cscope 15 $HOME/CC/work -c               0000219891
	@ALU.v

23 
module
 
	gALU
 #(

24 
parameter
 
	gDATA_WIDTH
 = 32

26 
input
 [5:0] 
ALU_operation
,

27 
	ginput
 [
DATA_WIDTH
-1:0] 
operand_A
,

28 
	ginput
 [
DATA_WIDTH
-1:0] 
operand_B
,

29 
	goutput
 [
DATA_WIDTH
-1:0] 
ALU_result


32 
wire
 signed [
DATA_WIDTH
-1:0] 
signed_operand_A
;

33 
wire
 signed [
DATA_WIDTH
-1:0] 
signed_operand_B
;

35 
	gwire
 [4:0] 
shamt
;

38 
	gwire
 [(
DATA_WIDTH
*2)-1:0] 
arithmetic_right_shift_double
;

39 
	gwire
 [
DATA_WIDTH
-1:0] 
arithmetic_right_shift
;

40 
wire
 signed [
DATA_WIDTH
-1:0] 
signed_less_than
;

41 
wire
 signed [
DATA_WIDTH
-1:0] 
signed_greater_than_equal
;

43 
assign
 
	gshamt
 = 
operand_B
 [4:0];

45 
assign
 
	gsigned_operand_A
 = 
operand_A
;

46 
assign
 
	gsigned_operand_B
 = 
operand_B
;

49 
assign
 
	garithmetic_right_shift_double
 = ({ {
DATA_WIDTH
{
operand_A
[DATA_WIDTH-1]}}, operand_A }) >> 
shamt
;

50 
assign
 
	garithmetic_right_shift
 = 
arithmetic_right_shift_double
[
DATA_WIDTH
-1:0];

51 
assign
 
	gsigned_less_than
 = 
signed_operand_A
 < 
signed_operand_B
;

52 
assign
 
	gsigned_greater_than_equal
 = 
signed_operand_A
 >= 
signed_operand_B
;

54 
assign
 
	gALU_result
 =

55 (
ALU_operation
 == 6'd0 )? operand_A + operand_B: /* ADD, ADDI, LB, LH, LW,

56 
LBU
, 
	gLHU
, 
	gSB
, 
	gSH
, 
	gSW
,

57 
	gAUIPC
, 
	gLUI
 */

58 (
	gALU_operation
 == 6'd1 )? operand_A: /* JAL, JALR */

59 (
ALU_operation
 == 6'd2 )? operand_A == operand_B: /* BEQ */

60 (
ALU_operation
 == 6'd3 )? operand_A != operand_B: /* BNE */

61 (
ALU_operation
 == 6'd4 )? signed_less_than: /* BLT, SLTI, SLT */

62 (
ALU_operation
 == 6'd5 )? signed_greater_than_equal: /* BGE */

63 (
ALU_operation
 == 6'd6 )? operand_A < operand_B: /* BLTU, SLTIU, SLTU*/

64 (
ALU_operation
 == 6'd7 )? operand_A >= operand_B: /* BGEU */

65 (
ALU_operation
 == 6'd8 )? operand_A ^ operand_B: /* XOR, XORI*/

66 (
ALU_operation
 == 6'd9 )? operand_A | operand_B: /* OR, ORI */

67 (
ALU_operation
 == 6'd10)? operand_A & operand_B: /* AND, ANDI */

68 (
ALU_operation
 == 6'd11)? operand_A << shamt: /* SLL, SLLI */

69 (
ALU_operation
 == 6'd12)? operand_A >> shamt: /* SRL, SRLI */

70 (
ALU_operation
 == 6'd13)? arithmetic_right_shift: /* SRA, SRAI */

71 (
ALU_operation
 == 6'd14)? operand_A - operand_B: /* SUB */

72 {
DATA_WIDTH
{1'b0}};

74 
endmodule


	@BRAM.v

23 
module
 
	gBRAM
 #(

24 
parameter
 
	gCORE
 = 0,

25 
parameter
 
	gDATA_WIDTH
 = 32,

26 
parameter
 
	gADDR_WIDTH
 = 8,

27 
parameter
 
	gSCAN_CYCLES_MIN
 = 0,

28 
parameter
 
	gSCAN_CYCLES_MAX
 = 1000

30 
clock
,

31 
	greset
,

32 
	greadEnable
,

33 
	greadAddress
,

34 
	greadData
,

35 
	gwriteEnable
,

36 
	gwriteAddress
,

37 
	gwriteData
,

38 
	gscan


41 
localparam
 
	gMEM_DEPTH
 = 1 << 
ADDR_WIDTH
;

43 
input
 
	gclock
;

44 
input
 
	greset
;

45 
input
 
	greadEnable
;

46 
	ginput
 [
ADDR_WIDTH
-1:0] 
readAddress
;

47 
	goutput
 [
DATA_WIDTH
-1:0] 
readData
;

48 
input
 
	gwriteEnable
;

49 
	ginput
 [
ADDR_WIDTH
-1:0] 
writeAddress
;

50 
	ginput
 [
DATA_WIDTH
-1:0] 
writeData
;

51 
input
 
	gscan
;

53 
	greg
 [
DATA_WIDTH
-1:0] 
readData
;

54 
	greg
 [
DATA_WIDTH
-1:0] 
ram
 [0:
MEM_DEPTH
-1];

60 
	galways
@(
posedge
 
	gclock
) 
	gbegin
 : 
RAM_READ


61 
readData
 <= (
readEnable
 & 
writeEnable
 & (
readAddress
 == 
writeAddress
)) ?

62 
writeData
 : 
readEnable
 ? 
ram
[
readAddress
] : 0;

63 
end


65 
	galways
@(
posedge
 
	gclock
) 
	gbegin
 : 
RAM_WRITE


66 if(
writeEnable
)

67 
ram
[
writeAddress
] <= 
writeData
;

68 
end


71 
	greg
 [31: 0] 
cycles
;

72 
	galways
 @ (
posedge
 
	gclock
) 
begin


73 
	gcycles
 <= 
reset
? 0 : 
cycles
 + 1;

74 if (
	gscan
 & ((
	gcycles
 >= 
SCAN_CYCLES_MIN
) & (
cycles
 <= 
SCAN_CYCLES_MAX
)))
begin


75 
$display
 ("------ Core %d BRAM Unit - Current Cycle %d --------", 
CORE
, 
cycles
);

76 
$display
 ("| Read [%b]", 
readEnable
);

77 
$display
 ("| Read Address[%h]", 
readAddress
);

78 
$display
 ("| Read Data [%h]", 
readData
);

79 
$display
 ("| Write [%b]", 
writeEnable
);

80 
$display
 ("| Write Addres[%h]", 
writeAddress
);

81 
$display
 ("| Write Data [%h]", 
writeData
);

82 
$display
 ("----------------------------------------------------------------------");

83 
end


84 
end


86 
	gendmodule


	@Dual_core_2_ways_single_cycle.v

24 
module
 
	gDual_core_2_ways_single_cycle
 #(

25 
parameter
 
	gNUM_CORES
=2,

26 
parameter
 
	gDATA_WIDTH
=32,

27 
parameter
 
	gADDRESS_BITS
=32,

28 
parameter
 
	gADDRESS_WIDTH
=32,

29 
parameter
 
	gMEM_ADDRESS_BITS
=10,

30 
parameter
 
	gSCAN_CYCLES_MIN
=0,

31 
parameter
 
	gSCAN_CYCLES_MAX
=1000

33 
input
 
clock
,

34 
input
 
	greset
,

36 
input
 
	gstart
,

37 
	ginput
 [
NUM_CORES
*
ADDRESS_BITS
-1:0] 
program_address
,

39 
	goutput
 [
NUM_CORES
*
ADDRESS_BITS
-1:0] 
PC
,

41 
input
 
	gscan


44 
localparam
 
	gMSG_BITS
=4;

45 
localparam
 
	gL2_OFFSET
=2;

46 
localparam
 
	gL2_WIDTH
=
DATA_WIDTH
*(1 << 
L2_OFFSET
);

49 
	gwire
 [
NUM_CORES
-1:0] 
fetch_read
;

50 
	gwire
 [
NUM_CORES
*
ADDRESS_BITS
-1:0] 
fetch_address_out
;

51 
	gwire
 [
NUM_CORES
*
DATA_WIDTH
-1:0] 
fetch_data_in
;

52 
	gwire
 [
NUM_CORES
*
ADDRESS_BITS
-1:0] 
fetch_address_in
;

53 
	gwire
 [
NUM_CORES
-1:0] 
fetch_valid
;

54 
	gwire
 [
NUM_CORES
-1:0] 
fetch_ready
;

56 
	gwire
 [
NUM_CORES
-1:0] 
memory_read
;

57 
	gwire
 [
NUM_CORES
-1:0] 
memory_write
;

58 
	gwire
 [
NUM_CORES
*
DATA_WIDTH
/8-1:0] 
memory_byte_en
;

59 
	gwire
 [
NUM_CORES
*
ADDRESS_BITS
-1:0] 
memory_address_out
;

60 
	gwire
 [
NUM_CORES
*
DATA_WIDTH
-1:0] 
memory_data_out
;

61 
	gwire
 [
NUM_CORES
*
DATA_WIDTH
-1:0] 
memory_data_in
;

62 
	gwire
 [
NUM_CORES
*
ADDRESS_BITS
-1:0] 
memory_address_in
;

63 
	gwire
 [
NUM_CORES
-1:0] 
memory_valid
;

64 
	gwire
 [
NUM_CORES
-1:0] 
memory_ready
;

66 
	gwire
 [
NUM_CORES
*
DATA_WIDTH
-1:0] 
i_mem_data_out
;

67 
	gwire
 [
NUM_CORES
*
ADDRESS_BITS
-1:0] 
i_mem_address_out
;

68 
	gwire
 [
NUM_CORES
-1:0] 
i_mem_valid
;

69 
	gwire
 [
NUM_CORES
-1:0] 
i_mem_ready
;

70 
	gwire
 [
NUM_CORES
-1:0] 
i_mem_read
;

71 
	gwire
 [
NUM_CORES
*
ADDRESS_BITS
-1:0] 
i_mem_address_in
;

73 
	gwire
 [
NUM_CORES
*
DATA_WIDTH
-1:0] 
d_mem_data_out
;

74 
	gwire
 [
NUM_CORES
*
ADDRESS_BITS
-1:0] 
d_mem_address_out
;

75 
	gwire
 [
NUM_CORES
-1:0] 
d_mem_valid
;

76 
	gwire
 [
NUM_CORES
-1:0] 
d_mem_ready
;

77 
	gwire
 [
NUM_CORES
-1:0] 
d_mem_read
;

78 
	gwire
 [
NUM_CORES
-1:0] 
d_mem_write
;

79 
	gwire
 [
NUM_CORES
*
DATA_WIDTH
/8-1:0] 
d_mem_byte_en
;

80 
	gwire
 [
NUM_CORES
*
ADDRESS_BITS
-1:0] 
d_mem_address_in
;

81 
	gwire
 [
NUM_CORES
*
DATA_WIDTH
-1:0] 
d_mem_data_in
;

83 
	gwire
 [
MSG_BITS
-1:0] 
intf2cachehier_msg
;

84 
	gwire
 [
ADDRESS_BITS
-1:0] 
intf2cachehier_address
;

85 
	gwire
 [
L2_WIDTH
-1:0] 
intf2cachehier_data
;

86 
	gwire
 [
MSG_BITS
-1:0] 
cachehier2intf_msg
;

87 
	gwire
 [
ADDRESS_BITS
-1:0] 
cachehier2intf_address
;

88 
	gwire
 [
L2_WIDTH
-1:0] 
cachehier2intf_data
;

90 
	gwire
 [
MSG_BITS
-1:0] 
mem2intf_msg
;

91 
	gwire
 [
ADDRESS_BITS
-1:0] 
mem2intf_address
;

92 
	gwire
 [
DATA_WIDTH
-1:0] 
mem2intf_data
;

93 
	gwire
 [
MSG_BITS
-1:0] 
intf2mem_msg
;

94 
	gwire
 [
ADDRESS_BITS
-1:0] 
intf2mem_address
;

95 
	gwire
 [
DATA_WIDTH
-1:0] 
intf2mem_data
;

98 
genvar
 
	gi
;

99 
generate


100 for (
	gi
 = 0; i < 
	gNUM_CORES
; i = 
i
+1) 
begin
 : 
CORES


101 
assign
 
PC
[
i
*
ADDRESS_WIDTH
 +: ADDRESS_WIDTH] = 
fetch_address_in
[i*ADDRESS_WIDTH +: ADDRESS_WIDTH];

102 
	gsingle_cycle_core
 #(

103 .
CORE
(
i
),

104 .
DATA_WIDTH
(DATA_WIDTH),

105 .
ADDRESS_BITS
(ADDRESS_BITS),

106 .
SCAN_CYCLES_MIN
(SCAN_CYCLES_MIN),

107 .
SCAN_CYCLES_MAX
(SCAN_CYCLES_MAX),

108 .
	$RESET_PC
(0)

109 ) 
	`core
(

110 .
	`clock
(
clock
),

111 .
	`reset
(
reset
),

112 .
	`start
(
start
),

113 .
	`program_address
(
program_address
[
i
*
ADDRESS_BITS
 +: ADDRESS_BITS]),

115 .
	`fetch_valid
(
fetch_valid
[
i
 +: 1]),

116 .
	`fetch_ready
(
fetch_ready
[
i
 +: 1]),

117 .
	`fetch_data_in
(
fetch_data_in
[
i
*
DATA_WIDTH
 +: DATA_WIDTH]),

118 .
	`fetch_address_in
(
fetch_address_in
[
i
*
ADDRESS_WIDTH
 +: ADDRESS_WIDTH]),

119 .
	`memory_valid
(
memory_valid
[
i
 +: 1]),

120 .
	`memory_ready
(
memory_ready
[
i
 +: 1]),

121 .
	`memory_data_in
(
memory_data_in
[
i
*
DATA_WIDTH
 +: DATA_WIDTH]),

122 .
	`memory_address_in
(
memory_address_in
[
i
*
ADDRESS_BITS
 +: ADDRESS_BITS]),

123 .
	`fetch_read
(
fetch_read
[
i
 +: 1]),

124 .
	`fetch_address_out
(
fetch_address_out
[
i
*
ADDRESS_BITS
 +: ADDRESS_BITS]),

125 .
	`memory_read
(
memory_read
[
i
 +: 1]),

126 .
	`memory_write
(
memory_write
[
i
 +: 1]),

127 .
	`memory_byte_en
(
memory_byte_en
[
i
*
DATA_WIDTH
/8 +: DATA_WIDTH/8]),

128 .
	`memory_address_out
(
memory_address_out
[
i
*
ADDRESS_BITS
 +: ADDRESS_BITS]),

129 .
	`memory_data_out
(
memory_data_out
[
i
*
ADDRESS_BITS
 +: ADDRESS_BITS]),

131 .
	`scan
(
scan
)

134 
memory_interface
 #(

135 .
	`DATA_WIDTH
(
DATA_WIDTH
),

136 .
	$ADDRESS_BITS
(
ADDRESS_BITS
)

137 ) 
	`mem_interface
(

139 .
	`fetch_read
(
fetch_read
[
i
 +: 1]),

140 .
	`fetch_address_out
(
fetch_address_out
[
i
*
ADDRESS_BITS
 +: ADDRESS_BITS]),

141 .
	`fetch_data_in
(
fetch_data_in
[
i
*
ADDRESS_BITS
 +: 
DATA_WIDTH
]),

142 .
	`fetch_address_in
(
fetch_address_in
[
i
*
ADDRESS_BITS
 +: 
ADDRESS_WIDTH
]),

143 .
	`fetch_valid
(
fetch_valid
[
i
 +: 1]),

144 .
	`fetch_ready
(
fetch_ready
[
i
 +: 1]),

146 .
	`memory_read
(
memory_read
[
i
 +: 1]),

147 .
	`memory_write
(
memory_write
[
i
 +: 1]),

148 .
	`memory_byte_en
(
memory_byte_en
[
i
*
DATA_WIDTH
/8 +: DATA_WIDTH/8]),

149 .
	`memory_address_out
(
memory_address_out
[
i
*
ADDRESS_BITS
 +: ADDRESS_BITS]),

150 .
	`memory_data_out
(
memory_data_out
[
i
*
ADDRESS_BITS
 +: ADDRESS_BITS]),

151 .
	`memory_data_in
(
memory_data_in
[
i
*
DATA_WIDTH
 +: DATA_WIDTH]),

152 .
	`memory_address_in
(
memory_address_in
[
i
*
ADDRESS_BITS
 +: ADDRESS_BITS]),

153 .
	`memory_valid
(
memory_valid
[
i
 +: 1]),

154 .
	`memory_ready
(
memory_ready
[
i
 +: 1]),

156 .
	`i_mem_data_out
(
i_mem_data_out
[
i
*
DATA_WIDTH
 +: DATA_WIDTH]),

157 .
	`i_mem_address_out
(
i_mem_address_out
[
i
*
ADDRESS_BITS
 +: ADDRESS_BITS]),

158 .
	`i_mem_valid
(
i_mem_valid
[
i
 +: 1]),

159 .
	`i_mem_ready
(
i_mem_ready
[
i
 +: 1]),

160 .
	`i_mem_read
(
i_mem_read
[
i
 +: 1]),

161 .
	`i_mem_address_in
(
i_mem_address_in
[
i
*
ADDRESS_BITS
 +: ADDRESS_BITS]),

163 .
	`d_mem_data_out
(
d_mem_data_out
[
i
*
DATA_WIDTH
 +: DATA_WIDTH]),

164 .
	`d_mem_address_out
(
d_mem_address_out
[
i
*
ADDRESS_BITS
 +: ADDRESS_BITS]),

165 .
	`d_mem_valid
(
d_mem_valid
[
i
 +: 1]),

166 .
	`d_mem_ready
(
d_mem_ready
[
i
 +: 1]),

167 .
	`d_mem_read
(
d_mem_read
[
i
 +: 1]),

168 .
	`d_mem_write
(
d_mem_write
[
i
 +: 1]),

169 .
	`d_mem_byte_en
(
d_mem_byte_en
[
i
*
DATA_WIDTH
/8 +: DATA_WIDTH/8]),

170 .
	`d_mem_address_in
(
d_mem_address_in
[
i
*
ADDRESS_BITS
 +: ADDRESS_BITS]),

171 .
	`d_mem_data_in
(
d_mem_data_in
[
i
*
DATA_WIDTH
 +: DATA_WIDTH]),

173 .
	`scan
(
scan
)

175 
end


177 
endgenerate


182 
cache_hierarchy
 #(

183 .
	`STATUS_BITS_L1
(2),

184 .
	`STATUS_BITS_L2
(3),

185 .
	`COHERENCE_BITS
(2),

186 .
	`OFFSET_BITS_L1
({32'd2, 32'
d2
, 32'd2, 32'
	}
d2}),

187 .
OFFSET_BITS_L2
(2),

188 .
DATA_WIDTH
(DATA_WIDTH),

189 .
NUMBER_OF_WAYS_L1
({32'd2, 32'
d2
, 32'd2, 32'd2}),

190 .
NUMBER_OF_WAYS_L2
(2),

191 .
REPLACEMENT_MODE_L1
(1'b0),

192 .
REPLACEMENT_MODE_L2
(1'b0),

193 .
ADDRESS_BITS
(ADDRESS_BITS),

194 .
INDEX_BITS_L1
({32'd5, 32'
d5
, 32'd5, 32'd5}),

195 .
INDEX_BITS_L2
(5),

196 .
MSG_BITS
(4),

197 .
NUM_L1_CACHES
(4),

198 .
BUS_OFFSET_BITS
(2),

199 .
	$MAX_OFFSET_BITS
(2)

200 ) 
	`cache_hier
(

201 .
	`clock
(
clock
),

202 .
	`reset
(
reset
),

203 .
	`read
({
d_mem_read
, 
i_mem_read
}),
	}
i_mem_read}),

204 .
write
({
d_mem_write
, {
NUM_CORES
{1'b0}}}),

205 .
w_byte_en
({
d_mem_byte_en
, {
NUM_CORES
*
DATA_WIDTH
/8{1'b0}}}),

206 .
invalidate
({
NUM_CORES
*2{1'b0}}),

207 .
flush
({
NUM_CORES
*2{1'b0}}),

208 .
address
({
d_mem_address_in
, 
i_mem_address_in
}),

209 .
data_in
({
d_mem_data_in
, {
DATA_WIDTH
*
NUM_CORES
{1'b0}}}),

210 .
report
(
scan
),

211 .
data_out
({
d_mem_data_out
, 
i_mem_data_out
}),

212 .
out_address
({
d_mem_address_out
, 
i_mem_address_out
}),

213 .
ready
({
d_mem_ready
, 
i_mem_ready
}),

214 .
valid
({
d_mem_valid
, 
i_mem_valid
}),

215 .
mem2cachehier_msg
(
intf2cachehier_msg
),

216 .
mem2cachehier_address
(
intf2cachehier_address
),

217 .
mem2cachehier_data
(
intf2cachehier_data
),

218 .
cachehier2mem_msg
(
cachehier2intf_msg
),

219 .
cachehier2mem_address
(
cachehier2intf_address
),

220 .
cachehier2mem_data
(
cachehier2intf_data
)

226 
main_memory_interface
 #(

227 .
OFFSET_BITS
(
L2_OFFSET
),

228 .
DATA_WIDTH
(DATA_WIDTH),

229 .
ADDRESS_WIDTH
(
ADDRESS_BITS
),

230 .
MSG_BITS
(MSG_BITS)

231 ) 
mem_intf
(

232 .
clock
(clock),

233 .
reset
(reset),

234 .
cache2interface_msg
(
cachehier2intf_msg
),

235 .
cache2interface_address
(
cachehier2intf_address
),

236 .
cache2interface_data
(
cachehier2intf_data
),

237 .
interface2cache_msg
(
intf2cachehier_msg
),

238 .
interface2cache_address
(
intf2cachehier_address
),

239 .
interface2cache_data
(
intf2cachehier_data
),

240 .
network2interface_msg
(4'd0),

241 .
network2interface_address
(0),

242 .
network2interface_data
(0),

243 .
interface2network_msg
(),

244 .
interface2network_address
(),

245 .
interface2network_data
(),

246 .
mem2interface_msg
(
mem2intf_msg
),

247 .
mem2interface_address
(
mem2intf_address
),

248 .
mem2interface_data
(
mem2intf_data
),

249 .
interface2mem_msg
(
intf2mem_msg
),

250 .
interface2mem_address
(
intf2mem_address
),

251 .
interface2mem_data
(
intf2mem_data
)

256 
main_memory
 #(

257 .
DATA_WIDTH
(DATA_WIDTH),

258 .
ADDRESS_WIDTH
(
ADDRESS_BITS
),

259 .
MSG_BITS
(MSG_BITS),

260 .
INDEX_BITS
(10),

261 .
NUM_PORTS
(1),

262 .
INIT_FILE
("")

263 ) 
memory
(

264 .
clock
(clock),

265 .
reset
(reset),

266 .
msg_in
(
intf2mem_msg
),

267 .
address
(
intf2mem_address
),

268 .
data_in
(
intf2mem_data
),

269 .
msg_out
(
mem2intf_msg
),

270 .
address_out
(
mem2intf_address
),

271 .
data_out
(
mem2intf_data
)

273 
endmodule


	@L1_bus_interface.v

23 
module
 
	gL1_bus_interface
 #(

24 
parameter
 
	gCACHE_OFFSET_BITS
 = 2,

25 
	gBUS_OFFSET_BITS
 = 1,

26 
	gDATA_WIDTH
 = 32,

27 
	gADDRESS_WIDTH
 = 32,

28 
	gMSG_BITS
 = 4,

29 
	gMAX_OFFSET_BITS
 = 3

31 
clock
,

32 
	greset
,

33 
	gcache_offset
,

35 
	gcache_msg_in
,

36 
	gcache_address_in
,

37 
	gcache_data_in
,

38 
	gcache_msg_out
,

39 
	gcache_address_out
,

40 
	gcache_data_out
,

42 
	gsnoop_msg_in
,

43 
	gsnoop_address_in
,

44 
	gsnoop_data_in
,

45 
	gsnoop_msg_out
,

46 
	gsnoop_address_out
,

47 
	gsnoop_data_out
,

49 
	gbus_msg_in
,

50 
	gbus_address_in
,

51 
	gbus_data_in
,

52 
	gbus_msg_out
,

53 
	gbus_address_out
,

54 
	gbus_data_out
,

55 
	gactive_offset
,

57 
	gbus_master
,

58 
	greq_ready


62 
function
 
integer
 
	glog2
;

63 
input
 
integer
 
	gvalue
;

64 
begin


65 
	gvalue
 = 
value
-1;

66 for (
	glog2
=0; 
	gvalue
>0; log2=
log2
+1)

67 
value
 = value >> 1;

68 
end


69 
endfunction


71 
localparam
 
	gCACHE_WORDS
 = 1 << 
CACHE_OFFSET_BITS
;

72 
localparam
 
	gBUS_WORDS
 = 1 << 
BUS_OFFSET_BITS
;

73 
localparam
 
	gCACHE_WIDTH
 = 
DATA_WIDTH
*
CACHE_WORDS
;

74 
localparam
 
	gBUS_WIDTH
 = 
DATA_WIDTH
*
BUS_WORDS
;

76 
localparam
 
	gIDLE
 = 4'd0,

77 
SNOOPER_REQ
 = 4'd1,

78 
CACHE_REQ
 = 4'd2,

79 
SN_WAIT_FOR_BUS
 = 4'd3,

80 
SN_WAIT_FOR_READY
 = 4'd4,

81 
SN_TRANSFER
 = 4'd5,

82 
SN_WAIT_RESP
 = 4'd6,

83 
WAIT_FOR_BUS
 = 4'd7,

84 
WAIT_RESP
 = 4'd8,

85 
TRANSFER
 = 4'd9,

86 
RECEIVE
 = 4'd10,

87 
WAIT_FOR_SNOOP
 = 4'd11,

88 
WAIT_FOR_CACHE
 = 4'd12,

89 
HOLD_BUS_SN
 = 4'd13;

96 `
include
 "./params.h"

98 
input
 
clock
, 
	greset
;

99 
	ginput
 [
	$log2
(
CACHE_OFFSET_BITS
):0] 
cache_offset
;

101 
input
 [
MSG_BITS
-1: 0] 
cache_msg_in
 ;

102 
input
 [
ADDRESS_WIDTH
-1: 0] 
cache_address_in
 ;

103 
input
 [
CACHE_WIDTH
-1: 0] 
cache_data_in
 ;

104 
output
 [
MSG_BITS
-1: 0] 
cache_msg_out
 ;

105 
output
 [
ADDRESS_WIDTH
-1: 0] 
cache_address_out
;

106 
output
 [
CACHE_WIDTH
-1: 0] 
cache_data_out
 ;

108 
input
 [
MSG_BITS
-1: 0] 
snoop_msg_in
 ;

109 
input
 [
ADDRESS_WIDTH
-1: 0] 
snoop_address_in
 ;

110 
input
 [
CACHE_WIDTH
-1: 0] 
snoop_data_in
 ;

111 
output
 [
MSG_BITS
-1: 0] 
snoop_msg_out
 ;

112 
output
 [
ADDRESS_WIDTH
-1: 0] 
snoop_address_out
;

113 
output
 [
CACHE_WIDTH
-1: 0] 
snoop_data_out
 ;

115 
input
 [
MSG_BITS
-1: 0] 
bus_msg_in
 ;

116 
input
 [
ADDRESS_WIDTH
-1: 0] 
bus_address_in
 ;

117 
input
 [
BUS_WIDTH
-1: 0] 
bus_data_in
 ;

118 
output
 [
MSG_BITS
-1: 0] 
bus_msg_out
 ;

119 
output
 [
ADDRESS_WIDTH
-1: 0] 
bus_address_out
 ;

120 
output
 [
BUS_WIDTH
-1: 0] 
bus_data_out
 ;

121 
output
 [
	$log2
(
MAX_OFFSET_BITS
):0] 
active_offset
;

123 
input
 
req_ready
;

124 
input
 
bus_master
;

127 
genvar
 
i
;

128 
integer
 
j
;

129 
reg
 [3:0] 
state
;

130 
reg
 [
DATA_WIDTH
-1:0] 
r_cache_data_out
 [
CACHE_WORDS
-1:0];

131 
reg
 [
DATA_WIDTH
-1:0] 
r_snoop_data_out
 [
CACHE_WORDS
-1:0];

132 
reg
 [
DATA_WIDTH
-1:0] 
r_bus_data_out
 [
BUS_WORDS
-1: 0];

134 
reg
 [
MSG_BITS
-1: 0] 
r_cache_msg_out
, 
r_bus_msg_out
, 
r_snoop_msg_out
;

135 
reg
 [
ADDRESS_WIDTH
-1:0] 
r_cache_address_out
, 
r_bus_address_out
,

136 
r_snoop_address_out
;

138 
reg
 [
MAX_OFFSET_BITS
:0] 
block_counter
;

139 
reg
 [
MAX_OFFSET_BITS
:0] 
word_counter
;

141 
reg
 
current_owner
;

142 
reg
 [
MSG_BITS
-1:0] 
curr_msg
;

143 
reg
 [
ADDRESS_WIDTH
-1:0] 
curr_address
;

144 
reg
 [
DATA_WIDTH
-1:0] 
curr_data
 [
CACHE_WORDS
-1:0];

146 
wire
 [
DATA_WIDTH
-1:0] 
w_cache_data_in
 [
CACHE_WORDS
-1: 0];

147 
wire
 [
DATA_WIDTH
-1:0] 
w_snoop_data_in
 [
CACHE_WORDS
-1: 0];

148 
wire
 [
DATA_WIDTH
-1:0] 
w_bus_data_in
 [
BUS_WORDS
-1: 0];

150 
wire
 [
MAX_OFFSET_BITS
-1:0] 
offset_diff
;

151 
wire
 [
CACHE_OFFSET_BITS
 :0] 
current_words
;

152 
wire
 [
MAX_OFFSET_BITS
 :0] 
ratio
;

153 
wire
 
wider_bus
, 
wider_line
;

154 
wire
 
cache_req
, 
snoop_req
;

156 
generate


157 for(
i
=0; i<
CACHE_WORDS
; i=i+1)
begin
 : 
SPLIT_INPUTS


158 
assign
 
w_cache_data_in
[
i
] = (i < 
current_words
) ?

159 
cache_data_in
[
i
*
DATA_WIDTH
 +: DATA_WIDTH] :

160 {
DATA_WIDTH
{1'b0}};

161 
assign
 
w_snoop_data_in
[
i
] = (i < 
current_words
) ?

162 
snoop_data_in
[
i
*
DATA_WIDTH
 +: DATA_WIDTH] :

163 {
DATA_WIDTH
{1'b0}};

164 
end


165 for(
i
=0; i<
BUS_WORDS
; i=i+1)
begin
: 
SPLIT_BUS


166 
assign
 
w_bus_data_in
[
i
] = 
bus_data_in
[i*
DATA_WIDTH
 +: DATA_WIDTH];

167 
end


168 
endgenerate


170 
assign
 
current_words
 = 1 << 
cache_offset
;

172 
assign
 
offset_diff
 = (
cache_offset
 >= 
BUS_OFFSET_BITS
) ?

173 (
cache_offset
 - 
BUS_OFFSET_BITS
) :

174 (
BUS_OFFSET_BITS
 - 
cache_offset
 ) ;

176 
assign
 
ratio
 = 1 << 
offset_diff
;

177 
assign
 
wider_bus
 = 
BUS_OFFSET_BITS
 >= 
cache_offset
;

178 
assign
 
wider_line
 = 
cache_offset
 > 
BUS_OFFSET_BITS
;

180 
assign
 
cache_req
 = (
cache_msg_in
 == 
R_REQ
) | (cache_msg_in == 
WB_REQ
) |

181 (
cache_msg_in
 == 
FLUSH
) | (cache_msg_in == 
FLUSH_S
) |

182 (
cache_msg_in
 == 
WS_BCAST
) | (cache_msg_in == 
RFO_BCAST
);

184 
assign
 
snoop_req
 = (
snoop_msg_in
 == 
C_WB
) | (snoop_msg_in == 
C_FLUSH
) |

185 (
snoop_msg_in
 == 
EN_ACCESS
);

188 
assign
 
active_offset
 = 
cache_offset
;

189 
assign
 
cache_msg_out
 = 
r_cache_msg_out
;

190 
assign
 
cache_address_out
 = 
r_cache_address_out
;

191 
assign
 
snoop_msg_out
 = 
r_snoop_msg_out
;

192 
assign
 
snoop_address_out
 = 
r_snoop_address_out
;

193 
assign
 
bus_msg_out
 = 
r_bus_msg_out
;

194 
assign
 
bus_address_out
 = 
r_bus_address_out
;

196 
generate


197 for(
i
=0; i<
CACHE_WORDS
; i=i+1)
begin
: 
OUTDATA


198 
assign
 
cache_data_out
[
i
*
DATA_WIDTH
 +: DATA_WIDTH] = 
r_cache_data_out
[i];

199 
assign
 
snoop_data_out
[
i
*
DATA_WIDTH
 +: DATA_WIDTH] = 
r_snoop_data_out
[i];

200 
end


201 for(
i
=0; i<
BUS_WORDS
; i=i+1)
begin
: 
OUTBUS


202 
assign
 
bus_data_out
[
i
*
DATA_WIDTH
 +: DATA_WIDTH] = 
r_bus_data_out
[i];

203 
end


204 
endgenerate


208 
always
 @(
posedge
 
clock
)
begin


209 if(
reset
)
begin


210 
r_cache_msg_out
 <= 
NO_REQ
;

211 
r_snoop_msg_out
 <= 
NO_REQ
;

212 
r_bus_msg_out
 <= 
NO_REQ
;

213 
r_cache_address_out
 <= {
ADDRESS_WIDTH
{1'b0}};

214 
r_snoop_address_out
 <= {
ADDRESS_WIDTH
{1'b0}};

215 
r_bus_address_out
 <= {
ADDRESS_WIDTH
{1'b0}};

216 
block_counter
 <= {(
MAX_OFFSET_BITS
+1){1'b0}};

217 
word_counter
 <= {(
MAX_OFFSET_BITS
+1){1'b0}};

218 
current_owner
 <= 1'b0;

219 for(
j
=0; j<
CACHE_WORDS
; j=j+1)
begin


220 
r_cache_data_out
[
j
] <= {
DATA_WIDTH
{1'b0}};

221 
r_snoop_data_out
[
j
] <= {
DATA_WIDTH
{1'b0}};

222 
curr_data
[
j
] <= {
DATA_WIDTH
{1'b0}};

223 
end


224 for(
j
=0; j<
BUS_WORDS
; j=j+1)
begin


225 
r_bus_data_out
[
j
] <= {
DATA_WIDTH
{1'b0}};

226 
end


227 
state
 <= 
IDLE
;

228 
end


229 else if(~
current_owner
 & 
snoop_req
)
begin


230 
curr_msg
 <= 
snoop_msg_in
;

231 
curr_address
 <= 
snoop_address_in
;

232 for(
j
=0; j<
CACHE_WORDS
; j=j+1)
begin


233 
curr_data
[
j
] <= 
snoop_data_in
[j*
DATA_WIDTH
 +: DATA_WIDTH];

234 
end


235 
current_owner
 <= 1'b1;

236 
state
 <= 
SNOOPER_REQ
;

237 
end


238 else 
begin


239 case(
state
)

240 
IDLE
:
begin


241 if(
snoop_req
)
begin


242 
curr_msg
 <= 
snoop_msg_in
;

243 
curr_address
 <= 
snoop_address_in
;

244 for(
j
=0; j<
CACHE_WORDS
; j=j+1)
begin


245 
curr_data
[
j
] <= 
snoop_data_in
[j*
DATA_WIDTH
 +: DATA_WIDTH];

246 
end


247 
current_owner
 <= 1'b1;

248 
state
 <= 
SNOOPER_REQ
;

249 
end


250 else if(
cache_req
)
begin


251 
curr_msg
 <= 
cache_msg_in
;

252 
curr_address
 <= 
cache_address_in
;

253 for(
j
=0; j<
CACHE_WORDS
; j=j+1)
begin


254 
curr_data
[
j
] <= 
cache_data_in
[j*
DATA_WIDTH
 +: DATA_WIDTH];

255 
end


256 
current_owner
 <= 1'b0;

257 
state
 <= 
CACHE_REQ
;

258 
end


260 
state
 <= 
IDLE
;

261 
end


262 
SNOOPER_REQ
:
begin


263 
r_bus_msg_out
 <= 
curr_msg
;

264 
r_bus_address_out
 <= 
curr_address
;

265 
state
 <= (
curr_msg
 == 
EN_ACCESS
) ? 
SN_WAIT_FOR_READY
 :

266 
SN_WAIT_FOR_BUS
;

267 
end


268 
SN_WAIT_FOR_READY
:
begin


269 if(
req_ready
)
begin


270 
r_bus_msg_out
 <= 
NO_REQ
;

271 
r_bus_address_out
 <= {
ADDRESS_WIDTH
{1'b0}};

272 
r_snoop_msg_out
 <= 
EN_ACCESS
;

273 
r_snoop_address_out
 <= 
curr_address
;

274 
state
 <= 
WAIT_FOR_SNOOP
;

275 
end


277 
state
 <= 
SN_WAIT_FOR_READY
;

278 
end


279 
SN_WAIT_FOR_BUS
:
begin


280 if(
bus_master
)
begin


281 if(
wider_line
)
begin


282 
r_bus_address_out
 <= 
curr_address
;

283 for(
j
=0; j<
BUS_WORDS
; j=j+1)
begin


284 
r_bus_data_out
[
j
] = 
curr_data
[j];

285 
end


286 
block_counter
 <= 1;

287 
word_counter
 <= 
BUS_WORDS
;

288 
state
 <= 
SN_TRANSFER
;

289 
end


290 else if(
wider_bus
)
begin


291 
r_bus_address_out
 <= 
curr_address
;

292 for(
j
=0; j<
BUS_WORDS
; j=j+1)
begin


293 if(
j
 < 
current_words
)

294 
r_bus_data_out
[
j
] = 
curr_data
[j];

296 
r_bus_data_out
[
j
] = {
DATA_WIDTH
{1'b0}};

297 
end


298 
block_counter
 <= 0;

299 
state
 <= 
SN_WAIT_RESP
;

300 
end


301 
end


303 
state
 <= 
SN_WAIT_FOR_BUS
;

304 
end


305 
SN_WAIT_RESP
:
begin


306 if(
bus_msg_in
 == 
MEM_C_RESP
)
begin


307 for(
j
=0; j<
BUS_WORDS
; j=j+1)
begin


308 
r_bus_data_out
[
j
] <= {
DATA_WIDTH
{1'b0}};

309 
end


310 
r_snoop_msg_out
 <= 
MEM_RESP
;

311 
r_snoop_address_out
 <= 
curr_address
;

312 for(
j
=0; j<
CACHE_WORDS
; j=j+1)
begin


313 
r_snoop_data_out
[
j
] <= {
DATA_WIDTH
{1'b0}};

314 
end


315 
r_bus_msg_out
 <= 
HOLD_BUS
;

316 
r_bus_address_out
 <= {
ADDRESS_WIDTH
{1'b0}};

317 for(
j
=0; j<
BUS_WORDS
; j=j+1)
begin


318 
r_bus_data_out
[
j
] <= {
DATA_WIDTH
{1'b0}};

319 
end


320 
state
 <= 
WAIT_FOR_SNOOP
;

321 
end


322 
end


323 
SN_TRANSFER
:
begin


324 if(
block_counter
 == 
ratio
)
begin


325 
state
 <= 
SN_WAIT_RESP
;

326 
end


327 else 
begin


328 for(
j
=0; j<
BUS_WORDS
; j=j+1)
begin


329 
r_bus_data_out
[
j
] <= 
curr_data
[
word_counter
 + j];

330 
end


331 
block_counter
 <= block_counter + 1;

332 
word_counter
 <= word_counter + 
BUS_WORDS
;

333 
state
 <= 
SN_TRANSFER
;

334 
end


335 
end


336 
CACHE_REQ
:
begin


337 
r_bus_msg_out
 <= 
curr_msg
;

338 
r_bus_address_out
 <= 
curr_address
;

339 
state
 <= 
WAIT_FOR_BUS
;

340 
end


341 
WAIT_FOR_BUS
:
begin


342 if(
bus_master
)
begin


343 if((
curr_msg
 == 
R_REQ
) | (curr_msg == 
RFO_BCAST
) |

344 (
curr_msg
 == 
FLUSH_S
) | (curr_msg == 
WS_BCAST
 ) )
begin


345 
state
 <= 
WAIT_RESP
;

346 
end


347 else 
begin


348 if(
wider_line
)
begin


349 for(
j
=0; j<
BUS_WORDS
; j=j+1)
begin


350 
r_bus_data_out
[
j
] <= 
curr_data
[j];

351 
end


352 
block_counter
 <= 1;

353 
word_counter
 <= 
BUS_WORDS
;

354 
state
 <= 
TRANSFER
;

355 
end


356 else if(
wider_bus
)
begin


357 for(
j
=0; j<
BUS_WORDS
; j=j+1)
begin


358 if(
j
 < 
current_words
)

359 
r_bus_data_out
[
j
] <= 
curr_data
[j];

361 
r_bus_data_out
[
j
] <= {
DATA_WIDTH
{1'b0}};

362 
end


363 
state
 <= 
WAIT_RESP
;

364 
end


365 
end


366 
end


368 
state
 <= 
WAIT_FOR_BUS
;

369 
end


370 
WAIT_RESP
:
begin


371 if((
curr_msg
 == 
WB_REQ
) | (curr_msg == 
FLUSH
) |

372 (
curr_msg
 == 
FLUSH_S
))
begin


373 if(
bus_msg_in
 == 
MEM_RESP
)
begin


374 
r_bus_msg_out
 <= 
NO_REQ
;

375 
r_bus_address_out
 <= {
ADDRESS_WIDTH
{1'b0}};

376 for(
j
=0; j<
BUS_WORDS
; j=j+1)
begin


377 
r_bus_data_out
[
j
] <= {
DATA_WIDTH
{1'b0}};

378 
end


379 
r_cache_msg_out
 <= 
MEM_RESP
;

380 
r_cache_address_out
 <= 
curr_address
;

381 for(
j
=0; j<
CACHE_WORDS
; j=j+1)
begin


382 
r_cache_data_out
[
j
] <= {
DATA_WIDTH
{1'b0}};

383 
end


384 
state
 <= 
WAIT_FOR_CACHE
;

385 
end


387 
state
 <= 
WAIT_RESP
;

388 
end


389 else if(
curr_msg
 == 
WS_BCAST
)
begin


390 if(
req_ready
)
begin


391 
r_cache_msg_out
 <= 
EN_ACCESS
;

392 
r_cache_address_out
 <= 
curr_address
;

393 for(
j
=0; j<
CACHE_WORDS
; j=j+1)
begin


394 
r_cache_data_out
[
j
] <= {
DATA_WIDTH
{1'b0}};

395 
end


396 
state
 <= 
WAIT_FOR_CACHE
;

397 
end


399 
state
 <= 
WAIT_RESP
;

400 
end


401 else 
begin


402 if((
bus_msg_in
 == 
MEM_RESP
) | (bus_msg_in == 
MEM_RESP_S
))
begin


403 if(
wider_line
)
begin


404 for(
j
=0; j<
BUS_WORDS
; j=j+1)
begin


405 
r_cache_data_out
[
j
] <= 
w_bus_data_in
[j];

406 
end


407 
block_counter
 <= 1;

408 
word_counter
 <= 
BUS_WORDS
;

409 
state
 <= 
RECEIVE
;

410 
end


411 else if(
wider_bus
)
begin


412 
r_cache_msg_out
 <= 
bus_msg_in
;

413 
r_cache_address_out
 <= 
curr_address
;

414 for(
j
=0; j<
CACHE_WORDS
; j=j+1)
begin


415 
r_cache_data_out
[
j
] <= (j < 
BUS_WORDS
) ? 
w_bus_data_in
[j] :

416 {
DATA_WIDTH
{1'b0}};

417 
end


418 
state
 <= 
WAIT_FOR_CACHE
;

419 
end


420 
end


421 
end


422 
end


423 
TRANSFER
:
begin


424 if(
block_counter
 == 
ratio
)
begin


425 
state
 <= 
WAIT_RESP
;

426 
end


427 else 
begin


428 for(
j
=0; j<
BUS_WORDS
; j=j+1)
begin


429 
r_bus_data_out
[
j
] <= 
curr_data
[
word_counter
 + j];

430 
end


431 
block_counter
 <= block_counter + 1;

432 
word_counter
 <= word_counter + 
BUS_WORDS
;

433 
state
 <= 
TRANSFER
;

434 
end


435 
end


436 
RECEIVE
:
begin


437 if(
block_counter
 == 
ratio
-1)
begin


438 
r_cache_msg_out
 <= 
bus_msg_in
;

439 
r_cache_address_out
 <= 
curr_address
;

440 for(
j
=0; j<
BUS_WORDS
; j=j+1)
begin


441 
r_cache_data_out
[
word_counter
 + 
j
] <= 
w_bus_data_in
[j];

442 
end


443 
state
 <= 
WAIT_FOR_CACHE
;

444 
end


445 else 
begin


446 for(
j
=0; j<
BUS_WORDS
; j=j+1)
begin


447 
r_cache_data_out
[
word_counter
 + 
j
] <= 
w_bus_data_in
[j];

448 
end


449 
block_counter
 <= block_counter + 1;

450 
word_counter
 <= word_counter + 
BUS_WORDS
;

451 
state
 <= 
RECEIVE
;

452 
end


453 
end


454 
WAIT_FOR_CACHE
:
begin


455 
r_cache_msg_out
 <= 
NO_REQ
;

456 
r_cache_address_out
 <= {
ADDRESS_WIDTH
{1'b0}};

457 for(
j
=0; j<
CACHE_WORDS
; j=j+1)
begin


458 
r_cache_data_out
[
j
] <= {
DATA_WIDTH
{1'b0}};

459 
end


460 
r_bus_msg_out
 <= 
NO_REQ
;

461 
r_bus_address_out
 <= {
ADDRESS_WIDTH
{1'b0}};

462 for(
j
=0; j<
BUS_WORDS
; j=j+1)
begin


463 
r_bus_data_out
[
j
] <= {
DATA_WIDTH
{1'b0}};

464 
end


465 
current_owner
 <= 1'b0;

466 
state
 <= 
IDLE
;

467 
end


468 
WAIT_FOR_SNOOP
:
begin


469 
r_snoop_msg_out
 <= 
NO_REQ
;

470 
r_snoop_address_out
 <= {
ADDRESS_WIDTH
{1'b0}};

471 for(
j
=0; j<
CACHE_WORDS
; j=j+1)
begin


472 
r_snoop_data_out
[
j
] <= {
DATA_WIDTH
{1'b0}};

473 
end


474 if(
snoop_msg_in
 == 
NO_REQ
)
begin


475 
r_bus_msg_out
 <= 
NO_REQ
;

476 
r_bus_address_out
 <= {
ADDRESS_WIDTH
{1'b0}};

477 for(
j
=0; j<
BUS_WORDS
; j=j+1)
begin


478 
r_bus_data_out
[
j
] <= {
DATA_WIDTH
{1'b0}};

479 
end


480 
current_owner
 <= 1'b0;

481 
state
 <= 
IDLE
;

482 
end


483 else if(
snoop_msg_in
 == 
HOLD_BUS
)
begin


484 
r_bus_msg_out
 <= 
HOLD_BUS
;

485 
r_bus_address_out
 <= {
ADDRESS_WIDTH
{1'b0}};

486 for(
j
=0; j<
BUS_WORDS
; j=j+1)
begin


487 
r_bus_data_out
[
j
] <= {
DATA_WIDTH
{1'b0}};

488 
end


489 
current_owner
 <= 1'b1;

490 
state
 <= 
HOLD_BUS_SN
;

491 
end


492 else if(
snoop_msg_in
 == 
EN_ACCESS
)
begin


493 
r_bus_msg_out
 <= 
EN_ACCESS
;

494 
r_bus_address_out
 <= 
curr_address
;

495 for(
j
=0; j<
BUS_WORDS
; j=j+1)
begin


496 
r_bus_data_out
[
j
] <= {
DATA_WIDTH
{1'b0}};

497 
end


498 
state
 <= 
SN_WAIT_FOR_READY
;

499 
end


500 else 
begin


501 
state
 <= 
WAIT_FOR_SNOOP
;

502 
end


503 
end


504 
HOLD_BUS_SN
:
begin


505 if(
snoop_req
)
begin


506 
curr_msg
 <= 
snoop_msg_in
;

507 
curr_address
 <= 
snoop_address_in
;

508 for(
j
=0; j<
CACHE_WORDS
; j=j+1)
begin


509 
curr_data
[
j
] <= 
snoop_data_in
[j*
DATA_WIDTH
 +: DATA_WIDTH];

510 
end


511 
current_owner
 <= 1'b1;

512 
state
 <= 
SNOOPER_REQ
;

513 
end


515 
state
 <= 
HOLD_BUS_SN
;

516 
end


517 default:
begin


518 
state
 <= 
IDLE
;

519 
end


520 
endcase


521 
end


522 
end


524 
endmodule


	@L1cache_wrapper.v

23 
module
 
	gL1cache_wrapper
 #(

24 
parameter
 
	gSTATUS_BITS
 = 2,

25 
parameter
 
	gCOHERENCE_BITS
 = 2,

26 
parameter
 
	gCACHE_OFFSET_BITS
 = 2,

27 
parameter
 
	gDATA_WIDTH
 = 32,

28 
parameter
 
	gNUMBER_OF_WAYS
 = 4,

29 
parameter
 
	gADDRESS_BITS
 = 32,

30 
parameter
 
	gINDEX_BITS
 = 8,

31 
parameter
 
	gMSG_BITS
 = 4,

32 
parameter
 
	gBUS_OFFSET_BITS
 = 0,

33 
parameter
 
	gMAX_OFFSET_BITS
 = 3,

34 
parameter
 
	gREPLACEMENT_MODE
 = 1'b0,

35 
parameter
 
CORE
 = 0,

36 
parameter
 
	gCACHE_NO
 = 0

38 
clock
,

39 
	greset
,

41 
	gread
,

42 
	gwrite
,

43 
	gw_byte_en
,

44 
	ginvalidate
,

45 
	gflush
,

46 
	gaddress
,

47 
	gdata_in
,

48 
	greport
,

49 
	gdata_out
,

50 
	gout_address
,

51 
	gready
,

52 
	gvalid
,

54 
	gbus_msg_in
,

55 
	gbus_address_in
,

56 
	gbus_data_in
,

57 
	gbus_msg_out
,

58 
	gbus_address_out
,

59 
	gbus_data_out
,

60 
	gactive_offset
,

61 
	gbus_master
,

62 
	greq_ready
,

63 
	gcurr_offset


67 
function
 
integer
 
	glog2
;

68 
input
 
integer
 
	gvalue
;

69 
begin


70 
	gvalue
 = 
value
-1;

71 for (
	glog2
=0; 
	gvalue
>0; log2=
log2
+1)

72 
value
 = value >> 1;

73 
end


74 
endfunction


77 
localparam
 
	gCACHE_WORDS
 = 1 << 
CACHE_OFFSET_BITS
;

78 
localparam
 
	gBUS_WORDS
 = 1 << 
BUS_OFFSET_BITS
;

79 
localparam
 
	gCACHE_WIDTH
 = 
CACHE_WORDS
 * 
DATA_WIDTH
;

80 
localparam
 
	gBUS_WIDTH
 = 
BUS_WORDS
 * 
DATA_WIDTH
;

81 
localparam
 
	gTAG_BITS
 = 
ADDRESS_BITS
 - 
INDEX_BITS
 - 
CACHE_OFFSET_BITS
;

82 
localparam
 
	gWAY_BITS
 = (
NUMBER_OF_WAYS
 > 1) ? 
	$log2
(
NUMBER_OF_WAYS
) : 1;

83 
localparam
 
SBITS
 = 
COHERENCE_BITS
 + 
STATUS_BITS
;

90 `
include
 "./params.h"

93 
input
 
clock
, 
reset
;

94 
input
 
read
, 
write
, 
invalidate
, 
flush
;

95 
input
 [
DATA_WIDTH
/8-1:0] 
w_byte_en
;

96 
input
 [
ADDRESS_BITS
-1:0] 
address
;

97 
input
 [
DATA_WIDTH
-1 :0] 
data_in
;

98 
input
 
report
;

99 
output
 [
DATA_WIDTH
-1 :0] 
data_out
;

100 
output
 [
ADDRESS_BITS
-1:0] 
out_address
;

101 
output
 
ready
, 
valid
;

103 
input
 [
MSG_BITS
-1 :0] 
bus_msg_in
;

104 
input
 [
ADDRESS_BITS
-1:0] 
bus_address_in
;

105 
input
 [
BUS_WIDTH
-1 :0] 
bus_data_in
;

106 
input
 
bus_master
;

107 
input
 
req_ready
;

108 
input
 [
	$log2
(
MAX_OFFSET_BITS
):0] 
curr_offset
;

109 
output
 [
MSG_BITS
-1 :0] 
bus_msg_out
;

110 
output
 [
ADDRESS_BITS
-1:0] 
bus_address_out
;

111 
output
 [
BUS_WIDTH
-1 :0] 
bus_data_out
;

112 
output
 [
	$log2
(
MAX_OFFSET_BITS
):0] 
active_offset
;

116 
wire
 
i_reset
;

117 
wire
 
snoop_action
;

119 
wire
 [
CACHE_WIDTH
-1 :0] 
ctrl_data_out0
, 
ctrl_data_out1
;

120 
wire
 [
CACHE_WIDTH
-1 :0] 
ctrl_data_in0
;

121 
wire
 [
INDEX_BITS
-1 :0] 
ctrl_index0
, 
ctrl_index1
;

122 
wire
 [
TAG_BITS
-1 :0] 
ctrl_tag_in0
, 
ctrl_tag_out0
, 
ctrl_tag_out1
;

123 
wire
 [
COHERENCE_BITS
-1:0] 
ctrl_coh_bits0
, 
ctrl_coh_bits1
;

124 
wire
 [
SBITS
-1 :0] 
ctrl_metadata0
, 
ctrl_metadata1
;

125 
wire
 [
WAY_BITS
-1 :0] 
ctrl_matched_way0
;

126 
wire
 [
WAY_BITS
-1 :0] 
ctrl_way_select0
, 
ctrl_way_select1
;

127 
wire
 [
STATUS_BITS
-1 :0] 
ctrl_status_bits0
;

128 
wire
 
ctrl_hit0
;

129 
wire
 
ctrl_read0
, 
ctrl_write0
, 
ctrl_invalidate0
;

130 
wire
 
ctrl_read1
, 
ctrl_write1
, 
ctrl_invalidate1
;

132 
wire
 [
CACHE_WIDTH
-1 :0] 
mem_data_in0
, 
mem_data_in1
;

133 
wire
 [
CACHE_WIDTH
-1 :0] 
mem_data_out0
, 
mem_data_out1
;

134 
wire
 [
INDEX_BITS
-1 :0] 
mem_index0
, 
mem_index1
;

135 
wire
 [
TAG_BITS
-1 :0] 
mem_tag_in0
, 
mem_tag_in1
, 
mem_tag_out0
, 
mem_tag_out1
;

136 
wire
 [
WAY_BITS
-1 :0] 
mem_matched_way0
, 
mem_matched_way1
;

137 
wire
 [
WAY_BITS
-1 :0] 
mem_way_select0
, 
mem_way_select1
;

138 
wire
 [
COHERENCE_BITS
-1:0] 
mem_coh_bits0
, 
mem_coh_bits1
;

139 
wire
 [
SBITS
-1 :0] 
mem_metadata0
, 
mem_metadata1
;

140 
wire
 [
STATUS_BITS
-1 :0] 
mem_status_bits0
, 
mem_status_bits1
;

141 
wire
 
mem_hit0
, 
mem_hit1
;

142 
wire
 
mem_read0
, 
mem_read1
, 
mem_write0
, 
mem_write1
;

143 
wire
 
mem_invalidate0
, 
mem_invalidate1
;

145 
wire
 [
CACHE_WIDTH
-1 :0] 
snooper_data_in
, 
snooper_data_out
;

146 
wire
 [
TAG_BITS
-1 :0] 
snooper_tag_out
;

147 
wire
 [
INDEX_BITS
-1 :0] 
snooper_index
;

148 
wire
 [
WAY_BITS
-1 :0] 
snooper_matched_way
;

149 
wire
 [
WAY_BITS
-1 :0] 
snooper_way_select
;

150 
wire
 [
COHERENCE_BITS
-1:0] 
snooper_coh_bits
;

151 
wire
 [
SBITS
-1 :0] 
snooper_metadata
;

152 
wire
 [
STATUS_BITS
-1 :0] 
snooper_status_bits
;

153 
wire
 
snooper_hit
;

154 
wire
 
snooper_read
, 
snooper_write
, 
snooper_invalidate
;

156 
wire
 [
MSG_BITS
-1 :0] 
cache2intf_msg
, 
intf2cache_msg
;

157 
wire
 [
ADDRESS_BITS
-1:0] 
cache2intf_addr
, 
intf2cache_addr
;

158 
wire
 [
CACHE_WIDTH
-1 :0] 
cache2intf_data
, 
intf2cache_data
;

159 
wire
 [
MSG_BITS
-1 :0] 
snooper2intf_msg
, 
intf2snooper_msg
;

160 
wire
 [
ADDRESS_BITS
-1:0] 
snooper2intf_addr
, 
intf2snooper_addr
;

161 
wire
 [
CACHE_WIDTH
-1 :0] 
snooper2intf_data
, 
intf2snooper_data
;

163 
wire
 [
	$log2
(
CACHE_OFFSET_BITS
):0] 
cache_offset_bits_wire
;

166 
assign
 
snoop_action
 = 
snooper_read
 | 
snooper_write
 | 
snooper_invalidate
;

168 
assign
 
mem_read0
 = 
ctrl_read0
;

169 
assign
 
mem_write0
 = 
ctrl_write0
;

170 
assign
 
mem_invalidate0
 = 
ctrl_invalidate0
;

171 
assign
 
mem_index0
 = 
ctrl_index0
;

172 
assign
 
mem_tag_in0
 = 
ctrl_tag_out0
;

173 
assign
 
mem_metadata0
 = 
ctrl_metadata0
;

174 
assign
 
mem_data_in0
 = 
ctrl_data_out0
;

175 
assign
 
mem_way_select0
 = 
ctrl_way_select0
;

176 
assign
 
mem_read1
 = 
snoop_action
 ? 
snooper_read
 : 
ctrl_read1
;

177 
assign
 
mem_write1
 = 
snoop_action
 ? 
snooper_write
 : 
ctrl_write1
;

178 
assign
 
mem_invalidate1
 = 
snoop_action
 ? 
snooper_invalidate
 : 
ctrl_invalidate1
;

179 
assign
 
mem_index1
 = 
snoop_action
 ? 
snooper_index
 : 
ctrl_index1
;

180 
assign
 
mem_tag_in1
 = 
snoop_action
 ? 
snooper_tag_out
 : 
ctrl_tag_out1
;

181 
assign
 
mem_metadata1
 = 
snoop_action
 ? 
snooper_metadata
 : 
ctrl_metadata1
;

182 
assign
 
mem_data_in1
 = 
snoop_action
 ? 
snooper_data_out
 : 
ctrl_data_out1
;

183 
assign
 
mem_way_select1
 = 
snoop_action
 ? 
snooper_way_select
 : 
ctrl_way_select1
;

185 
assign
 
ctrl_data_in0
 = 
mem_data_out0
;

186 
assign
 
ctrl_tag_in0
 = 
mem_tag_out0
;

187 
assign
 
ctrl_matched_way0
 = 
mem_matched_way0
;

188 
assign
 
ctrl_coh_bits0
 = 
mem_coh_bits0
;

189 
assign
 
ctrl_status_bits0
 = 
mem_status_bits0
;

190 
assign
 
ctrl_hit0
 = 
mem_hit0
;

192 
assign
 
snooper_data_in
 = 
mem_data_out1
;

193 
assign
 
snooper_matched_way
 = 
mem_matched_way1
;

194 
assign
 
snooper_coh_bits
 = 
mem_coh_bits1
;

195 
assign
 
snooper_status_bits
 = 
mem_status_bits1
;

196 
assign
 
snooper_hit
 = 
mem_hit1
;

199 
assign
 
cache_offset_bits_wire
 = 
CACHE_OFFSET_BITS
[
	$log2
(
CACHE_OFFSET_BITS
):0];

202 
cache_controller
 #(

203 .
	`STATUS_BITS
(
STATUS_BITS
),

204 .
	`COHERENCE_BITS
(
COHERENCE_BITS
),

205 .
	`OFFSET_BITS
(
CACHE_OFFSET_BITS
),

206 .
	`DATA_WIDTH
(
DATA_WIDTH
),

207 .
	`NUMBER_OF_WAYS
(
NUMBER_OF_WAYS
),

208 .
	`ADDRESS_BITS
(
ADDRESS_BITS
),

209 .
	`INDEX_BITS
(
INDEX_BITS
),

210 .
	`MSG_BITS
(
MSG_BITS
),

211 .
	`CORE
(0),

212 .
	$CACHE_NO
(0)

213 ) 
	`controller
 (

214 .
	`clock
(
clock
),

215 .
	`reset
(
reset
),

216 .
	`read
(
read
),

217 .
	`write
(
write
),

218 .
	`w_byte_en
(
w_byte_en
),

219 .
	`invalidate
(
invalidate
),

220 .
	`flush
(
flush
),

221 .
	`address
(
address
),

222 .
	`data_in
(
data_in
),

223 .
	`report
(
report
),

224 .
	`data_out
(
data_out
),

225 .
	`out_address
(
out_address
),

226 .
	`ready
(
ready
),

227 .
	`valid
(
valid
),

229 .
	`data_in0
(
ctrl_data_in0
),

230 .
	`tag_in0
(
ctrl_tag_in0
),

231 .
	`matched_way0
(
ctrl_matched_way0
),

232 .
	`coh_bits0
(
ctrl_coh_bits0
),

233 .
	`status_bits0
(
ctrl_status_bits0
),

234 .
	`hit0
(
ctrl_hit0
),

235 .
	`read0
(
ctrl_read0
),

236 .
	`write0
(
ctrl_write0
),

237 .
	`invalidate0
(
ctrl_invalidate0
),

238 .
	`index0
(
ctrl_index0
),

239 .
	`tag0
(
ctrl_tag_out0
),

240 .
	`meta_data0
(
ctrl_metadata0
),

241 .
	`data_out0
(
ctrl_data_out0
),

242 .
	`way_select0
(
ctrl_way_select0
),

243 .
	`read1
(
ctrl_read1
),

244 .
	`write1
(
ctrl_write1
),

245 .
	`invalidate1
(
ctrl_invalidate1
),

246 .
	`index1
(
ctrl_index1
),

247 .
	`tag1
(
ctrl_tag_out1
),

248 .
	`meta_data1
(
ctrl_metadata1
),

249 .
	`data_out1
(
ctrl_data_out1
),

250 .
	`way_select1
(
ctrl_way_select1
),

251 .
	`i_reset
(
i_reset
),

253 .
	`mem2cache_msg
(
intf2cache_msg
),

254 .
	`mem2cache_data
(
intf2cache_data
),

255 .
	`mem2cache_address
(
intf2cache_addr
),

256 .
	`cache2mem_msg
(
cache2intf_msg
),

257 .
	`cache2mem_data
(
cache2intf_data
),

258 .
	`cache2mem_address
(
cache2intf_addr
),

260 .
	`snoop_address
({
snooper_tag_out
, 
snooper_index
, {
CACHE_OFFSET_BITS
{1'b0}}}),

261 .
	`snoop_read
(
snooper_read
),

262 .
	`snoop_modify
(
snooper_write
 | 
snooper_invalidate
)

268 
cache_memory
 #(

269 .
	`STATUS_BITS
(
STATUS_BITS
),

270 .
	`COHERENCE_BITS
(
COHERENCE_BITS
),

271 .
	`OFFSET_BITS
(
CACHE_OFFSET_BITS
),

272 .
	`DATA_WIDTH
(
DATA_WIDTH
),

273 .
	`NUMBER_OF_WAYS
(
NUMBER_OF_WAYS
),

274 .
	`REPLACEMENT_MODE
(
REPLACEMENT_MODE
),

275 .
	`ADDRESS_BITS
(
ADDRESS_BITS
),

276 .
	`INDEX_BITS
(
INDEX_BITS
)

277 ) 
	`memory
 (

278 .
	`clock
(
clock
),

279 .
	`reset
(
i_reset
),

281 .
	`read0
(
mem_read0
),

282 .
	`write0
(
mem_write0
),

283 .
	`invalidate0
(
mem_invalidate0
),

284 .
	`index0
(
mem_index0
),

285 .
	`tag0
(
mem_tag_in0
),

286 .
	`meta_data0
(
mem_metadata0
),

287 .
	`data_in0
(
mem_data_in0
),

288 .
	`way_select0
(
mem_way_select0
),

289 .
	`data_out0
(
mem_data_out0
),

290 .
	`tag_out0
(
mem_tag_out0
),

291 .
	`matched_way0
(
mem_matched_way0
),

292 .
	`coh_bits0
(
mem_coh_bits0
),

293 .
	`status_bits0
(
mem_status_bits0
),

294 .
	`hit0
(
mem_hit0
),

296 .
	`read1
(
mem_read1
),

297 .
	`write1
(
mem_write1
),

298 .
	`invalidate1
(
mem_invalidate1
),

299 .
	`index1
(
mem_index1
),

300 .
	`tag1
(
mem_tag_in1
),

301 .
	`meta_data1
(
mem_metadata1
),

302 .
	`data_in1
(
mem_data_in1
),

303 .
	`way_select1
(
mem_way_select1
),

304 .
	`data_out1
(
mem_data_out1
),

305 .
	`tag_out1
(
mem_tag_out1
),

306 .
	`matched_way1
(
mem_matched_way1
),

307 .
	`coh_bits1
(
mem_coh_bits1
),

308 .
	`status_bits1
(
mem_status_bits1
),

309 .
	`hit1
(
mem_hit1
),

311 .
	`report
(
report
)

316 
snooper
 #(

317 .
	`CACHE_OFFSET_BITS
(
CACHE_OFFSET_BITS
),

318 .
	`BUS_OFFSET_BITS
(
BUS_OFFSET_BITS
),

319 .
	`DATA_WIDTH
(
DATA_WIDTH
),

320 .
	`ADDRESS_WIDTH
(
ADDRESS_BITS
),

321 .
	`MSG_BITS
(
MSG_BITS
),

322 .
	`INDEX_BITS
(
INDEX_BITS
),

323 .
	`COHERENCE_BITS
(
COHERENCE_BITS
),

324 .
	`STATUS_BITS
(
STATUS_BITS
),

325 .
	`NUMBER_OF_WAYS
(
NUMBER_OF_WAYS
),

326 .
	`MAX_OFFSET_BITS
(
MAX_OFFSET_BITS
)

327 ) 
	`snooper
 (

328 .
	`clock
(
clock
),

329 .
	`reset
(
i_reset
),

330 .
	`data_in
(
snooper_data_in
),

331 .
	`matched_way
(
snooper_matched_way
),

332 .
	`coh_bits
(
snooper_coh_bits
),

333 .
	`status_bits
(
snooper_status_bits
),

334 .
	`hit
(
snooper_hit
),

335 .
	`read
(
snooper_read
),

336 .
	`write
(
snooper_write
),

337 .
	`invalidate
(
snooper_invalidate
),

338 .
	`index
(
snooper_index
),

339 .
	`tag
(
snooper_tag_out
),

340 .
	`meta_data
(
snooper_metadata
),

341 .
	`data_out
(
snooper_data_out
),

342 .
	`way_select
(
snooper_way_select
),

344 .
	`intf_msg
(
intf2snooper_msg
),

345 .
	`intf_address
(
intf2snooper_addr
),

346 .
	`intf_data
(
intf2snooper_data
),

347 .
	`snoop_msg
(
snooper2intf_msg
),

348 .
	`snoop_address
(
snooper2intf_addr
),

349 .
	`snoop_data
(
snooper2intf_data
),

351 .
	`bus_msg
(
bus_msg_in
),

352 .
	`bus_address
(
bus_address_in
),

353 .
	`req_ready
(
req_ready
),

354 .
	`bus_master
(
bus_master
),

355 .
	`curr_offset
(
curr_offset
)

360 
L1_bus_interface
 #(

361 .
	`CACHE_OFFSET_BITS
(
CACHE_OFFSET_BITS
),

362 .
	`BUS_OFFSET_BITS
(
BUS_OFFSET_BITS
),

363 .
	`DATA_WIDTH
(
DATA_WIDTH
),

364 .
	`ADDRESS_WIDTH
(
ADDRESS_BITS
),

365 .
	`MSG_BITS
(
MSG_BITS
),

366 .
	`MAX_OFFSET_BITS
(
MAX_OFFSET_BITS
)

367 ) 
	`bus_interface
 (

368 .
	`clock
(
clock
),

369 .
	`reset
(
i_reset
),

371 .
	`cache_offset
(
cache_offset_bits_wire
),

373 .
	`cache_msg_in
(
cache2intf_msg
),

374 .
	`cache_address_in
(
cache2intf_addr
),

375 .
	`cache_data_in
(
cache2intf_data
),

376 .
	`cache_msg_out
(
intf2cache_msg
),

377 .
	`cache_address_out
(
intf2cache_addr
),

378 .
	`cache_data_out
(
intf2cache_data
),

380 .
	`snoop_msg_in
(
snooper2intf_msg
),

381 .
	`snoop_address_in
(
snooper2intf_addr
),

382 .
	`snoop_data_in
(
snooper2intf_data
),

383 .
	`snoop_msg_out
(
intf2snooper_msg
),

384 .
	`snoop_address_out
(
intf2snooper_addr
),

385 .
	`snoop_data_out
(
intf2snooper_data
),

387 .
	`bus_msg_in
(
bus_msg_in
),

388 .
	`bus_address_in
(
bus_address_in
),

389 .
	`bus_data_in
(
bus_data_in
),

390 .
	`bus_msg_out
(
bus_msg_out
),

391 .
	`bus_address_out
(
bus_address_out
),

392 .
	`bus_data_out
(
bus_data_out
),

393 .
	`active_offset
(
active_offset
),

395 .
	`bus_master
(
bus_master
),

396 .
	`req_ready
(
req_ready
)

399 
endmodule


	@Lx_bus_interface.v

23 
module
 
	gLx_bus_interface
 #(

24 
parameter
 
	gCACHE_OFFSET_BITS
 = 2,

25 
	gBUS_OFFSET_BITS
 = 1,

26 
	gDATA_WIDTH
 = 32,

27 
	gADDRESS_WIDTH
 = 32,

28 
	gMSG_BITS
 = 4,

29 
	gMAX_OFFSET_BITS
 = 3

31 
clock
,

32 
	greset
,

34 
	gbus_msg_in
,

35 
	gbus_address_in
,

36 
	gbus_data_in
,

37 
	gbus_msg_out
,

38 
	gbus_address_out
,

39 
	gbus_data_out
,

40 
	greq_offset
,

41 
	greq_ready
,

42 
	gactive_offset
,

44 
	gcache_msg_in
,

45 
	gcache_address_in
,

46 
	gcache_data_in
,

47 
	gcache_msg_out
,

48 
	gcache_address_out
,

49 
	gcache_data_out


53 
function
 
integer
 
	glog2
;

54 
input
 
integer
 
	gvalue
;

55 
begin


56 
	gvalue
 = 
value
-1;

57 for (
	glog2
=0; 
	gvalue
>0; log2=
log2
+1)

58 
value
 = value >> 1;

59 
end


60 
endfunction


62 
localparam
 
	gCACHE_WORDS
 = 1 << 
CACHE_OFFSET_BITS
;

63 
localparam
 
	gBUS_WORDS
 = 1 << 
BUS_OFFSET_BITS
;

64 
localparam
 
	gMAX_WORDS
 = 1 << 
MAX_OFFSET_BITS
;

65 
localparam
 
	gCACHE_WIDTH
 = 
DATA_WIDTH
*
CACHE_WORDS
;

66 
localparam
 
	gBUS_WIDTH
 = 
DATA_WIDTH
*
BUS_WORDS
;

67 
localparam
 
	gCACHE2BUS_OFFSETDIFF
 = (
CACHE_OFFSET_BITS
 >= 
BUS_OFFSET_BITS
 ) ?

68 (
CACHE_OFFSET_BITS
 - 
BUS_OFFSET_BITS
 ) :

69 (
BUS_OFFSET_BITS
 - 
CACHE_OFFSET_BITS
) ;

70 
localparam
 
	gCACHE2BUS_RATIO
 = 1 << 
CACHE2BUS_OFFSETDIFF
;

72 
localparam
 
	gIDLE
 = 4'd0 ,

73 
RECEIVE
 = 4'd1 ,

74 
SEND_ADDR
 = 4'd2 ,

75 
SEND_TO_CACHE
 = 4'd3 ,

76 
READ_DATA
 = 4'd4 ,

77 
READ_FILLER
 = 4'd5 ,

78 
TRANSFER
 = 4'd6 ,

79 
WAIT_FOR_RESP
 = 4'd7 ,

80 
WAIT_BUS_CLEAR
 = 4'd8 ,

81 
WAIT_FLUSH_RESP
 = 4'd9 ,

82 
GET_BUS
 = 4'd10;

89 `
include
 "./params.h"

91 
input
 
clock
, 
	greset
;

93 
	ginput
 [
MSG_BITS
-1: 0] 
bus_msg_in
;

94 
	ginput
 [
ADDRESS_WIDTH
-1: 0] 
bus_address_in
;

95 
	ginput
 [
BUS_WIDTH
-1: 0] 
bus_data_in
;

96 
input
 
	greq_ready
;

97 
	ginput
 [
	$log2
(
MAX_OFFSET_BITS
):0] 
req_offset
;

98 
output
 [
MSG_BITS
-1: 0] 
bus_msg_out
;

99 
output
 [
ADDRESS_WIDTH
-1: 0] 
bus_address_out
;

100 
output
 [
BUS_WIDTH
-1: 0] 
bus_data_out
;

101 
output
 [
	$log2
(
MAX_OFFSET_BITS
):0] 
active_offset
;

103 
input
 [
MSG_BITS
-1: 0] 
cache_msg_in
 ;

104 
input
 [
ADDRESS_WIDTH
-1: 0] 
cache_address_in
 ;

105 
input
 [
CACHE_WIDTH
-1: 0] 
cache_data_in
 ;

106 
output
 [
MSG_BITS
-1: 0] 
cache_msg_out
 ;

107 
output
 [
ADDRESS_WIDTH
-1: 0] 
cache_address_out
;

108 
output
 [
CACHE_WIDTH
-1: 0] 
cache_data_out
 ;

111 
genvar
 
i
;

112 
integer
 
j
;

113 
reg
 [3:0] 
state
;

114 
reg
 [
DATA_WIDTH
-1:0] 
r_cache_data_out
 [
CACHE_WORDS
-1:0];

115 
reg
 [
DATA_WIDTH
-1:0] 
r_bus_data_out
 [
BUS_WORDS
-1: 0];

117 
reg
 [
MSG_BITS
-1: 0] 
r_cache_msg_out
, 
r_bus_msg_out
;

118 
reg
 [
ADDRESS_WIDTH
-1:0] 
r_cache_address_out
, 
r_bus_address_out
;

119 
reg
 [
MAX_OFFSET_BITS
:0] 
block_counter
, 
word_counter
;

121 
reg
 [
MSG_BITS
-1:0] 
curr_msg
;

122 
reg
 [
ADDRESS_WIDTH
-1:0] 
curr_address
;

123 
reg
 [
CACHE_OFFSET_BITS
-1:0] 
curr_offset
;

124 
reg
 [
DATA_WIDTH
-1:0] 
curr_data
 [
MAX_WORDS
-1:0];

125 
reg
 [
MAX_OFFSET_BITS
-1:0] 
r_req_offset
;

127 
reg
 
shared_line
;

129 
reg
 
flush_active
;

130 
reg
 [
ADDRESS_WIDTH
-1:0] 
flush_address
;

132 
wire
 [
DATA_WIDTH
-1:0] 
w_cache_data_in
 [
CACHE_WORDS
-1: 0];

133 
wire
 [
DATA_WIDTH
-1:0] 
w_bus_data_in
 [
BUS_WORDS
-1: 0];

135 
wire
 [
MAX_OFFSET_BITS
-1:0] 
cache2req_offsetdiff
;

136 
wire
 [
MAX_OFFSET_BITS
 :0] 
cache2req_ratio
;

137 
wire
 [
MAX_OFFSET_BITS
-1:0] 
req2bus_offsetdiff
;

138 
wire
 [
MAX_OFFSET_BITS
 :0] 
req2bus_ratio
;

139 
wire
 [
MAX_OFFSET_BITS
 :0] 
req_words
;

140 
wire
 
cache_wt_bus
, 
cache_wt_req
, 
bus_wt_cache
, 
bus_wt_req
,

141 
req_wt_cache
, 
req_wt_bus
, 
bus_wt_flush
;

142 
wire
 
cache_req
, 
coh_req
;

143 
wire
 
read_req
, 
receive_req
;

147 
assign
 
cache2req_offsetdiff
 = (
CACHE_OFFSET_BITS
 > 
r_req_offset
) ?

148 (
CACHE_OFFSET_BITS
 - 
r_req_offset
) :

149 (
r_req_offset
 - 
CACHE_OFFSET_BITS
) ;

150 
assign
 
cache2req_ratio
 = 1 << 
cache2req_offsetdiff
;

152 
assign
 
req2bus_offsetdiff
 = (
r_req_offset
 > 
BUS_OFFSET_BITS
) ?

153 (
r_req_offset
 - 
BUS_OFFSET_BITS
) :

154 (
BUS_OFFSET_BITS
 - 
r_req_offset
) ;

155 
assign
 
req2bus_ratio
 = 1 << 
req2bus_offsetdiff
;

158 
assign
 
cache_wt_bus
 = 
CACHE_OFFSET_BITS
 > 
BUS_OFFSET_BITS
;

159 
assign
 
cache_wt_req
 = 
CACHE_OFFSET_BITS
 > 
r_req_offset
;

160 
assign
 
bus_wt_cache
 = 
BUS_OFFSET_BITS
 > 
CACHE_OFFSET_BITS
;

161 
assign
 
bus_wt_req
 = 
BUS_OFFSET_BITS
 > 
r_req_offset
;

162 
assign
 
req_wt_cache
 = 
r_req_offset
 > 
CACHE_OFFSET_BITS
;

163 
assign
 
req_wt_bus
 = 
r_req_offset
 > 
BUS_OFFSET_BITS
;

165 
assign
 
req_words
 = 1 << 
r_req_offset
;

167 
generate


168 for(
i
=0; i<
CACHE_WORDS
; i=i+1)
begin
 : 
SPLIT_CACHELINE


169 
assign
 
w_cache_data_in
[
i
] = 
cache_data_in
[i*
DATA_WIDTH
 +: DATA_WIDTH];

170 
end


171 for(
i
=0; i<
BUS_WORDS
; i=i+1)
begin
: 
SPLIT_BUS


172 
assign
 
w_bus_data_in
[
i
] = 
bus_data_in
[i*
DATA_WIDTH
 +: DATA_WIDTH];

173 
end


174 
endgenerate


176 
assign
 
cache_req
 = (
bus_msg_in
 == 
R_REQ
) | (bus_msg_in == 
WB_REQ
 ) |

177 (
bus_msg_in
 == 
FLUSH
) | (bus_msg_in == 
FLUSH_S
) |

178 (
bus_msg_in
 == 
RFO_BCAST
);

180 
assign
 
coh_req
 = (
bus_msg_in
 == 
C_WB
) | (bus_msg_in == 
C_FLUSH
);

182 
assign
 
read_req
 = (
bus_msg_in
 == 
R_REQ
) | (bus_msg_in == 
RFO_BCAST
);

183 
assign
 
receive_req
 = (
bus_msg_in
 == 
WB_REQ
) | (bus_msg_in == 
FLUSH
) | 
coh_req
;

187 
always
 @(
posedge
 
clock
)
begin


188 if(
reset
)
begin


189 
r_cache_msg_out
 <= 
NO_REQ
;

190 
r_bus_msg_out
 <= 
NO_REQ
;

191 
r_cache_address_out
 <= {
ADDRESS_WIDTH
{1'b0}};

192 
r_bus_address_out
 <= {
ADDRESS_WIDTH
{1'b0}};

193 
block_counter
 <= {
MAX_OFFSET_BITS
{1'b0}};

194 
word_counter
 <= {
MAX_OFFSET_BITS
{1'b0}};

195 
curr_msg
 <= 
NO_REQ
;

196 
curr_address
 <= {
ADDRESS_WIDTH
{1'b0}};

197 
curr_offset
 <= {
CACHE_OFFSET_BITS
{1'b0}};

198 
r_req_offset
 <= {
MAX_OFFSET_BITS
{1'b0}};

199 
shared_line
 <= 1'b0;

200 
flush_active
 <= 1'b0;

201 
flush_address
 <= {
ADDRESS_WIDTH
{1'b0}};

202 for(
j
=0; j<
MAX_WORDS
; j=j+1)
begin


203 
curr_data
[
j
] <= {
DATA_WIDTH
{1'b0}};

204 
end


205 for(
j
=0; j<
BUS_WORDS
; j=j+1)
begin


206 
r_bus_data_out
[
j
] <= {
DATA_WIDTH
{1'b0}};

207 
end


208 for(
j
=0; j<
CACHE_WORDS
; j=j+1)
begin


209 
r_cache_data_out
[
j
] <= {
DATA_WIDTH
{1'b0}};

210 
end


211 
state
 <= 
IDLE
;

212 
end


213 else 
begin


214 case(
state
)

215 
IDLE
:
begin


216 if((
cache_req
 & 
req_ready
) | 
coh_req
)
begin


217 
curr_msg
 <= 
bus_msg_in
;

218 
curr_address
 <= 
bus_address_in
;

219 
curr_offset
 <= 
bus_address_in
[0 +: 
CACHE_OFFSET_BITS
];

220 
r_req_offset
 <= 
req_offset
;

221 if(
receive_req
)
begin


222 
block_counter
 <= 1;

223 
word_counter
 <= 0;

224 
state
 <= 
RECEIVE
;

225 
end


226 else 
begin


227 
block_counter
 <= 1;

228 
word_counter
 <= 0;

229 
shared_line
 <= 1'b0;

230 
state
 <= 
SEND_ADDR
;

231 
end


232 
end


233 else if(
req_ready
 & (
bus_msg_in
 == 
NO_REQ
) & 
flush_active
)
begin


234 
r_bus_msg_out
 <= 
HOLD_BUS
;

235 
r_bus_address_out
 <= {
ADDRESS_WIDTH
{1'b0}};

236 
r_cache_msg_out
 <= 
FLUSH_S
;

237 
r_cache_address_out
 <= 
flush_address
;

238 
flush_active
 <= 1'b0;

239 
state
 <= 
WAIT_FLUSH_RESP
;

240 
end


242 
state
 <= 
IDLE
;

243 
end


244 
RECEIVE
:
begin


245 for(
j
=0; j<
BUS_WORDS
; j=j+1)
begin


246 
curr_data
[
word_counter
 + 
j
] <= 
w_bus_data_in
[j];

247 
end


248 if(
req_wt_bus
)
begin


249 if(
block_counter
 == 
req2bus_ratio
)
begin


250 
block_counter
 <= 1;

251 
word_counter
 <= 0;

252 
state
 <= 
SEND_TO_CACHE
;

253 
end


254 else 
begin


255 
block_counter
 <= block_counter + 1;

256 
word_counter
 <= word_counter + 
BUS_WORDS
;

257 
state
 <= 
RECEIVE
;

258 
end


259 
end


260 else 
begin


261 if(
cache2req_ratio
 == 1)
begin


262 
r_cache_msg_out
 <= 
curr_msg
;

263 
r_cache_address_out
 <= 
curr_address
;

264 
block_counter
 <= 1;

265 
word_counter
 <= 0;

266 for(
j
=0; j<
CACHE_WORDS
; j=j+1)
begin


267 
r_cache_data_out
[
j
] <= (j<
BUS_WORDS
) ? 
w_bus_data_in
[j] :

268 {
DATA_WIDTH
{1'b0}};

269 
end


270 
state
 <= 
WAIT_FOR_RESP
;

271 
end


272 else 
begin


273 
r_cache_msg_out
 <= 
R_REQ
;

274 
r_cache_address_out
 <= (
curr_address
 >> 
CACHE_OFFSET_BITS
) <<

275 
CACHE_OFFSET_BITS
;

276 
state
 <= 
READ_FILLER
;

277 
end


278 
end


279 
end


280 
READ_FILLER
:
begin


281 if((
cache_msg_in
 == 
MEM_RESP
) | (cache_msg_in == 
MEM_RESP_S
))
begin


282 for(
j
=0; j<
CACHE_WORDS
; j=j+1)
begin


283 
r_cache_data_out
[
j
] <= 
w_cache_data_in
[j];

284 
end


285 
r_cache_msg_out
 <= 
NO_REQ
;

286 
r_cache_address_out
 <= {
ADDRESS_WIDTH
{1'b0}};

287 
block_counter
 <= 1;

288 
word_counter
 <= 0;

289 
state
 <= 
SEND_TO_CACHE
;

290 
end


291 else if(
cache_msg_in
 == 
REQ_FLUSH
)
begin


292 
r_bus_msg_out
 <= 
REQ_FLUSH
;

293 
r_bus_address_out
 <= 
cache_address_in
;

294 
flush_active
 <= 1'b1;

295 
flush_address
 <= 
cache_address_in
;

296 
r_cache_msg_out
 <= 
NO_REQ
;

297 
state
 <= 
GET_BUS
;

298 
end


300 
state
 <= 
READ_FILLER
;

301 
end


302 
SEND_TO_CACHE
:
begin


303 if(
req_wt_cache
)
begin


304 
r_cache_msg_out
 <= 
curr_msg
;

305 
r_cache_address_out
 <= 
curr_address
 + 
word_counter
;

306 for(
j
=0; j<
CACHE_WORDS
; j=j+1)
begin


307 
r_cache_data_out
[
j
] <= 
curr_data
[
word_counter
 + j];

308 
end


309 
end


310 else 
begin


311 
r_cache_msg_out
 <= 
curr_msg
;

312 
r_cache_address_out
 <= (
curr_address
 >> 
CACHE_OFFSET_BITS
) <<

313 
CACHE_OFFSET_BITS
;

314 for(
j
=0; j<
CACHE_WORDS
; j=j+1)
begin


315 
r_cache_data_out
[
j
] <= (j>=
curr_offset
 & j<(curr_offset+
req_words
))

316 ? 
curr_data
[
j
-
curr_offset
] :

317 
r_cache_data_out
[
j
];

318 
end


319 
end


320 
state
 <= 
WAIT_FOR_RESP
;

321 
end


322 
WAIT_FOR_RESP
:
begin


323 if((
cache_msg_in
 == 
MEM_RESP
) | (cache_msg_in == 
MEM_C_RESP
))
begin


324 if((
block_counter
 == 
cache2req_ratio
) | 
cache_wt_req
)
begin


325 
r_bus_msg_out
 <= 
cache_msg_in
;

326 
r_bus_address_out
 <= 
curr_address
;

327 for(
j
=0; j<
BUS_WORDS
; j=j+1)
begin


328 
r_bus_data_out
[
j
] <= {
DATA_WIDTH
{1'b0}};

329 
end


330 
state
 <= 
WAIT_BUS_CLEAR
;

331 
end


332 else 
begin


333 
block_counter
 <= block_counter + 1;

334 
word_counter
 <= word_counter + 
CACHE_WORDS
;

335 
r_cache_msg_out
 <= 
NO_REQ
;

336 
state
 <= 
SEND_TO_CACHE
;

337 
end


338 
r_cache_msg_out
 <= 
NO_REQ
;

339 
r_cache_address_out
 <= {
ADDRESS_WIDTH
{1'b0}};

340 
end


342 
state
 <= 
WAIT_FOR_RESP
;

343 
end


344 
SEND_ADDR
:
begin


345 
r_cache_msg_out
 <= 
curr_msg
;

346 
r_cache_address_out
 <= ((
curr_address
 >> 
CACHE_OFFSET_BITS
) <<

347 
CACHE_OFFSET_BITS
) + 
word_counter
;

348 
state
 <= 
READ_DATA
;

349 
end


350 
READ_DATA
:
begin


351 if((
cache_msg_in
 == 
MEM_RESP
) | (cache_msg_in == 
MEM_RESP_S
))
begin


352 
r_cache_msg_out
 <= 
NO_REQ
;

353 for(
j
=0; j<
CACHE_WORDS
; j=j+1)
begin


354 
curr_data
[
word_counter
 + 
j
] <= 
w_cache_data_in
[j];

355 
end


356 if((
block_counter
 == 
cache2req_ratio
) | 
cache_wt_req
)
begin


357 
block_counter
 <= 0;

358 
word_counter
 <= 
curr_offset
;

359 
r_bus_msg_out
 <= (
shared_line
 | (
cache_msg_in
 == 
MEM_RESP_S
)) ?

360 
MEM_RESP_S
 : 
MEM_RESP
;

361 
r_bus_address_out
 <= 
curr_address
;

362 
state
 <= (
curr_msg
 == 
FLUSH_S
) ? 
WAIT_BUS_CLEAR
 :

363 
TRANSFER
;

364 
end


365 else 
begin


366 
block_counter
 <= block_counter + 1;

367 
word_counter
 <= word_counter + 
CACHE_WORDS
;

368 
shared_line
 <= shared_line | (
cache_msg_in
 == 
MEM_RESP_S
);

369 
state
 <= 
SEND_ADDR
;

370 
end


371 
end


372 else if(
cache_msg_in
 == 
REQ_FLUSH
)
begin


373 
r_bus_msg_out
 <= 
REQ_FLUSH
;

374 
r_bus_address_out
 <= 
cache_address_in
;

375 
flush_active
 <= 1'b1;

376 
flush_address
 <= 
cache_address_in
;

377 
r_cache_msg_out
 <= 
NO_REQ
;

378 
state
 <= 
GET_BUS
;

379 
end


381 
state
 <= 
READ_DATA
;

382 
end


383 
TRANSFER
:
begin


384 if((
block_counter
 == 
req2bus_ratio
) | (
bus_wt_req
 & (block_counter==1)))

385 
begin


386 
state
 <= 
WAIT_BUS_CLEAR
;

387 for(
j
=0; j<
BUS_WORDS
; j=j+1)
begin


388 
r_bus_data_out
[
j
] <= {
DATA_WIDTH
{1'b0}};

389 
end


390 
r_bus_msg_out
 <= 
NO_REQ
;

391 
r_bus_address_out
 <= {
ADDRESS_WIDTH
{1'b0}};

392 
end


393 else 
begin


394 for(
j
=0; j<
BUS_WORDS
; j=j+1)
begin


395 
r_bus_data_out
[
j
] <= 
curr_data
[
word_counter
 + j];

396 
end


397 
block_counter
 <= block_counter + 1;

398 
word_counter
 <= word_counter + 
BUS_WORDS
;

399 
state
 <= 
TRANSFER
;

400 
end


401 
end


402 
WAIT_BUS_CLEAR
:
begin


403 if(
bus_msg_in
 == 
NO_REQ
)
begin


404 if(
flush_active
)
begin


405 
r_bus_msg_out
 <= 
REQ_FLUSH
;

406 
r_bus_address_out
 <= 
flush_address
;

407 
state
 <= 
IDLE
;

408 
end


409 else 
begin


410 
r_bus_msg_out
 <= 
NO_REQ
;

411 
r_bus_address_out
 <= {
ADDRESS_WIDTH
{1'b0}};

412 for(
j
=0; j<
BUS_WORDS
; j=j+1)
begin


413 
r_bus_data_out
[
j
] <= {
DATA_WIDTH
{1'b0}};

414 
end


415 
state
 <= 
IDLE
;

416 
end


417 
end


419 
state
 <= 
WAIT_BUS_CLEAR
;

420 
end


421 
WAIT_FLUSH_RESP
:
begin


422 if(
cache_msg_in
 == 
MEM_RESP
)
begin


423 
r_cache_msg_out
 <= 
NO_REQ
;

424 
r_cache_address_out
 <= {
ADDRESS_WIDTH
{1'b0}};

425 
r_bus_msg_out
 <= 
NO_REQ
;

426 
r_bus_address_out
 <= {
ADDRESS_WIDTH
{1'b0}};

427 
state
 <= 
IDLE
;

428 
end


430 
state
 <= 
WAIT_FLUSH_RESP
;

431 
end


432 
GET_BUS
:
begin


433 
state
 <= 
IDLE
;

434 
end


435 default:
begin


436 
state
 <= 
IDLE
;

437 
end


438 
endcase


439 
end


440 
end


443 
assign
 
bus_msg_out
 = 
r_bus_msg_out
;

444 
assign
 
bus_address_out
 = 
r_bus_address_out
;

445 
assign
 
cache_msg_out
 = 
r_cache_msg_out
;

446 
assign
 
cache_address_out
 = 
r_cache_address_out
;

447 
assign
 
active_offset
 = 
CACHE_OFFSET_BITS
;

449 
generate


450 for(
i
=0; i<
BUS_WORDS
; i=i+1)
begin
: 
BUS_DATA


451 
assign
 
bus_data_out
[
i
*
DATA_WIDTH
 +: DATA_WIDTH] = 
r_bus_data_out
[i];

452 
end


453 for(
i
=0; i<
CACHE_WORDS
; i=i+1)
begin
: 
CACHE_DATA


454 
assign
 
cache_data_out
[
i
*
DATA_WIDTH
 +: DATA_WIDTH] = 
r_cache_data_out
[i];

455 
end


456 
endgenerate


458 
endmodule


	@Lxcache_controller.v

23 
module
 
	gLxcache_controller
 #(

24 
parameter
 
	gSTATUS_BITS
 = 3,

25 
	gCOHERENCE_BITS
 = 2,

26 
	gOFFSET_BITS
 = 2,

27 
	gDATA_WIDTH
 = 32,

28 
	gNUMBER_OF_WAYS
 = 4,

29 
	gADDRESS_BITS
 = 32,

30 
	gINDEX_BITS
 = 10,

31 
	gMSG_BITS
 = 4

33 
clock
,

34 
	greset
,

35 
	gaddress
,

36 
	gdata_in
,

37 
	gmsg_in
,

38 
	greport
,

39 
	gdata_out
,

40 
	gout_address
,

41 
	gmsg_out
,

43 
	gmem2cache_msg
,

44 
	gmem2cache_address
,

45 
	gmem2cache_data
,

46 
	gcache2mem_msg
,

47 
	gcache2mem_address
,

48 
	gcache2mem_data
,

50 
	gread0
, 
	gwrite0
, 
	ginvalidate0
,

51 
	gindex0
,

52 
	gtag0
,

53 
	gmeta_data0
,

54 
	gdata0
,

55 
	gway_select0
,

56 
	gi_reset
,

57 
	gdata_in0
,

58 
	gtag_in0
,

59 
	gmatched_way0
,

60 
	gcoh_bits0
,

61 
	gstatus_bits0
,

62 
	ghit0


66 
function
 
integer
 
	glog2
;

67 
input
 
integer
 
	gvalue
;

68 
begin


69 
	gvalue
 = 
value
-1;

70 for(
	glog2
=0; 
	gvalue
>0; log2=
log2
+1)

71 
value
 = value >> 1;

72 
end


73 
endfunction


75 
localparam
 
	gCACHE_WORDS
 = 1 << 
OFFSET_BITS
;

76 
localparam
 
	gCACHE_WIDTH
 = 
DATA_WIDTH
*
CACHE_WORDS
;

77 
localparam
 
	gMBITS
 = 
COHERENCE_BITS
 + 
STATUS_BITS
;

78 
localparam
 
	gTAG_BITS
 = 
ADDRESS_BITS
 - 
OFFSET_BITS
 - 
INDEX_BITS
;

79 
localparam
 
	gWAY_BITS
 = (
NUMBER_OF_WAYS
 > 1) ? 
	$log2
(
NUMBER_OF_WAYS
) : 1;

80 
localparam
 
CACHE_DEPTH
 = 1 << 
INDEX_BITS
;

82 
localparam
 
IDLE
 = 4'd0,

83 
READING
 = 4'd1,

84 
SERVING
 = 4'd2,

85 
RESPOND
 = 4'd3,

86 
WRITE_BACK
 = 4'd4,

87 
READ_STATE
 = 4'd5,

88 
READ_WAIT
 = 4'd6,

89 
FLUSH_WAIT
 = 4'd7,

90 
RESET
 = 4'd8;

97 `
include
 "./params.h"

100 
input
 
clock
;

101 
input
 
reset
;

103 
input
 [
ADDRESS_BITS
-1:0] 
address
;

104 
input
 [
CACHE_WIDTH
-1 :0] 
data_in
;

105 
input
 [
MSG_BITS
-1 :0] 
msg_in
;

106 
input
 
report
;

107 
output
 [
CACHE_WIDTH
-1 :0] 
data_out
;

108 
output
 [
ADDRESS_BITS
-1:0] 
out_address
;

109 
output
 [
MSG_BITS
-1 :0] 
msg_out
;

111 
input
 [
MSG_BITS
-1 :0] 
mem2cache_msg
;

112 
input
 [
ADDRESS_BITS
-1:0] 
mem2cache_address
;

113 
input
 [
CACHE_WIDTH
-1 :0] 
mem2cache_data
;

114 
output
 [
MSG_BITS
-1 :0] 
cache2mem_msg
;

115 
output
 [
ADDRESS_BITS
-1:0] 
cache2mem_address
;

116 
output
 [
CACHE_WIDTH
-1 :0] 
cache2mem_data
;

118 
output
 
read0
, 
write0
, 
invalidate0
;

119 
output
 [
INDEX_BITS
-1 :0] 
index0
;

120 
output
 [
TAG_BITS
-1 :0] 
tag0
;

121 
output
 [
MBITS
-1 :0] 
meta_data0
;

122 
output
 [
CACHE_WIDTH
-1 :0] 
data0
;

123 
output
 [
WAY_BITS
-1 :0] 
way_select0
;

124 
output
 
i_reset
;

125 
input
 [
CACHE_WIDTH
-1 :0] 
data_in0
;

126 
input
 [
TAG_BITS
-1 :0] 
tag_in0
;

127 
input
 [
WAY_BITS
-1 :0] 
matched_way0
;

128 
input
 [
COHERENCE_BITS
-1:0] 
coh_bits0
;

129 
input
 [
STATUS_BITS
-1 :0] 
status_bits0
;

130 
input
 
hit0
;

132 
genvar
 
i
;

133 
integer
 
j
;

135 
reg
 [3:0] 
state
;

136 
reg
 [
INDEX_BITS
-1:0] 
reset_counter
;

137 
reg
 
read
, 
write
, 
invalidate
;

138 
reg
 [
MSG_BITS
-1:0] 
r_msg
;

139 
reg
 [
ADDRESS_BITS
-1:0] 
r_address
;

140 
reg
 [
DATA_WIDTH
-1:0] 
r_data
 [
CACHE_WORDS
-1:0];

141 
reg
 [
DATA_WIDTH
-1:0] 
r_data_out
 [
CACHE_WORDS
-1:0];

142 
reg
 
r_hit
, 
r_dirty
, 
r_include
;

143 
reg
 [
COHERENCE_BITS
-1:0] 
r_coh_bits
;

144 
reg
 [
TAG_BITS
-1:0] 
r_tag
, 
r_tag_out
;

145 
reg
 [
WAY_BITS
-1:0] 
r_matched_way
, 
r_way_select
;

146 
reg
 [
MSG_BITS
-1:0] 
r_msg_out
;

147 
reg
 [
MBITS
-1 :0] 
r_meta_data
;

148 
reg
 [
MSG_BITS
-1 :0] 
r_cache2mem_msg
;

149 
reg
 [
ADDRESS_BITS
-1:0] 
r_cache2mem_address
;

150 
reg
 
flush_active
;

153 
wire
 
request
;

154 
wire
 
coh_request
;

155 
wire
 
read_req
, 
write_req
;

156 
wire
 [
DATA_WIDTH
-1:0] 
w_data_in
 [
CACHE_WORDS
-1:0];

157 
wire
 [
DATA_WIDTH
-1:0] 
w_read_data
 [
CACHE_WORDS
-1:0];

158 
wire
 [
DATA_WIDTH
-1:0] 
w_mem_data
 [
CACHE_WORDS
-1:0];

162 
assign
 
i_reset
 = 
reset
 | (
state
 == 
RESET
);

164 
assign
 
coh_request
 = (
msg_in
 == 
C_WB
) | (msg_in == 
C_FLUSH
);

166 
assign
 
request
 = (
msg_in
 == 
WB_REQ
 ) | (msg_in == 
R_REQ
) |

167 (
msg_in
 == 
RFO_BCAST
) | (msg_in == 
FLUSH
) |

168 (
msg_in
 == 
FLUSH_S
 ) | 
coh_request
 ;

170 
assign
 
read_req
 = (
r_msg
 == 
R_REQ
) | (r_msg == 
RFO_BCAST
) | (r_msg == 
FLUSH_S
);

172 
assign
 
write_req
 = (
r_msg
 == 
C_WB
) | (r_msg == 
C_FLUSH
) | (r_msg == 
WB_REQ
) |

173 (
r_msg
 == 
FLUSH
);

175 
generate


176 for(
i
=0; i<
CACHE_WORDS
; i=i+1)
begin
:
SEPARATE_INPUTS


177 
assign
 
w_data_in
[
i
] = 
data_in
[i*
DATA_WIDTH
 +: DATA_WIDTH];

178 
assign
 
w_read_data
[
i
] = 
data_in0
[i*
DATA_WIDTH
 +: DATA_WIDTH];

179 
assign
 
w_mem_data
[
i
] = 
mem2cache_data
[i*
DATA_WIDTH
 +: DATA_WIDTH];

180 
end


181 
endgenerate


185 
always
 @(
posedge
 
clock
)
begin


186 if(
reset
 & (
state
 != 
RESET
))
begin


187 
reset_counter
 <= {
INDEX_BITS
{1'b0}};

188 
read
 <= 1'b0;

189 
write
 <= 1'b0;

190 
invalidate
 <= 1'b1;

191 
flush_active
 <= 1'b0;

192 
r_cache2mem_msg
 <= 
NO_REQ
;

193 
r_cache2mem_address
 <= {
ADDRESS_BITS
{1'b0}};

194 
r_msg
 <= 
NO_REQ
;

195 
r_address
 <= {
ADDRESS_BITS
{1'b0}};

196 
r_hit
 <= 1'b0;

197 
r_dirty
 <= 1'b0;

198 
r_include
 <= 1'b0;

199 
r_coh_bits
 <= {
COHERENCE_BITS
{1'b0}};

200 
r_tag
 <= {
TAG_BITS
{1'b0}};

201 
r_tag_out
 <= {
TAG_BITS
{1'b0}};

202 
r_matched_way
 <= {
WAY_BITS
{1'b0}};

203 
r_way_select
 <= {
WAY_BITS
{1'b0}};

204 
r_msg_out
 <= 
NO_REQ
;

205 
r_meta_data
 <= {
MBITS
{1'b0}};

206 for(
j
=0; j<
CACHE_WORDS
; j=j+1)
begin


207 
r_data
[
j
] <= {
DATA_WIDTH
{1'b0}};

208 
r_data_out
[
j
] <= {
DATA_WIDTH
{1'b0}};

209 
end


210 
state
 <= 
RESET
;

211 
end


212 else 
begin


213 case(
state
)

214 
RESET
:
begin


215 if(
reset_counter
 < 
CACHE_DEPTH
-1)
begin


216 
reset_counter
 <= reset_counter + 1;

217 
end


218 else if((
reset_counter
 == 
CACHE_DEPTH
-1) & ~
reset
)
begin


219 
reset_counter
 <= {
INDEX_BITS
{1'b0}};

220 
invalidate
 <= 1'b0;

221 
state
 <= 
IDLE
;

222 
end


224 
state
 <= 
RESET
;

225 
end


226 
IDLE
:
begin


227 if(
request
)
begin


228 
r_msg
 <= 
msg_in
;

229 
r_address
 <= 
address
;

230 for(
j
=0; j<
CACHE_WORDS
; j=j+1)
begin


231 
r_data
[
j
] <= 
w_data_in
[j];

232 
end


233 
state
 <= 
READING
;

234 
end


236 
state
 <= 
IDLE
;

237 
end


238 
READING
:
begin


239 
r_hit
 <= 
hit0
;

240 
r_dirty
 <= 
status_bits0
[
STATUS_BITS
-2];

241 
r_include
 <= 
status_bits0
[
STATUS_BITS
-3];

242 
r_coh_bits
 <= 
coh_bits0
;

243 
r_tag
 <= 
tag_in0
;

244 
r_matched_way
 <= 
matched_way0
;

245 for(
j
=0; j<
CACHE_WORDS
; j=j+1)
begin


246 
r_data_out
[
j
] <= 
w_read_data
[j];

247 
end


248 
state
 <= 
SERVING
;

249 
end


250 
SERVING
:
begin


251 case(
r_msg
)

252 
R_REQ
:
begin


253 if(
r_hit
)
begin


254 
r_msg_out
 <= (
r_coh_bits
==
INVALID
) ? 
MEM_RESP
 : 
MEM_RESP_S
;

255 
write
 <= 1'b1;

256 
r_tag_out
 <= 
r_tag
;

257 
r_way_select
 <= 
r_matched_way
;

258 
r_meta_data
 <= (
r_coh_bits
 == 
INVALID
) ?

259 {1'b1, r_dirty, 1'
b1
, 
EXCLUSIVE
} :

260 {1'b1, r_dirty, 1'
b1
, 
SHARED
 } ;

261 for(
j
=0; j<
CACHE_WORDS
; j=j+1)
begin


262 
r_data
[
j
] <= 
r_data_out
[j];

263 
end


264 
state
 <= 
RESPOND
;

265 
end


266 else 
begin


267 if(
r_include
)
begin


268 
flush_active
 <= 1'b1;

269 
r_msg_out
 <= 
REQ_FLUSH
;

270 
r_address
[
ADDRESS_BITS
-1 -: 
TAG_BITS
] <= 
r_tag
;

271 
state
 <= 
RESPOND
;

272 
end


273 else if(
r_dirty
)
begin


274 
r_cache2mem_msg
 <= 
WB_REQ
;

275 
r_cache2mem_address
 <= {
r_tag
, 
r_address
[
OFFSET_BITS
 +:

276 
INDEX_BITS
], {
OFFSET_BITS
{1'b0}}};

277 for(
j
=0; j<
CACHE_WORDS
; j=j+1)
begin


278 
r_data
[
j
] <= 
r_data_out
[j];

279 
end


280 
state
 <= 
WRITE_BACK
;

281 
end


282 else 
begin


283 
r_cache2mem_msg
 <= 
R_REQ
;

284 
r_cache2mem_address
 <= {
r_address
[
ADDRESS_BITS
-1:
OFFSET_BITS
],

285 {
OFFSET_BITS
{1'b0}}};

286 
state
 <= 
READ_WAIT
;

287 
end


288 
end


289 
end


290 
RFO_BCAST
:
begin


291 if(
r_hit
)
begin


292 
r_msg_out
 <= 
MEM_RESP
;

293 
write
 <= 1'b1;

294 
r_tag_out
 <= 
r_tag
;

295 
r_way_select
 <= 
r_matched_way
;

296 
r_meta_data
 <= {1'b1, r_dirty, 1'
b1
, 
EXCLUSIVE
};

297 for(
j
=0; j<
CACHE_WORDS
; j=j+1)
begin


298 
r_data
[
j
] <= 
r_data_out
[j];

299 
end


300 
state
 <= 
RESPOND
;

301 
end


302 else 
begin


303 if(
r_include
)
begin


304 
flush_active
 <= 1'b1;

305 
r_msg_out
 <= 
REQ_FLUSH
;

306 
r_address
[
ADDRESS_BITS
-1 -: 
TAG_BITS
] <= 
r_tag
;

307 
state
 <= 
RESPOND
;

308 
end


309 else if(
r_dirty
)
begin


310 
r_cache2mem_msg
 <= 
WB_REQ
;

311 
r_cache2mem_address
 <= {
r_tag
, 
r_address
[
OFFSET_BITS
 +:

312 
INDEX_BITS
], {
OFFSET_BITS
{1'b0}}};

313 for(
j
=0; j<
CACHE_WORDS
; j=j+1)
begin


314 
r_data
[
j
] <= 
r_data_out
[j];

315 
end


316 
state
 <= 
WRITE_BACK
;

317 
end


318 else 
begin


319 
r_cache2mem_msg
 <= 
R_REQ
;

320 
r_cache2mem_address
 <= {
r_address
[
ADDRESS_BITS
-1:
OFFSET_BITS
],

321 {
OFFSET_BITS
{1'b0}}};

322 
state
 <= 
READ_WAIT
;

323 
end


324 
end


325 
end


326 
WB_REQ
:
begin


327 
write
 <= 1'b1;

328 
r_tag_out
 <= 
r_tag
;

329 
r_way_select
 <= 
r_matched_way
;

330 
r_meta_data
 <= (
r_coh_bits
 == 
EXCLUSIVE
) ? {3'b110, INVALID} :

332 
r_msg_out
 <= 
MEM_RESP
;

333 
state
 <= 
RESPOND
;

334 
end


335 
FLUSH
:
begin


336 
flush_active
 <= 1'b1;

337 
r_tag_out
 <= 
r_tag
;

338 
r_msg_out
 <= 
REQ_FLUSH
;

339 
state
 <= 
RESPOND
;

340 
end


341 
FLUSH_S
:
begin


342 if(
flush_active
)
begin


343 if(
r_hit
 & 
r_dirty
)
begin


344 
invalidate
 <= 1'b1;

345 
r_tag_out
 <= 
r_tag
;

346 
r_way_select
 <= 
r_matched_way
;

347 
r_cache2mem_address
 <= 
r_address
;

348 for(
j
=0; j<
CACHE_WORDS
; j=j+1)
begin


349 
r_data
[
j
] <= 
r_data_out
[j];

350 
end


351 
r_cache2mem_msg
 <= 
FLUSH
;

352 
flush_active
 <= 1'b0;

353 
state
 <= 
FLUSH_WAIT
;

354 
end


355 else if(
r_hit
 & ~
r_dirty
)
begin


356 
invalidate
 <= 1'b1;

357 
r_msg_out
 <= 
MEM_RESP
;

358 
flush_active
 <= 1'b0;

359 
state
 <= 
RESPOND
;

360 
end


362 else 
begin


363 
r_msg_out
 <= 
MEM_RESP
;

364 
flush_active
 <= 1'b0;

365 
state
 <= 
RESPOND
;

366 
end


367 
end


368 else 
begin


369 if(
r_hit
)
begin


370 
flush_active
 <= 1'b1;

371 
r_tag_out
 <= 
r_tag
;

372 
r_msg_out
 <= 
REQ_FLUSH
;

373 
state
 <= 
RESPOND
;

374 
end


375 else 
begin


376 
r_msg_out
 <= 
MEM_RESP
;

377 
state
 <= 
RESPOND
;

378 
end


379 
end


380 
end


381 
C_WB
:
begin


382 
write
 <= 1'b1;

383 
r_tag_out
 <= 
r_tag
;

384 
r_way_select
 <= 
r_matched_way
;

385 
r_meta_data
 <= (
r_coh_bits
 == 
EXCLUSIVE
) ? {3'b110, INVALID} :

387 
r_msg_out
 <= 
MEM_C_RESP
;

388 
state
 <= 
RESPOND
;

389 
end


390 
C_FLUSH
:
begin


391 
invalidate
 <= 1'b1;

392 
r_tag_out
 <= 
r_tag
;

393 
r_way_select
 <= 
r_matched_way
;

394 
r_cache2mem_address
 <= 
r_address
;

395 
r_cache2mem_msg
 <= 
FLUSH
;

396 
state
 <= 
FLUSH_WAIT
;

397 
end


398 default:
begin


399 
state
 <= 
IDLE
;

400 
end


401 
endcase


402 
end


403 
WRITE_BACK
:
begin


404 if(
mem2cache_msg
 == 
MEM_RESP
)
begin


405 
r_cache2mem_msg
 <= 
NO_REQ
;

406 
r_cache2mem_address
 <= {
ADDRESS_BITS
{1'b0}};

407 
invalidate
 <= 1'b1;

408 
state
 <= 
READ_STATE
;

409 
end


411 
state
 <= 
WRITE_BACK
;

412 
end


413 
READ_STATE
:
begin


414 
invalidate
 <= 1'b0;

415 
r_cache2mem_msg
 <= 
R_REQ
;

416 
r_cache2mem_address
 <= {
r_address
[
ADDRESS_BITS
-1:
OFFSET_BITS
],

417 {
OFFSET_BITS
{1'b0}}};

418 
state
 <= 
READ_WAIT
;

419 
end


420 
READ_WAIT
:
begin


421 if(
mem2cache_msg
 == 
MEM_RESP
)
begin


422 
r_msg_out
 <= 
MEM_RESP
;

423 for(
j
=0; j<
CACHE_WORDS
; j=j+1)
begin


424 
r_data
[
j
] <= 
w_mem_data
[j];

425 
r_data_out
[
j
] <= 
w_mem_data
[j];

426 
end


427 
r_tag_out
 <= 
r_address
[
ADDRESS_BITS
-1 -: 
TAG_BITS
];

428 
r_way_select
 <= 
r_matched_way
;

429 
r_meta_data
 <= {3'b101, EXCLUSIVE};

430 
write
 <= 1'b1;

431 
r_cache2mem_msg
 <= 
NO_REQ
;

432 
r_cache2mem_address
 <= {
ADDRESS_BITS
{1'b0}};

433 
state
 <= 
RESPOND
;

434 
end


436 
state
 <= 
READ_WAIT
;

437 
end


438 
RESPOND
:
begin


439 
write
 <= 1'b0;

440 
invalidate
 <= 1'b0;

441 
r_msg_out
 <= 
NO_REQ
;

442 
state
 <= 
IDLE
;

443 
end


444 
FLUSH_WAIT
:
begin


445 
invalidate
 <= 1'b0;

446 if(
mem2cache_msg
 == 
MEM_RESP
)
begin


447 
r_msg_out
 <= 
MEM_C_RESP
;

448 
r_cache2mem_msg
 <= 
NO_REQ
;

449 
r_cache2mem_address
 <= {
ADDRESS_BITS
{1'b0}};

450 
state
 <= 
RESPOND
;

451 
end


453 
state
 <= 
FLUSH_WAIT
;

454 
end


455 default:
begin


456 
state
 <= 
IDLE
;

457 
end


458 
endcase


459 
end


460 
end


463 
assign
 
read0
 = (
state
 == 
IDLE
) & (
msg_in
 != 
NO_REQ
);

464 
assign
 
write0
 = 
write
;

465 
assign
 
invalidate0
 = 
invalidate
;

466 
assign
 
tag0
 = (
state
 == 
IDLE
) ? 
address
[
ADDRESS_BITS
-1 -: 
TAG_BITS
] :

467 
r_tag_out
;

468 
assign
 
meta_data0
 = 
r_meta_data
;

469 
assign
 
way_select0
 = 
r_way_select
;

471 
assign
 
index0
 = (
state
 == 
RESET
) ? 
reset_counter
 :

472 (
state
 == 
IDLE
 ) ? 
address
[
OFFSET_BITS
 +: 
INDEX_BITS
] :

473 
r_address
[
OFFSET_BITS
 +: 
INDEX_BITS
];

475 
assign
 
msg_out
 = 
r_msg_out
;

476 
assign
 
out_address
 = 
r_address
;

478 
generate


479 for(
i
=0; i<
CACHE_WORDS
; i=i+1)
begin
: 
DATAOUT


480 
assign
 
data_out
[
i
*
DATA_WIDTH
 +: DATA_WIDTH] = 
r_data_out
[i];

481 
end


482 for(
i
=0; i<
CACHE_WORDS
; i=i+1)
begin
: 
C2MDATA


483 
assign
 
cache2mem_data
[
i
*
DATA_WIDTH
 +: DATA_WIDTH] = 
r_data
[i];

484 
end


485 for(
i
=0; i<
CACHE_WORDS
; i=i+1)
begin
: 
DATA0


486 
assign
 
data0
[
i
*
DATA_WIDTH
 +: DATA_WIDTH] = 
r_data
[i];

487 
end


488 
endgenerate


490 
assign
 
cache2mem_msg
 = 
r_cache2mem_msg
;

491 
assign
 
cache2mem_address
 = 
r_cache2mem_address
;

494 
endmodule


	@Lxcache_wrapper.v

23 
module
 
	gLxcache_wrapper
 #(

24 
parameter
 
	gSTATUS_BITS
 = 3,

25 
	gCOHERENCE_BITS
 = 2,

26 
	gCACHE_OFFSET_BITS
 = 2,

27 
	gDATA_WIDTH
 = 32,

28 
	gNUMBER_OF_WAYS
 = 4,

29 
	gREPLACEMENT_MODE
 = 0,

30 
	gADDRESS_BITS
 = 32,

31 
	gINDEX_BITS
 = 10,

32 
	gMSG_BITS
 = 4,

33 
	gBUS_OFFSET_BITS
 = 1,

34 
	gMAX_OFFSET_BITS
 = 3

36 
clock
,

37 
	greset
,

38 
	gaddress
,

39 
	gdata_in
,

40 
	gmsg_in
,

41 
	greq_ready
,

42 
	greq_offset
,

43 
	greport
,

44 
	gdata_out
,

45 
	gout_address
,

46 
	gmsg_out
,

47 
	gactive_offset
,

49 
	gmem2cache_msg
,

50 
	gmem2cache_address
,

51 
	gmem2cache_data
,

52 
	gcache2mem_msg
,

53 
	gcache2mem_address
,

54 
	gcache2mem_data


58 
function
 
integer
 
	glog2
;

59 
input
 
integer
 
	gvalue
;

60 
begin


61 
	gvalue
 = 
value
-1;

62 for (
	glog2
=0; 
	gvalue
>0; log2=
log2
+1)

63 
value
 = value >> 1;

64 
end


65 
endfunction


68 
localparam
 
	gCACHE_WORDS
 = 1 << 
CACHE_OFFSET_BITS
;

69 
localparam
 
	gBUS_WORDS
 = 1 << 
BUS_OFFSET_BITS
;

70 
localparam
 
	gCACHE_WIDTH
 = 
DATA_WIDTH
*
CACHE_WORDS
;

71 
localparam
 
	gBUS_WIDTH
 = 
DATA_WIDTH
*
BUS_WORDS
;

72 
localparam
 
	gTAG_BITS
 = 
ADDRESS_BITS
 - 
CACHE_OFFSET_BITS
 - 
INDEX_BITS
;

73 
localparam
 
	gMBITS
 = 
COHERENCE_BITS
 + 
STATUS_BITS
;

74 
localparam
 
	gWAY_BITS
 = (
NUMBER_OF_WAYS
 > 1) ? 
	$log2
(
NUMBER_OF_WAYS
) : 1;

77 
input
 
clock
;

78 
input
 
reset
;

79 
input
 [
ADDRESS_BITS
-1:0] 
address
;

80 
input
 [
BUS_WIDTH
-1 :0] 
data_in
;

81 
input
 [
MSG_BITS
-1 :0] 
msg_in
;

82 
input
 
req_ready
;

83 
input
 [
	$log2
(
MAX_OFFSET_BITS
):0] 
req_offset
;

84 
input
 
report
;

85 
output
 [
BUS_WIDTH
-1 :0] 
data_out
;

86 
output
 [
ADDRESS_BITS
-1:0] 
out_address
;

87 
output
 [
MSG_BITS
-1 :0] 
msg_out
;

88 
output
 [
	$log2
(
MAX_OFFSET_BITS
):0] 
active_offset
;

90 
input
 [
MSG_BITS
-1 :0] 
mem2cache_msg
;

91 
input
 [
ADDRESS_BITS
-1:0] 
mem2cache_address
;

92 
input
 [
CACHE_WIDTH
-1 :0] 
mem2cache_data
;

93 
output
 [
MSG_BITS
-1 :0] 
cache2mem_msg
;

94 
output
 [
ADDRESS_BITS
-1:0] 
cache2mem_address
;

95 
output
 [
CACHE_WIDTH
-1 :0] 
cache2mem_data
;

99 
wire
 [
MSG_BITS
-1:0] 
intf2ctrl_msg
;

100 
wire
 [
ADDRESS_BITS
-1:0] 
intf2ctrl_address
;

101 
wire
 [
CACHE_WIDTH
-1:0] 
intf2ctrl_data
;

102 
wire
 [
MSG_BITS
-1:0] 
ctrl2intf_msg
;

103 
wire
 [
ADDRESS_BITS
-1:0] 
ctrl2intf_address
;

104 
wire
 [
CACHE_WIDTH
-1:0] 
ctrl2intf_data
;

105 
wire
 
read0
;

106 
wire
 
write0
;

107 
wire
 
invalidate0
;

108 
wire
 [
INDEX_BITS
-1:0] 
index0
;

109 
wire
 [
TAG_BITS
-1:0] 
tag0
;

110 
wire
 [
MBITS
-1:0] 
meta_data0
;

111 
wire
 [
CACHE_WIDTH
-1:0] 
data0
;

112 
wire
 [
WAY_BITS
-1:0] 
way_select0
;

113 
wire
 [
CACHE_WIDTH
-1:0] 
data_in0
;

114 
wire
 [
TAG_BITS
-1:0] 
tag_in0
;

115 
wire
 [
WAY_BITS
-1:0] 
matched_way0
;

116 
wire
 [
COHERENCE_BITS
-1:0] 
coh_bits0
;

117 
wire
 [
STATUS_BITS
-1:0] 
status_bits0
;

118 
wire
 
hit0
;

119 
wire
 
i_reset
;

123 
Lx_bus_interface
 #(

124 .
	`CACHE_OFFSET_BITS
(
CACHE_OFFSET_BITS
),

125 .
	`BUS_OFFSET_BITS
(
BUS_OFFSET_BITS
),

126 .
	`DATA_WIDTH
(
DATA_WIDTH
),

127 .
	`ADDRESS_WIDTH
(
ADDRESS_BITS
),

128 .
	`MSG_BITS
(
MSG_BITS
),

129 .
	$MAX_OFFSET_BITS
(
MAX_OFFSET_BITS
)

130 ) 
	`bus_interface
 (

131 .
	`clock
(
clock
),

132 .
	`reset
(
reset
),

134 .
	`bus_msg_in
(
msg_in
),

135 .
	`bus_address_in
(
address
),

136 .
	`bus_data_in
(
data_in
),

137 .
	`bus_msg_out
(
msg_out
),

138 .
	`bus_address_out
(
out_address
),

139 .
	`bus_data_out
(
data_out
),

140 .
	`req_offset
(
req_offset
),

141 .
	`req_ready
(
req_ready
),

142 .
	`active_offset
(
active_offset
),

144 .
	`cache_msg_in
(
ctrl2intf_msg
),

145 .
	`cache_address_in
(
ctrl2intf_address
),

146 .
	`cache_data_in
(
ctrl2intf_data
),

147 .
	`cache_msg_out
(
intf2ctrl_msg
),

148 .
	`cache_address_out
(
intf2ctrl_address
),

149 .
	`cache_data_out
(
intf2ctrl_data
)

154 
cache_memory
 #(

155 .
	`STATUS_BITS
(
STATUS_BITS
),

156 .
	`COHERENCE_BITS
(
COHERENCE_BITS
),

157 .
	`OFFSET_BITS
(
CACHE_OFFSET_BITS
),

158 .
	`DATA_WIDTH
(
DATA_WIDTH
),

159 .
	`NUMBER_OF_WAYS
(
NUMBER_OF_WAYS
),

160 .
	`REPLACEMENT_MODE
(
REPLACEMENT_MODE
),

161 .
	`ADDRESS_BITS
(
ADDRESS_BITS
),

162 .
	$INDEX_BITS
(
INDEX_BITS
)

163 ) 
	`memory
 (

164 .
	`clock
(
clock
),

165 .
	`reset
(
i_reset
),

167 .
	`read0
(
read0
),

168 .
	`write0
(
write0
),

169 .
	`invalidate0
(
invalidate0
),

170 .
	`index0
(
index0
),

171 .
	`tag0
(
tag0
),

172 .
	`meta_data0
(
meta_data0
),

173 .
	`data_in0
(
data0
),

174 .
	`way_select0
(
way_select0
),

175 .
	`data_out0
(
data_in0
),

176 .
	`tag_out0
(
tag_in0
),

177 .
	`matched_way0
(
matched_way0
),

178 .
	`coh_bits0
(
coh_bits0
),

179 .
	`status_bits0
(
status_bits0
),

180 .
	`hit0
(
hit0
),

182 .
	`read1
(1'b0),

183 .
	`write1
(1'b0),

184 .
	`invalidate1
(1'b0),

185 .
	`index1
({
INDEX_BITS
{1'b0}}),

186 .
	`tag1
({
TAG_BITS
{1'b0}}),

187 .
	`meta_data1
({
MBITS
{1'b0}}),

188 .
	`data_in1
({
CACHE_WIDTH
{1'b0}}),

189 .
	`way_select1
({
WAY_BITS
{1'b0}}),

190 .
	`data_out1
(),

191 .
	`tag_out1
(),

192 .
	`matched_way1
(),

193 .
	`coh_bits1
(),

194 .
	`status_bits1
(),

195 .
	`hit1
(),

197 .
	`report
(
report
)

202 
Lxcache_controller
 #(

203 .
	`STATUS_BITS
(
STATUS_BITS
),

204 .
	`COHERENCE_BITS
(
COHERENCE_BITS
),

205 .
	`OFFSET_BITS
(
CACHE_OFFSET_BITS
),

206 .
	`DATA_WIDTH
(
DATA_WIDTH
),

207 .
	`NUMBER_OF_WAYS
(
NUMBER_OF_WAYS
),

208 .
	`ADDRESS_BITS
(
ADDRESS_BITS
),

209 .
	`INDEX_BITS
(
INDEX_BITS
),

210 .
	`MSG_BITS
(
MSG_BITS
)

211 ) 
	`controller
 (

212 .
	`clock
(
clock
),

213 .
	`reset
(
reset
),

214 .
	`address
(
intf2ctrl_address
),

215 .
	`data_in
(
intf2ctrl_data
),

216 .
	`msg_in
(
intf2ctrl_msg
),

217 .
	`report
(
report
),

218 .
	`data_out
(
ctrl2intf_data
),

219 .
	`out_address
(
ctrl2intf_address
),

220 .
	`msg_out
(
ctrl2intf_msg
),

222 .
	`mem2cache_msg
(
mem2cache_msg
),

223 .
	`mem2cache_address
(
mem2cache_address
),

224 .
	`mem2cache_data
(
mem2cache_data
),

225 .
	`cache2mem_msg
(
cache2mem_msg
),

226 .
	`cache2mem_address
(
cache2mem_address
),

227 .
	`cache2mem_data
(
cache2mem_data
),

229 .
	`read0
(
read0
),

230 .
	`write0
(
write0
),

231 .
	`invalidate0
(
invalidate0
),

232 .
	`index0
(
index0
),

233 .
	`tag0
(
tag0
),

234 .
	`meta_data0
(
meta_data0
),

235 .
	`data0
(
data0
),

236 .
	`way_select0
(
way_select0
),

237 .
	`i_reset
(
i_reset
),

238 .
	`data_in0
(
data_in0
),

239 .
	`tag_in0
(
tag_in0
),

240 .
	`matched_way0
(
matched_way0
),

241 .
	`coh_bits0
(
coh_bits0
),

242 .
	`status_bits0
(
status_bits0
),

243 .
	`hit0
(
hit0
)

247 
endmodule


	@arbiter.v

23 
module
 
	garbiter
 #(

24 
parameter
 
	gWIDTH
 = 4

26 
clock
,

27 
	greset
,

28 
	grequests
,

29 
	ggrant


33 
function
 
integer
 
	glog2
;

34 
input
 
integer
 
	gvalue
;

35 
begin


36 
	gvalue
 = 
value
-1;

37 for (
	glog2
=0; 
	gvalue
>0; log2=
log2
+1)

38 
value
 = value >> 1;

39 
end


40 
endfunction


42 
input
 
	gclock
, 
	greset
;

43 
	ginput
 [
WIDTH
-1 : 0] 
requests
;

44 
	goutput
 [
log2
(
WIDTH
)-1 : 0] 
grant
;

46 
integer
 
	gj
;

47 
	greg
 [
WIDTH
-1 : 0] 
mask
;

48 
	gwire
 [
WIDTH
-1 : 0] 
masked_requests
;

49 
wire
 
	gmasked_valid
, 
	gunmasked_valid
;

50 
	gwire
 [
log2
(
WIDTH
)-1 : 0] 
masked_encoded
, 
	gunmasked_encoded
;

54 
	gpriority_encoder
 #(
	gWIDTH
, "LSB")

55 
masked_encoder
(
masked_requests
, 
masked_encoded
, 
masked_valid
);

56 
	gpriority_encoder
 #(
	gWIDTH
, "LSB")

57 
unmasked_encoder
(
requests
, 
unmasked_encoded
, 
unmasked_valid
);

59 
	galways
 @(
posedge
 
	gclock
)
begin


60 if(
	greset
)

61 
	gmask
 <= {
WIDTH
{1'b1}};

62 else 
begin


63 for(
j
=0; 
	gj
<
	gWIDTH
; j=j+1)
begin


64 
mask
[
j
] <= (j < 
grant
) ? 0 : 1;

65 
end


66 
end


67 
end


69 
assign
 
	gmasked_requests
 = 
requests
 & 
mask
;

70 
assign
 
	ggrant
 = (
masked_requests
 == 0) ? 
unmasked_encoded
 : 
masked_encoded
;

72 
	gendmodule


	@cache_controller.v

23 
module
 
	gcache_controller
 #(

24 
parameter
 
	gSTATUS_BITS
 = 2,

25 
	gCOHERENCE_BITS
 = 2,

26 
	gOFFSET_BITS
 = 0,

27 
	gDATA_WIDTH
 = 32,

28 
	gNUMBER_OF_WAYS
 = 4,

29 
	gADDRESS_BITS
 = 32,

30 
	gINDEX_BITS
 = 8,

31 
	gMSG_BITS
 = 4,

32 
	gCORE
 = 0,

33 
	gCACHE_NO
 = 0

35 
clock
, 
	greset
,

36 
	gread
, 
	gwrite
, 
	ginvalidate
, 
	gflush
,

37 
	gw_byte_en
,

38 
	gaddress
,

39 
	gdata_in
,

40 
	greport
,

41 
	gdata_out
,

42 
	gout_address
,

43 
	gready
,

44 
	gvalid
,

46 
	gdata_in0
,

47 
	gtag_in0
,

48 
	gmatched_way0
,

49 
	gcoh_bits0
,

50 
	gstatus_bits0
,

51 
	ghit0
,

52 
	gread0
,

53 
	gwrite0
,

54 
	ginvalidate0
,

55 
	gindex0
,

56 
	gtag0
,

57 
	gmeta_data0
,

58 
	gdata_out0
,

59 
	gway_select0
,

60 
	gread1
,

61 
	gwrite1
,

62 
	ginvalidate1
,

63 
	gindex1
,

64 
	gtag1
,

65 
	gmeta_data1
,

66 
	gdata_out1
,

67 
	gway_select1
,

68 
	gi_reset
,

70 
	gmem2cache_msg
,

71 
	gmem2cache_data
,

72 
	gmem2cache_address
,

73 
	gcache2mem_msg
,

74 
	gcache2mem_data
,

75 
	gcache2mem_address
,

77 
	gsnoop_address
,

78 
	gsnoop_read
,

79 
	gsnoop_modify


83 
function
 
integer
 
	glog2
;

84 
input
 
integer
 
	gvalue
;

85 
begin


86 
	gvalue
 = 
value
-1;

87 for (
	glog2
=0; 
	gvalue
>0; log2=
log2
+1)

88 
value
 = value >> 1;

89 
end


90 
endfunction


93 
localparam
 
	gCACHE_WORDS
 = 1 << 
OFFSET_BITS
;

94 
localparam
 
	gCACHE_WIDTH
 = 
DATA_WIDTH
*
CACHE_WORDS
;

95 
localparam
 
	gSBITS
 = 
COHERENCE_BITS
 + 
STATUS_BITS
;

96 
localparam
 
	gTAG_BITS
 = 
ADDRESS_BITS
 - 
OFFSET_BITS
 - 
INDEX_BITS
;

97 
localparam
 
	gWAY_BITS
 = (
NUMBER_OF_WAYS
 > 1) ? 
	$log2
(
NUMBER_OF_WAYS
) : 1;

98 
localparam
 
CACHE_DEPTH
 = 1 << 
INDEX_BITS
;

101 
localparam
 
IDLE
 = 4'd0,

102 
RESET
 = 4'd1,

103 
WAIT_FOR_ACCESS
 = 4'd2,

104 
CACHE_ACCESS
 = 4'd3,

105 
READ_STATE
 = 4'd4,

106 
WRITE_BACK
 = 4'd5,

107 
WAIT
 = 4'd6,

108 
UPDATE
 = 4'd7,

109 
WB_WAIT
 = 4'd8,

110 
SRV_FLUSH_REQ
 = 4'd9,

111 
WAIT_FLUSH_REQ
 = 4'd10,

112 
SRV_INVLD_REQ
 = 4'd11,

113 
WAIT_INVLD_REQ
 = 4'd12,

114 
WAIT_WS_ENABLE
 = 4'd13,

115 
REACCESS
 = 4'd14;

122 `
include
 "./params.h"

124 
input
 
clock
, 
reset
;

125 
input
 
read
, 
write
, 
invalidate
, 
flush
;

126 
input
 [
DATA_WIDTH
/8-1:0] 
w_byte_en
;

127 
input
 [
ADDRESS_BITS
-1:0] 
address
;

128 
input
 [
DATA_WIDTH
-1: 0] 
data_in
;

129 
input
 
report
;

130 
output
 [
DATA_WIDTH
-1: 0] 
data_out
;

131 
output
 [
ADDRESS_BITS
-1:0] 
out_address
;

132 
output
 
ready
;

133 
output
 
valid
;

136 
input
 [
CACHE_WIDTH
-1 :0] 
data_in0
;

137 
input
 [
TAG_BITS
-1 :0] 
tag_in0
;

138 
input
 [
WAY_BITS
-1 :0] 
matched_way0
;

139 
input
 [
COHERENCE_BITS
-1:0] 
coh_bits0
;

140 
input
 [
STATUS_BITS
-1 :0] 
status_bits0
;

141 
input
 
hit0
;

142 
output
 
read0
, 
write0
, 
invalidate0
;

143 
output
 [
INDEX_BITS
-1 :0] 
index0
;

144 
output
 [
TAG_BITS
-1 :0] 
tag0
;

145 
output
 [
SBITS
-1 :0] 
meta_data0
;

146 
output
 [
CACHE_WIDTH
-1 :0] 
data_out0
;

147 
output
 [
WAY_BITS
-1 :0] 
way_select0
;

149 
output
 
read1
, 
write1
, 
invalidate1
;

150 
output
 [
INDEX_BITS
-1 :0] 
index1
;

151 
output
 [
TAG_BITS
-1 :0] 
tag1
;

152 
output
 [
SBITS
-1 :0] 
meta_data1
;

153 
output
 [
CACHE_WIDTH
-1 :0] 
data_out1
;

154 
output
 [
WAY_BITS
-1 :0] 
way_select1
;

155 
output
 
i_reset
;

158 
input
 [
MSG_BITS
-1: 0] 
mem2cache_msg
;

159 
input
 [
CACHE_WIDTH
-1: 0] 
mem2cache_data
;

160 
input
 [
ADDRESS_BITS
-1:0] 
mem2cache_address
;

161 
output
 [
MSG_BITS
-1: 0] 
cache2mem_msg
;

162 
output
 [
CACHE_WIDTH
-1: 0] 
cache2mem_data
;

163 
output
 [
ADDRESS_BITS
-1:0] 
cache2mem_address
;

166 
input
 [
ADDRESS_BITS
-1:0] 
snoop_address
;

167 
input
 
snoop_read
;

168 
input
 
snoop_modify
;

171 
genvar
 
i
, 
byte
;

172 
integer
 
j
, 
k
;

174 
reg
 [3:0] 
state
;

175 
reg
 [
INDEX_BITS
-1:0] 
reset_counter
;

176 
reg
 [
ADDRESS_BITS
-1:0] 
REQ1_address
, 
REQ2_address
;

177 
reg
 [
DATA_WIDTH
-1:0] 
REQ1_data
 , 
REQ2_data
;

178 
reg
 
REQ1_read
, 
REQ1_write
, 
REQ1_flush
, 
REQ1_invalidate
, 
REQ2_read
, 
REQ2_write
,

179 
REQ2_flush
, 
REQ2_invalidate
;

180 
reg
 [
DATA_WIDTH
/8-1:0] 
REQ1_w_byte_en
, 
REQ2_w_byte_en
;

181 
reg
 [
DATA_WIDTH
-1:0] 
r_line_out
 [
CACHE_WORDS
-1:0];

182 
reg
 [
WAY_BITS
-1:0] 
r_matched_way
;

183 
reg
 
r_dirty_bit
;

184 
reg
 [
MSG_BITS
-1:0] 
r_cache2mem_msg
;

185 
reg
 [
DATA_WIDTH
-1:0] 
r_cache2mem_data
 [
CACHE_WORDS
-1:0];

186 
reg
 [
ADDRESS_BITS
-1:0] 
r_cache2mem_address
;

187 
reg
 [
DATA_WIDTH
-1 : 0] 
r_words_from_mem
 [
CACHE_WORDS
-1:0];

188 
reg
 [
MSG_BITS
-1:0] 
r_transaction
;

189 
reg
 [
TAG_BITS
-1:0] 
r_tag_out
;

190 
reg
 [
COHERENCE_BITS
-1:0] 
r_coh_bits_from_mem
;

191 
reg
 
reaccess_delay
;

193 
wire
 
request
, 
REQ2
;

194 
wire
 [(
ADDRESS_BITS
-
OFFSET_BITS
)-1:0] 
addr_line
, 
sn_addr_line
, 
wb_addr_line
;

195 
wire
 [(
ADDRESS_BITS
-
OFFSET_BITS
)-1:0] 
REQ1_line
, 
REQ2_line
;

196 
wire
 [
INDEX_BITS
-1:0] 
REQ1_index
, 
REQ2_index
, 
address_index
, 
snoop_index
;

197 
wire
 [
TAG_BITS
-1:0] 
REQ1_tag
, 
REQ2_tag
, 
address_tag
;

198 
wire
 [
OFFSET_BITS
-1:0] 
REQ1_offset
;

199 
wire
 [
DATA_WIDTH
-1:0] 
line_out_words
 [
CACHE_WORDS
-1:0];

200 
wire
 
stall
;

201 
wire
 [
OFFSET_BITS
-1:0] 
zero_offset
;

202 
wire
 
dirty0
;

205 
wire
 [
ADDRESS_BITS
-1:0] 
REQ1_word_addr
, 
REQ2_word_addr
;

206 
wire
 [
ADDRESS_BITS
-1:0] 
address_shifted
;

209 
assign
 
REQ1_word_addr
 = 
REQ1_address
 >> 2;

210 
assign
 
REQ2_word_addr
 = 
REQ2_address
 >> 2;

211 
assign
 
address_shifted
 = 
address
 >> 2;

213 
assign
 
dirty0
 = 
status_bits0
[
STATUS_BITS
-2];

214 
assign
 
request
 = 
read
 | 
write
 | 
flush
 | 
invalidate
 ;

215 
assign
 
REQ2
 = 
REQ2_read
 | 
REQ2_write
 | 
REQ2_flush
 | 
REQ2_invalidate
;

217 
assign
 
addr_line
 = 
address_shifted
[
ADDRESS_BITS
-1 : 
OFFSET_BITS
];

218 
assign
 
sn_addr_line
 = 
snoop_address
[
ADDRESS_BITS
-1 : 
OFFSET_BITS
];

219 
assign
 
wb_addr_line
 = {
r_tag_out
, 
REQ1_index
};
	}
REQ1_index};

220 
assign
 
	gREQ1_line
 = 
REQ1_word_addr
[
ADDRESS_BITS
-1 : 
OFFSET_BITS
];

221 
assign
 
	gREQ2_line
 = 
REQ2_word_addr
[
ADDRESS_BITS
-1 : 
OFFSET_BITS
];

222 
assign
 
	gaddress_index
 = 
address_shifted
[
OFFSET_BITS
 +: 
INDEX_BITS
];

223 
assign
 
	gREQ1_index
 = 
REQ1_word_addr
[
OFFSET_BITS
 +: 
INDEX_BITS
];

224 
assign
 
	gREQ2_index
 = 
REQ2_word_addr
[
OFFSET_BITS
 +: 
INDEX_BITS
];

225 
assign
 
	gsnoop_index
 = 
snoop_address
[
OFFSET_BITS
 +: 
INDEX_BITS
];

226 
assign
 
	gREQ1_tag
 = 
REQ1_word_addr
[
ADDRESS_BITS
-1 -: 
TAG_BITS
];

227 
assign
 
	gREQ2_tag
 = 
REQ2_word_addr
[
ADDRESS_BITS
-1 -: 
TAG_BITS
];

228 
assign
 
	gaddress_tag
 = 
address_shifted
[
ADDRESS_BITS
-1 -: 
TAG_BITS
];

229 
assign
 
	gREQ1_offset
 = 
REQ1_word_addr
[0 +: 
OFFSET_BITS
];

230 
assign
 
	gzero_offset
 = 0;

232 
assign
 
	gstall
 = ((
REQ1_index
 == 
REQ2_index
 ) & 
REQ2
 & 
REQ1_write
) |

233 ((
REQ1_index
 == 
address_index
 ) & 
REQ1_write
 & 
request
 & 
ready
);

235 
generate


236 for(
	gi
=0; i<
	gCACHE_WORDS
; i=
i
+1)
begin
: 
LINEWORDS


237 
assign
 
line_out_words
[
i
] = 
data_in0
[i*
DATA_WIDTH
 +: DATA_WIDTH];

238 
end


239 
endgenerate


243 
	galways
 @(
posedge
 
	gclock
)
begin


244 if(
	greset
 & (
	gstate
 != 
RESET
))
begin


245 
reset_counter
 <= {
INDEX_BITS
{1'b0}};

246 
REQ1_address
 <= {
ADDRESS_BITS
{1'b0}};

247 
REQ1_data
 <= {
DATA_WIDTH
{1'b0}};

248 
REQ1_read
 <= 1'b0;

249 
REQ1_write
 <= 1'b0;

250 
REQ1_flush
 <= 1'b0;

251 
REQ1_invalidate
 <= 1'b0;

252 
REQ1_w_byte_en
 <= {
DATA_WIDTH
/8{1'b0}};

253 
REQ2_address
 <= {
ADDRESS_BITS
{1'b0}};

254 
REQ2_data
 <= {
DATA_WIDTH
{1'b0}};

255 
REQ2_read
 <= 1'b0;

256 
REQ2_write
 <= 1'b0;

257 
REQ2_flush
 <= 1'b0;

258 
REQ2_invalidate
 <= 1'b0;

259 
REQ2_w_byte_en
 <= {
DATA_WIDTH
/8{1'b0}};

260 for(
j
=0; 
	gj
<
	gCACHE_WORDS
; j=j+1)
begin


261 
r_line_out
[
j
] <= {
DATA_WIDTH
{1'b0}};

262 
end


263 
r_matched_way
 <= {
WAY_BITS
{1'b0}};

264 
r_dirty_bit
 <= 1'b0;

265 
r_cache2mem_address
 <= {
ADDRESS_BITS
{1'b0}};

266 for(
j
=0; 
	gj
<
	gCACHE_WORDS
; j=j+1)
begin


267 
r_cache2mem_data
[
j
] <= {
DATA_WIDTH
{1'b0}};

268 
r_words_from_mem
[
j
] <= {
DATA_WIDTH
{1'b0}};

269 
end


270 
r_cache2mem_msg
 <= 
NO_REQ
;

271 
	gr_coh_bits_from_mem
 <= 2'b00;

272 
reaccess_delay
 <= 1'b0;

273 
state
 <= 
RESET
;

274 
end


275 else 
begin


276 case(
	gstate
)

277 
	gRESET
:
begin


278 if(
reset_counter
 < 
CACHE_DEPTH
-1)
begin


279 
reset_counter
 <= reset_counter + 1;

280 
end


281 else if((
	greset_counter
 == 
CACHE_DEPTH
-1) & ~
reset
)
begin


282 
reset_counter
 <= {
INDEX_BITS
{1'b0}};

283 
state
 <= 
IDLE
;

284 
end


285 
end


286 
	gIDLE
:
begin


287 if(
request
 & 
snoop_modify
 & (
address_index
 == 
snoop_index
))
begin


288 
REQ2_read
 <= 
read
;

289 
	gREQ2_write
 <= 
write
;

290 
	gREQ2_flush
 <= 
flush
;

291 
	gREQ2_invalidate
 <= 
invalidate
;

292 
	gREQ2_address
 <= 
address
;

293 
	gREQ2_data
 <= 
data_in
;

294 
	gREQ2_w_byte_en
 <= 
w_byte_en
;

295 
	gstate
 <= 
WAIT_FOR_ACCESS
;

296 
end


297 else 
begin


298 
	gREQ1_address
 <= 
address
;

299 
	gREQ1_data
 <= 
data_in
;

300 
	gREQ1_read
 <= 
read
;

301 
	gREQ1_write
 <= 
write
;

302 
	gREQ1_flush
 <= 
flush
;

303 
	gREQ1_invalidate
 <= 
invalidate
;

304 
	gREQ1_w_byte_en
 <= 
w_byte_en
;

305 
	gstate
 <= 
request
 ? 
CACHE_ACCESS
 : 
IDLE
;

306 
end


307 
end


308 
	gCACHE_ACCESS
:
begin


309 for(
j
=0; 
	gj
<
	gCACHE_WORDS
; j=j+1)
begin


310 
r_line_out
[
j
] <= 
data_in0
[j*
DATA_WIDTH
 +: DATA_WIDTH];

311 
end


312 
	gr_matched_way
 <= 
matched_way0
;

313 
	gr_tag_out
 <= 
tag_in0
;

314 
	gr_dirty_bit
 <= 
dirty0
;

315 if((
	gsnoop_modify
|
	gsnoop_read
) & 
	gREQ1_write
)
begin


316 
	gREQ2_address
 <= 
REQ2
 ? 
REQ2_address
 : 
address
;

317 
	gREQ2_data
 <= 
REQ2
 ? 
REQ2_data
 : 
data_in
;

318 
	gREQ2_read
 <= 
REQ2
 ? 
REQ2_read
 : 
read
;

319 
	gREQ2_write
 <= 
REQ2
 ? 
REQ2_write
 : 
write
;

320 
	gREQ2_flush
 <= 
REQ2
 ? 
REQ2_flush
 : 
flush
;

321 
	gREQ2_invalidate
 <= 
REQ2
 ? 
REQ2_invalidate
 : 
invalidate
;

322 
	gREQ2_w_byte_en
 <= 
REQ2
 ? 
REQ2_w_byte_en
 : 
w_byte_en
;

323 
	greaccess_delay
 <= 
snoop_read
 ? 1'b1 : 1'
b0
;

324 
	gstate
 <= 
REACCESS
;

325 
end


327 else if(
	ghit0
)
begin


328 if(
	gREQ1_write
 & (
	gcoh_bits0
 == 
SHARED
))
begin


329 
REQ2_address
 <= 
REQ2
 ? REQ2_address : 
address
;

330 
	gREQ2_data
 <= 
REQ2
 ? 
REQ2_data
 : 
data_in
;

331 
	gREQ2_read
 <= 
REQ2
 ? 
REQ2_read
 : 
read
;

332 
	gREQ2_write
 <= 
REQ2
 ? 
REQ2_write
 : 
write
;

333 
	gREQ2_flush
 <= 
REQ2
 ? 
REQ2_flush
 : 
flush
;

334 
	gREQ2_invalidate
 <= 
REQ2
 ? 
REQ2_invalidate
 : 
invalidate
;

335 
	gREQ2_w_byte_en
 <= 
REQ2
 ? 
REQ2_w_byte_en
 : 
w_byte_en
;

336 
	gr_cache2mem_address
 <= (
REQ1_word_addr
 >> 
OFFSET_BITS
)

337 << 
OFFSET_BITS
;

338 
	gr_cache2mem_msg
 <= 
WS_BCAST
;

339 
	gstate
 <= 
WAIT_WS_ENABLE
;

340 
end


341 else if(
	gstall
)
begin


342 
	gREQ1_data
 <= {
DATA_WIDTH
{1'b0}};

343 
REQ1_address
 <= {
ADDRESS_BITS
{1'b0}};

344 
REQ1_read
 <= 1'b0;

345 
REQ1_write
 <= 1'b0;

346 
REQ1_flush
 <= 1'b0;

347 
REQ1_invalidate
 <= 1'b0;

348 
REQ1_w_byte_en
 <= {
DATA_WIDTH
/8{1'b0}};

349 
REQ2_address
 <= 
REQ2
 ? REQ2_address : 
address
;

350 
	gREQ2_data
 <= 
REQ2
 ? 
REQ2_data
 : 
data_in
;

351 
	gREQ2_read
 <= 
REQ2
 ? 
REQ2_read
 : 
read
;

352 
	gREQ2_write
 <= 
REQ2
 ? 
REQ2_write
 : 
write
;

353 
	gREQ2_flush
 <= 
REQ2
 ? 
REQ2_flush
 : 
flush
;

354 
	gREQ2_invalidate
 <= 
REQ2
 ? 
REQ2_invalidate
 : 
invalidate
;

355 
	gREQ2_w_byte_en
 <= 
REQ2
 ? 
REQ2_w_byte_en
 : 
w_byte_en
;

356 
	gstate
 <= 
WAIT_FOR_ACCESS
;

357 
end


359 else if(
	grequest
 & 
	gsnoop_modify
 & (
	gaddress_index
 == 
snoop_index
))
begin


360 
REQ2_read
 <= 
read
;

361 
	gREQ2_write
 <= 
write
;

362 
	gREQ2_invalidate
 <= 
invalidate
;

363 
	gREQ2_flush
 <= 
flush
;

364 
	gREQ2_address
 <= 
address
;

365 
	gREQ2_data
 <= 
data_in
;

366 
	gREQ2_w_byte_en
 <= 
w_byte_en
;

367 if(
	gREQ1_flush
)
begin


368 
	gstate
 <= 
SRV_FLUSH_REQ
;

369 
end


370 else if(
	gREQ1_invalidate
)
begin


371 
	gstate
 <= 
SRV_INVLD_REQ
;

372 
end


373 else 
begin


374 
	gstate
 <= 
WAIT_FOR_ACCESS
;

375 
end


376 
end


378 else 
begin


379 
	gREQ1_read
 <= 
REQ2
 ? 1'b0 : read;

380 
REQ1_write
 <= 
REQ2
 ? 1'b0 : write;

381 
REQ1_flush
 <= 
REQ2
 ? 1'b0 : flush;

382 
REQ1_invalidate
 <= 
REQ2
 ? 1'b0 : invalidate;

383 
REQ1_address
 <= 
REQ2
 ? {
ADDRESS_BITS
{1'b0}} : address;

384 
REQ1_data
 <= 
REQ2
 ? {
DATA_WIDTH
{1'b0}} : data_in;

385 
REQ1_w_byte_en
 <= 
REQ2
 ? {
DATA_WIDTH
/8{1'b0}} : w_byte_en;

386 if(
REQ1_flush
)
begin


387 
state
 <= 
SRV_FLUSH_REQ
;

388 
end


389 else if(
	gREQ1_invalidate
)
begin


390 
	gstate
 <= 
SRV_INVLD_REQ
;

391 
end


392 else 
begin


393 
	gstate
 <= 
REQ2
 ? 
WAIT_FOR_ACCESS
 : (
request
 & 
ready
) ? 
CACHE_ACCESS
 : 
IDLE
;

394 
end


395 
end


396 
end


397 else 
begin


398 
	gREQ2_read
 <= 
REQ2
 ? 
REQ2_read
 : 
read
;

399 
	gREQ2_write
 <= 
REQ2
 ? 
REQ2_write
 : 
write
;

400 
	gREQ2_flush
 <= 
REQ2
 ? 
REQ2_flush
 : 
flush
;

401 
	gREQ2_invalidate
 <= 
REQ2
 ? 
REQ2_invalidate
 : 
invalidate
;

402 
	gREQ2_address
 <= 
REQ2
 ? 
REQ2_address
 : 
address
;

403 
	gREQ2_data
 <= 
REQ2
 ? 
REQ2_data
 : 
data_in
;

404 
	gREQ2_w_byte_en
 <= 
REQ2
 ? 
REQ2_w_byte_en
 : 
w_byte_en
;

405 if(
	gREQ1_flush
)
begin


406 
	gstate
 <= 
SRV_FLUSH_REQ
;

407 
end


408 else if(
	gREQ1_invalidate
)
begin


409 
	gstate
 <= 
SRV_INVLD_REQ
;

410 
end


411 else 
begin


412 
	gstate
 <= 
dirty0
 ? 
WRITE_BACK
 : 
READ_STATE
;

413 
end


414 
end


415 
end


416 
	gREAD_STATE
:
begin


417 if(
snoop_modify
 & (
sn_addr_line
 == 
REQ1_line
))
begin


418 
state
 <= 
REACCESS
;

419 
end


420 else 
begin


421 
	gr_cache2mem_msg
 <= 
REQ1_write
 ? 
RFO_BCAST
 : 
R_REQ
;

422 
	gr_cache2mem_address
 <= (
REQ1_word_addr
 >> 
OFFSET_BITS
) << OFFSET_BITS;

423 for(
	gj
=0; j<
	gCACHE_WORDS
; j=
j
+1)
begin


424 
r_cache2mem_data
[
j
] <= {
DATA_WIDTH
{1'b0}};

425 
end


426 
state
 <= 
WAIT
;

427 
end


428 
end


429 
	gWAIT
:
begin


430 if(
snoop_modify
 & (
sn_addr_line
 == 
REQ1_line
))
begin


431 
r_cache2mem_msg
 <= 
NO_REQ
;

432 
	gr_cache2mem_address
 <= {
ADDRESS_BITS
{1'b0}};

433 
state
 <= 
REACCESS
;

434 
end


435 else if((
	gmem2cache_msg
 == 
MEM_RESP
) | 
mem2cache_msg
 == 
MEM_RESP_S
)
begin


436 
r_cache2mem_msg
 <= 
NO_REQ
;

437 
	gr_cache2mem_address
 <= {
ADDRESS_BITS
{1'b0}};

438 
state
 <= 
UPDATE
;

439 for(
	gj
=0; j<
	gCACHE_WORDS
; j=
j
+1)
begin


440 
r_words_from_mem
[
j
] <= 
mem2cache_data
[j*
DATA_WIDTH
 +: DATA_WIDTH];

441 
end


442 
	gr_coh_bits_from_mem
 <= (
mem2cache_msg
 == 
MEM_RESP
) ? 2'b01 : 2'
b11
;

443 
end


444 else 
begin


445 
	gstate
 <= 
WAIT
;

446 
end


447 
end


448 
	gUPDATE
:
begin


449 if(
snoop_modify
 & (
sn_addr_line
 == 
REQ1_line
))

450 
state
 <= 
REACCESS
;

452 
	gstate
 <= 
WAIT_FOR_ACCESS
;

453 
end


454 
	gWAIT_FOR_ACCESS
:
begin


455 if(
stall
)
begin


456 
REQ1_data
 <= {
DATA_WIDTH
{1'b0}};

457 
REQ1_read
 <= 1'b0;

458 
REQ1_write
 <= 1'b0;

459 
REQ1_flush
 <= 1'b0;

460 
REQ1_invalidate
 <= 1'b0;

461 
REQ1_w_byte_en
 <= {
DATA_WIDTH
/8{1'b0}};

462 
state
 <= 
WAIT_FOR_ACCESS
;

463 
end


464 else if(
	gsnoop_modify
 & 
	gREQ2
 & (
	gsnoop_index
 == 
REQ2_index
))
begin


465 
state
 <= 
WAIT_FOR_ACCESS
;

466 
end


467 else 
begin


468 
	gREQ1_address
 <= 
REQ2_address
;

469 
	gREQ1_data
 <= 
REQ2_data
;

470 
	gREQ1_read
 <= 
REQ2_read
;

471 
	gREQ1_write
 <= 
REQ2_write
;

472 
	gREQ1_flush
 <= 
REQ2_flush
;

473 
	gREQ1_invalidate
 <= 
REQ2_invalidate
;

474 
	gREQ1_w_byte_en
 <= 
REQ2_w_byte_en
;

475 
	gREQ2_address
 <= 0;

476 
	gREQ2_data
 <= 0;

477 
	gREQ2_read
 <= 0;

478 
	gREQ2_write
 <= 0;

479 
	gREQ2_flush
 <= 0;

480 
	gREQ2_invalidate
 <= 0;

481 
	gREQ2_w_byte_en
 <= {
DATA_WIDTH
/8{1'b0}};

482 
state
 <= 
REQ2
 ? 
CACHE_ACCESS
 : 
IDLE
;

483 
end


484 
end


485 
	gWRITE_BACK
:
begin


486 if(
snoop_modify
 & (
sn_addr_line
 == 
wb_addr_line
))
begin


487 
state
 <= 
REACCESS
;

488 
end


489 else 
begin


490 
	gr_cache2mem_msg
 <= 
WB_REQ
;

491 
	gr_cache2mem_address
 <= {
r_tag_out
, 
REQ1_index
, 
zero_offset
};

492 for(
	gj
=0; j<
	gCACHE_WORDS
; j=
j
+1)
begin


493 
r_cache2mem_data
[
j
] <= 
r_line_out
[j];

494 
end


495 
	gstate
 <= 
WB_WAIT
;

496 
end


497 
end


498 
	gWB_WAIT
:
begin


499 if(
snoop_modify
 & (
snoop_index
 == 
REQ1_index
))
begin


500 
r_cache2mem_msg
 <= 
NO_REQ
;

501 
	gr_cache2mem_address
 <= {
ADDRESS_BITS
{1'b0}};

502 for(
j
=0; 
	gj
<
	gCACHE_WORDS
; j=j+1)
begin


503 
r_cache2mem_data
[
j
] <= {
DATA_WIDTH
{1'b0}};

504 
end


505 
state
 <= 
REACCESS
;

506 
end


507 else if(
	gmem2cache_msg
 == 
MEM_RESP
)
begin


508 
r_cache2mem_msg
 <= 
NO_REQ
;

509 
	gr_cache2mem_address
 <= {
ADDRESS_BITS
{1'b0}};

510 for(
j
=0; 
	gj
<
	gCACHE_WORDS
; j=j+1)
begin


511 
r_cache2mem_data
[
j
] <= {
DATA_WIDTH
{1'b0}};

512 
end


513 
state
 <= 
READ_STATE
;

514 
end


516 
	gstate
 <= 
WB_WAIT
;

517 
end


518 
	gSRV_FLUSH_REQ
:
begin


519 if(
snoop_modify
 & (
sn_addr_line
 == 
REQ1_line
))
begin


520 
state
 <= 
REACCESS
;

521 
end


522 else 
begin


523 
	gr_cache2mem_msg
 <= 
r_dirty_bit
 ? 
FLUSH
 : 
FLUSH_S
;

524 
	gr_cache2mem_address
 <= (
REQ1_word_addr
 >> 
OFFSET_BITS
) << OFFSET_BITS;

525 for(
	gj
=0; j<
	gCACHE_WORDS
; j=
j
+1)
begin


526 
r_cache2mem_data
[
j
] <= 
r_line_out
[j];

527 
end


528 
	gstate
 <= 
WAIT_FLUSH_REQ
;

529 
end


530 
end


531 
	gWAIT_FLUSH_REQ
:
begin


532 if(
snoop_modify
 & (
sn_addr_line
 == 
REQ1_line
))
begin


533 
r_cache2mem_msg
 <= 
NO_REQ
;

534 
	gr_cache2mem_address
 <= {
ADDRESS_BITS
{1'b0}};

535 for(
j
=0; 
	gj
<
	gCACHE_WORDS
; j=j+1)
begin


536 
r_cache2mem_data
[
j
] <= {
DATA_WIDTH
{1'b0}};

537 
end


538 
state
 <= 
REACCESS
;

539 
end


540 else if(
	gmem2cache_msg
 == 
MEM_RESP
)
begin


541 
r_cache2mem_msg
 <= 
NO_REQ
;

542 
	gr_cache2mem_address
 <= {
ADDRESS_BITS
{1'b0}};

543 for(
j
=0; 
	gj
<
	gCACHE_WORDS
; j=j+1)
begin


544 
r_cache2mem_data
[
j
] <= {
DATA_WIDTH
{1'b0}};

545 
end


546 
state
 <= 
IDLE
;

547 
end


548 else 
begin


549 
	gstate
 <= 
WAIT_FLUSH_REQ
;

550 
end


551 
end


552 
	gSRV_INVLD_REQ
:
begin


553 if(
snoop_modify
 & (
sn_addr_line
 == 
REQ1_line
))
begin


554 
state
 <= 
REACCESS
;

555 
end


556 else 
begin


557 
	gr_cache2mem_msg
 <= 
r_dirty_bit
 ? 
FLUSH
 : 
FLUSH_S
;

558 
	gr_cache2mem_address
 <= (
REQ1_word_addr
 >> 
OFFSET_BITS
) << OFFSET_BITS;

559 for(
	gj
=0; j<
	gCACHE_WORDS
; j=
j
+1)
begin


560 
r_cache2mem_data
[
j
] <= 
r_line_out
[j];

561 
end


562 
	gstate
 <= 
WAIT_INVLD_REQ
;

563 
end


564 
end


565 
	gWAIT_INVLD_REQ
:
begin


566 if(
snoop_modify
 & (
sn_addr_line
 == 
REQ1_line
))
begin


567 
r_cache2mem_msg
 <= 
NO_REQ
;

568 
	gr_cache2mem_address
 <= {
ADDRESS_BITS
{1'b0}};

569 for(
j
=0; 
	gj
<
	gCACHE_WORDS
; j=j+1)
begin


570 
r_cache2mem_data
[
j
] <= {
DATA_WIDTH
{1'b0}};

571 
end


572 
state
 <= 
REACCESS
;

573 
end


574 else if(
	gmem2cache_msg
 == 
MEM_RESP
)
begin


575 
r_cache2mem_msg
 <= 
NO_REQ
;

576 
	gr_cache2mem_address
 <= {
ADDRESS_BITS
{1'b0}};

577 for(
j
=0; 
	gj
<
	gCACHE_WORDS
; j=j+1)
begin


578 
r_cache2mem_data
[
j
] <= {
DATA_WIDTH
{1'b0}};

579 
end


580 
state
 <= 
IDLE
;

581 
end


582 else 
begin


583 
	gstate
 <= 
WAIT_INVLD_REQ
;

584 
end


585 
end


586 
	gWAIT_WS_ENABLE
:
begin


587 if(
snoop_modify
 & (
sn_addr_line
 == 
REQ1_line
))
begin


588 
r_cache2mem_msg
 <= 
NO_REQ
;

589 
	gr_cache2mem_address
 <= {
ADDRESS_BITS
{1'b0}};

590 for(
j
=0; 
	gj
<
	gCACHE_WORDS
; j=j+1)
begin


591 
r_cache2mem_data
[
j
] <= {
DATA_WIDTH
{1'b0}};

592 
end


593 
state
 <= 
REACCESS
;

594 
end


595 else if(
	gmem2cache_msg
 == 
EN_ACCESS
)
begin


596 
r_cache2mem_msg
 <= 
NO_REQ
;

597 
	gr_cache2mem_address
 <= {
ADDRESS_BITS
{1'b0}};

598 for(
j
=0; 
	gj
<
	gCACHE_WORDS
; j=j+1)
begin


599 
r_cache2mem_data
[
j
] <= {
DATA_WIDTH
{1'b0}};

600 
end


601 
state
 <= 
WAIT_FOR_ACCESS
;

602 
end


603 else 
begin


604 
	gstate
 <= 
WAIT_WS_ENABLE
;

605 
end


606 
end


607 
	gREACCESS
:
begin


608 if(
reaccess_delay
)
begin


609 
reaccess_delay
 <= 1'b0;

610 
state
 <= 
REACCESS
;

611 
end


612 else if(
	gsnoop_modify
 & (
	gsn_addr_line
 == 
REQ1_line
))

613 
state
 <= 
REACCESS
;

615 
	gstate
 <= 
CACHE_ACCESS
;

616 
end


617 default:
begin


618 
state
 <= 
IDLE
;

619 
end


620 
endcase


621 
end


622 
end


628 
assign
 
	gread0
 = (((
state
 == 
IDLE
) | (state == 
CACHE_ACCESS
)) & 
request
) |

629 (
state
 == 
WAIT_FOR_ACCESS
) | (state == 
REACCESS
);

631 
assign
 
	gwrite0
 = (
state
 == 
RESET
) | (state == 
UPDATE
) |

632 ((
state
 == 
WAIT_WS_ENABLE
) & (
mem2cache_msg
 == 
EN_ACCESS
));

634 
assign
 
	ginvalidate0
 = (
mem2cache_msg
 == 
MEM_RESP
) & ((
state
 == 
WB_WAIT
) |

635 (
state
 == 
WAIT_FLUSH_REQ
) | (state == 
WAIT_INVLD_REQ
));

638 
assign
 
	gtag0
 = (
state
 == 
WAIT_FOR_ACCESS
) ? 
REQ2_tag
 :

639 (((
state
 == 
IDLE
) | (state == 
CACHE_ACCESS
)) & 
request
) ?

640 
address_tag
 : 
REQ1_tag
;

642 
assign
 
	gindex0
 = (
state
 == 
RESET
) ? 
reset_counter
 :

643 (
state
 == 
WAIT_FOR_ACCESS
) ? 
REQ2_index
 :

644 (((
state
 == 
IDLE
) | (state == 
CACHE_ACCESS
)) & 
request
) ?

645 
address_index
 : 
REQ1_index
;

648 
assign
 
	gmeta_data0
 = 
REQ1_write
 ? 4'b1110 : {2'
b10
, 
	gr_coh_bits_from_mem
};

650 
generate


651 for(
	gi
=0; i<
	gCACHE_WORDS
; i=
i
+1)
begin
: 
DATAOUT0


652 for(
byte
=0; 
	gbyte
<(
	gDATA_WIDTH
/8); byte=byte+1) 
begin
: 
BYTE_LOOP


654 
assign
 
data_out0
[(
i
*
DATA_WIDTH
)+(
byte
*8) +: 8] =

655 
REQ1_write
 & 
REQ1_w_byte_en
[
byte
] & (
i
 == 
REQ1_offset
) ? 
REQ1_data
[byte*8 +: 8] :

656 (
state
 == 
WAIT_WS_ENABLE
) ? 
r_line_out
[
i
][
byte
*8 +: 8] : 
r_words_from_mem
[i][byte*8 +: 8];

657 
end


658 
end


659 
endgenerate


662 
assign
 
	gway_select0
 = 
r_matched_way
;

663 
assign
 
	gread1
 = 1'b0;

664 
assign
 
write1
 = (
state
 == 
CACHE_ACCESS
) & 
REQ1_write
 & 
hit0
 &

665 (
coh_bits0
 != 
SHARED
);

666 
assign
 
	ginvalidate1
 = 1'b0;

667 
assign
 
index1
 = 
REQ1_index
;

668 
assign
 
	gtag1
 = 
REQ1_tag
;

669 
assign
 
	gmeta_data1
 = {2'b11, MODIFIED};

671 
generate


672 for(
i
=0; 
	gi
<
	gCACHE_WORDS
; i=i+1)
begin
:
DATA_OUT1


673 
assign
 
data_out1
[
i
*
DATA_WIDTH
 +: DATA_WIDTH] = (i == 
REQ1_offset
) ?

674 
REQ1_data
 : 
data_in0
[
i
*
DATA_WIDTH
 +: DATA_WIDTH];

675 
end


676 
endgenerate


678 
assign
 
	gway_select1
 = 
matched_way0
;

679 
assign
 
	gi_reset
 = 
reset
 | (
state
 == 
RESET
);

681 
assign
 
	gcache2mem_address
 = 
r_cache2mem_address
;

682 
generate


683 for(
	gi
=0; i<
	gCACHE_WORDS
; i=
i
+1)
begin
: 
DATA2MEM


684 
assign
 
cache2mem_data
[
i
*
DATA_WIDTH
 +: DATA_WIDTH] = 
r_cache2mem_data
[i];

685 
end


686 
endgenerate


687 
assign
 
	gcache2mem_msg
 = 
r_cache2mem_msg
;

688 
assign
 
	gout_address
 = 
REQ1_address
;

690 
generate


691 if(
	gOFFSET_BITS
>0)
begin


692 
assign
 
	gdata_out
 = (
state
 == 
CACHE_ACCESS
) & 
hit0
 & 
REQ1_read
 ?

693 
line_out_words
[
REQ1_offset
]

694 : (
state
 == 
UPDATE
) & 
REQ1_read
 ?

695 
r_words_from_mem
[
REQ1_offset
]

696 : {
DATA_WIDTH
{1'b0}};

697 
end


698 else 
begin


699 
assign
 
data_out
 = (
state
 == 
CACHE_ACCESS
) & 
hit0
 &

700 
REQ1_read
 ? 
line_out_words
[0]

701 : (
state
 == 
UPDATE
) & 
REQ1_read
 ?

702 
r_words_from_mem
[0]

703 : {
DATA_WIDTH
{1'b0}};

704 
end


705 
endgenerate


707 
assign
 
valid
 = (((
state
==
CACHE_ACCESS
) & 
hit0
) | (state == 
UPDATE
)) & 
REQ1_read
;

709 
assign
 
	gready
 = ((
state
 == 
IDLE
) & ~
flush
 & ~
invalidate
 & ~(
snoop_modify
 &

710 (
address_index
 == 
snoop_index
))) | ((
state
 == 
CACHE_ACCESS
) &

711 ~
REQ1_flush
 & ~
REQ1_invalidate
 & ~
REQ2
 & ~((
snoop_modify
 |

712 
snoop_read
 | (
coh_bits0
 == 
SHARED
) | (
REQ1_index
 == 
address_index
))

713 & 
REQ1_write
) & ~((
address_index
 == 
snoop_index
) & 
snoop_modify
)

714 & 
hit0
);

716 
	gendmodule


	@cache_hierarchy.v

23 
module
 
	gcache_hierarchy
 #(

24 
parameter
 
	gSTATUS_BITS_L1
 = 2,

25 
	gSTATUS_BITS_L2
 = 3,

26 
	gCOHERENCE_BITS
 = 2,

27 
	gOFFSET_BITS_L1
 = {32'd2, 32'
d2
, 32'd2, 32'd2},

28 
	gOFFSET_BITS_L2
 = 2,

29 
	gDATA_WIDTH
 = 32,

30 
	gNUMBER_OF_WAYS_L1
 = {32'd2, 32'
d2
, 32'd2, 32'd2},

31 
	gNUMBER_OF_WAYS_L2
 = 4,

32 
	gREPLACEMENT_MODE_L1
 = 1'b0,

33 
REPLACEMENT_MODE_L2
 = 1'b0,

34 
ADDRESS_BITS
 = 32,

35 
	gINDEX_BITS_L1
 = {32'd5, 32'
d5
, 32'd5, 32'd5},

36 
	gINDEX_BITS_L2
 = 6,

37 
	gMSG_BITS
 = 4,

38 
	gNUM_L1_CACHES
 = 4,

39 
	gBUS_OFFSET_BITS
 = 2,

40 
	gMAX_OFFSET_BITS
 = 2

42 
clock
, 
	greset
,

43 
	gread
, 
	gwrite
, 
	ginvalidate
, 
	gflush
,

44 
	gw_byte_en
,

45 
	gaddress
,

46 
	gdata_in
,

47 
	greport
,

48 
	gdata_out
,

49 
	gout_address
,

50 
	gready
,

51 
	gvalid
,

52 
	gmem2cachehier_msg
,

53 
	gmem2cachehier_address
,

54 
	gmem2cachehier_data
,

55 
	gcachehier2mem_msg
,

56 
	gcachehier2mem_address
,

57 
	gcachehier2mem_data


61 
function
 
integer
 
	glog2
;

62 
input
 
integer
 
	gvalue
;

63 
begin


64 
	gvalue
 = 
value
-1;

65 for(
	glog2
=0; 
	gvalue
>0; log2=
log2
+1)

66 
value
 = value>>1;

67 
end


68 
	gendfunction


75 `
	ginclude
 "./params.h"

77 
localparam
 
	gBUS_WORDS
 = 1 << 
BUS_OFFSET_BITS
;

78 
localparam
 
	gBUS_WIDTH
 = 
BUS_WORDS
*
DATA_WIDTH
;

79 
localparam
 
	gL2_WORDS
 = 1 << 
OFFSET_BITS_L2
;

80 
localparam
 
	gL2_WIDTH
 = 
L2_WORDS
*
DATA_WIDTH
;

81 
localparam
 
	gBUS_PORTS
 = 
NUM_L1_CACHES
 + 1;

82 
localparam
 
	gMEM_PORT
 = 
BUS_PORTS
 - 1;

83 
localparam
 
	gBUS_SIG_WIDTH
 = 
log2
(
BUS_PORTS
);

84 
localparam
 
	gWIDTH_BITS
 = 
log2
(
MAX_OFFSET_BITS
) + 1;

88 
input
 
	gclock
, 
	greset
;

89 
input
 
	greport
;

90 
	ginput
 [
NUM_L1_CACHES
-1:0] 
read
, 
	gwrite
, 
	ginvalidate
, 
	gflush
;

91 
	ginput
 [
NUM_L1_CACHES
*
DATA_WIDTH
/8-1:0] 
w_byte_en
;

92 
	ginput
 [
NUM_L1_CACHES
*
ADDRESS_BITS
-1:0] 
address
;

93 
	ginput
 [
NUM_L1_CACHES
*
DATA_WIDTH
-1 :0] 
data_in
;

94 
	goutput
 [
NUM_L1_CACHES
*
ADDRESS_BITS
-1:0] 
out_address
;

95 
	goutput
 [
NUM_L1_CACHES
*
DATA_WIDTH
-1 :0] 
data_out
;

96 
	goutput
 [
NUM_L1_CACHES
-1:0] 
valid
, 
	gready
;

98 
	ginput
 [
MSG_BITS
-1 :0] 
mem2cachehier_msg
;

99 
	ginput
 [
ADDRESS_BITS
-1:0] 
mem2cachehier_address
;

100 
	ginput
 [
L2_WIDTH
-1 :0] 
mem2cachehier_data
;

101 
	goutput
 [
MSG_BITS
-1 :0] 
cachehier2mem_msg
;

102 
	goutput
 [
ADDRESS_BITS
-1:0] 
cachehier2mem_address
;

103 
	goutput
 [
L2_WIDTH
-1 :0] 
cachehier2mem_data
;

107 
genvar
 
	gi
;

108 
	gwire
 [
DATA_WIDTH
-1 :0] 
w_data_in
 [
NUM_L1_CACHES
-1:0];

109 
	gwire
 [
DATA_WIDTH
/8-1:0] 
w_w_byte_en
 [
NUM_L1_CACHES
-1:0];

110 
	gwire
 [
ADDRESS_BITS
-1:0] 
w_address
 [
NUM_L1_CACHES
-1:0];

111 
	gwire
 [
DATA_WIDTH
-1 :0] 
w_data_out
 [
NUM_L1_CACHES
-1:0];

112 
	gwire
 [
ADDRESS_BITS
-1:0] 
w_out_address
 [
NUM_L1_CACHES
-1:0];

114 
	gwire
 [
MSG_BITS
-1 :0] 
w_l1tobus_msg
 [
NUM_L1_CACHES
-1:0];

115 
	gwire
 [
ADDRESS_BITS
-1:0] 
w_l1tobus_address
 [
NUM_L1_CACHES
-1:0];

116 
	gwire
 [
BUS_WIDTH
-1 :0] 
w_l1tobus_data
 [
NUM_L1_CACHES
-1:0];

117 
	gwire
 [
WIDTH_BITS
-1 :0] 
w_l1tobus_offset
 [
NUM_L1_CACHES
-1:0];

119 
	gwire
 [
NUM_L1_CACHES
*
MSG_BITS
-1 :0] 
l1tobus_msg
;

120 
	gwire
 [
NUM_L1_CACHES
*
ADDRESS_BITS
-1:0] 
l1tobus_address
;

121 
	gwire
 [
NUM_L1_CACHES
*
BUS_WIDTH
-1 :0] 
l1tobus_data
;

122 
	gwire
 [
NUM_L1_CACHES
*
WIDTH_BITS
-1 :0] 
l1tobus_offset
;

124 
	gwire
 [
MSG_BITS
-1 :0] 
l2tobus_msg
;

125 
	gwire
 [
ADDRESS_BITS
-1:0] 
l2tobus_address
;

126 
	gwire
 [
BUS_WIDTH
-1 :0] 
l2tobus_data
;

127 
	gwire
 [
WIDTH_BITS
-1 :0] 
l2tobus_offset
;

129 
	gwire
 [
MSG_BITS
-1 :0] 
bus_msg
;

130 
	gwire
 [
ADDRESS_BITS
-1:0] 
bus_address
;

131 
	gwire
 [
BUS_WIDTH
-1 :0] 
bus_data
;

132 
	gwire
 [
WIDTH_BITS
-1 :0] 
req_offset
;

134 
	gwire
 [
NUM_L1_CACHES
-1:0] 
bus_master
;

135 
	gwire
 [
BUS_SIG_WIDTH
-1:0] 
bus_ctrl
;

136 
wire
 
	greq_ready
;

137 
wire
 
	gbus_en
;

141 
generate


142 for(
	gi
=0; i<
	gNUM_L1_CACHES
; i=
i
+1)
begin
: 
INPUTS


143 
assign
 
w_w_byte_en
[
i
] = 
w_byte_en
[i*
DATA_WIDTH
/8 +: DATA_WIDTH/8];

144 
assign
 
	gw_address
[
i
] = 
address
[i*
ADDRESS_BITS
 +: ADDRESS_BITS];

145 
assign
 
	gw_data_in
[
i
] = 
data_in
[i*
DATA_WIDTH
 +: DATA_WIDTH ];

146 
end


147 
endgenerate


150 
generate


151 for(
	gi
=0; i<
	gNUM_L1_CACHES
; i=
i
+1)
begin
: 
OUTPUTS


152 
assign
 
data_out
[
i
*
DATA_WIDTH
 +: DATA_WIDTH] = 
w_data_out
[i];

153 
assign
 
	gout_address
[
i
*
ADDRESS_BITS
 +: ADDRESS_BITS] = 
w_out_address
[i];

154 
end


155 for(
	gi
=0; i<
	gNUM_L1_CACHES
; i=
i
+1)
begin
: 
BUS_SIGNALS


156 
assign
 
l1tobus_msg
[
i
*
MSG_BITS
+:MSG_BITS] = 
w_l1tobus_msg
[i];

157 
assign
 
	gl1tobus_address
[
i
*
ADDRESS_BITS
+:ADDRESS_BITS] = 
w_l1tobus_address
[i];

158 
assign
 
	gl1tobus_data
[
i
*
BUS_WIDTH
+:BUS_WIDTH] = 
w_l1tobus_data
[i];

159 
assign
 
	gl1tobus_offset
[
i
*
WIDTH_BITS
+:WIDTH_BITS] = 
w_l1tobus_offset
[i];

160 
end


161 
endgenerate


165 
generate


166 for(
	gi
=0; i<
	gNUM_L1_CACHES
; i=
i
+1)
begin
: 
L1INST


167 
L1cache_wrapper
 #(

168 .
STATUS_BITS
(
STATUS_BITS_L1
),

169 .
COHERENCE_BITS
(COHERENCE_BITS),

170 .
CACHE_OFFSET_BITS
(
OFFSET_BITS_L1
[
i
*32 +: 32]),

171 .
DATA_WIDTH
(DATA_WIDTH),

172 .
NUMBER_OF_WAYS
(
NUMBER_OF_WAYS_L1
[
i
*32 +: 32]),

173 .
ADDRESS_BITS
(ADDRESS_BITS),

174 .
INDEX_BITS
(
INDEX_BITS_L1
[
i
*32 +: 32]),

175 .
MSG_BITS
(MSG_BITS),

176 .
BUS_OFFSET_BITS
(BUS_OFFSET_BITS),

177 .
MAX_OFFSET_BITS
(MAX_OFFSET_BITS),

178 .
REPLACEMENT_MODE
(
REPLACEMENT_MODE_L1
),

179 .
CORE
(
i
/2),

180 .
	$CACHE_NO
(
i
)

181 ) 
	`l1cache
 (

182 .
	`clock
(
clock
),

183 .
	`reset
(
reset
),

185 .
	`read
(
read
[
i
]),

186 .
	`write
(
write
[
i
]),

187 .
	`w_byte_en
(
w_w_byte_en
[
i
]),

188 .
	`invalidate
(
invalidate
[
i
]),

189 .
	`flush
(
flush
[
i
]),

190 .
	`address
(
w_address
[
i
]),

191 .
	`data_in
(
w_data_in
[
i
]),

192 .
	`report
(
report
),

193 .
	`data_out
(
w_data_out
[
i
]),

194 .
	`out_address
(
w_out_address
[
i
]),

195 .
	`ready
(
ready
[
i
]),

196 .
	`valid
(
valid
[
i
]),

198 .
	`bus_msg_in
(
bus_msg
),

199 .
	`bus_address_in
(
bus_address
),

200 .
	`bus_data_in
(
bus_data
),

201 .
	`bus_msg_out
(
w_l1tobus_msg
[
i
]),

202 .
	`bus_address_out
(
w_l1tobus_address
[
i
]),

203 .
	`bus_data_out
(
w_l1tobus_data
[
i
]),

204 .
	`active_offset
(
w_l1tobus_offset
[
i
]),

205 .
	`bus_master
(
bus_master
[
i
]),

206 .
	`req_ready
(
req_ready
),

207 .
	`curr_offset
(
req_offset
)

209 
end


210 
endgenerate


214 
mux_bus
 #(

215 .
	`WIDTH
(
MSG_BITS
),

216 .
	$NUM_PORTS
(
BUS_PORTS
)

217 ) 
	`msg_bus
 (

218 .
	`data_in
({
l2tobus_msg
, 
l1tobus_msg
}),
	}
l1tobus_msg}),

219 .
enable_port
(
bus_ctrl
),

220 .
valid_enable
(
bus_en
),

221 .
data_out
(
bus_msg
)

224 
	gmux_bus
 #(

225 .
WIDTH
(
ADDRESS_BITS
),

226 .
	$NUM_PORTS
(
BUS_PORTS
)

227 ) 
	`address_bus
 (

228 .
	`data_in
({
l2tobus_address
, 
l1tobus_address
}),
	}
l1tobus_address}),

229 .
enable_port
(
bus_ctrl
),

230 .
valid_enable
(
bus_en
),

231 .
data_out
(
bus_address
)

234 
	gmux_bus
 #(

235 .
WIDTH
(
BUS_WIDTH
),

236 .
	$NUM_PORTS
(
BUS_PORTS
)

237 ) 
	`data_bus
 (

238 .
	`data_in
({
l2tobus_data
, 
l1tobus_data
}),
	}
l1tobus_data}),

239 .
enable_port
(
bus_ctrl
),

240 .
valid_enable
(
bus_en
),

241 .
data_out
(
bus_data
)

244 
	gmux_bus
 #(

245 .
WIDTH
(
log2
(
MAX_OFFSET_BITS
) + 1),

246 .
	$NUM_PORTS
(
BUS_PORTS
)

247 ) 
	`offset_bus
 (

248 .
	`data_in
({
l2tobus_offset
, 
l1tobus_offset
}),
	}
l1tobus_offset}),

249 .
enable_port
(
bus_ctrl
),

250 .
valid_enable
(
bus_en
),

251 .
data_out
(
req_offset
)

256 
	gcoherence_controller
 #(

257 .
MSG_BITS
(MSG_BITS),

258 .
	$NUM_CACHES
(
NUM_L1_CACHES
)

259 ) 
	`bus_controller
 (

260 .
	`clock
(
clock
),

261 .
	`reset
(
reset
),

262 .
	`cache2mem_msg
(
l1tobus_msg
),

263 .
	`mem2controller_msg
(
l2tobus_msg
),

264 .
	`bus_msg
(
bus_msg
),

265 .
	`bus_control
(
bus_ctrl
),

266 .
	`bus_en
(
bus_en
),

267 .
	`curr_master
(
bus_master
),

268 .
	`req_ready
(
req_ready
)

273 
Lxcache_wrapper
 #(

274 .
	`STATUS_BITS
(
STATUS_BITS_L2
),

275 .
	`COHERENCE_BITS
(
COHERENCE_BITS
),

276 .
	`CACHE_OFFSET_BITS
(
OFFSET_BITS_L2
),

277 .
	`DATA_WIDTH
(
DATA_WIDTH
),

278 .
	`NUMBER_OF_WAYS
(
NUMBER_OF_WAYS_L2
),

279 .
	`REPLACEMENT_MODE
(
REPLACEMENT_MODE_L2
),

280 .
	`ADDRESS_BITS
(
ADDRESS_BITS
),

281 .
	`INDEX_BITS
(
INDEX_BITS_L2
),

282 .
	`MSG_BITS
(
MSG_BITS
),

283 .
	`BUS_OFFSET_BITS
(
BUS_OFFSET_BITS
),

284 .
	$MAX_OFFSET_BITS
(
MAX_OFFSET_BITS
)

285 ) 
	`l2cache
 (

286 .
	`clock
(
clock
),

287 .
	`reset
(
reset
),

288 .
	`address
(
bus_address
),

289 .
	`data_in
(
bus_data
),

290 .
	`msg_in
(
bus_msg
),

291 .
	`req_ready
(
req_ready
),

292 .
	`req_offset
(
req_offset
),

293 .
	`report
(
report
),

294 .
	`data_out
(
l2tobus_data
),

295 .
	`out_address
(
l2tobus_address
),

296 .
	`msg_out
(
l2tobus_msg
),

297 .
	`active_offset
(
l2tobus_offset
),

299 .
	`mem2cache_msg
(
mem2cachehier_msg
),

300 .
	`mem2cache_address
(
mem2cachehier_address
),

301 .
	`mem2cache_data
(
mem2cachehier_data
),

302 .
	`cache2mem_msg
(
cachehier2mem_msg
),

303 .
	`cache2mem_address
(
cachehier2mem_address
),

304 .
	`cache2mem_data
(
cachehier2mem_data
)

308 
endmodule


	@cache_memory.v

23 
module
 
	gcache_memory
 #(

24 
parameter
 
	gSTATUS_BITS
 = 2,

25 
	gCOHERENCE_BITS
 = 2,

26 
	gOFFSET_BITS
 = 2,

27 
	gDATA_WIDTH
 = 32,

28 
	gNUMBER_OF_WAYS
 = 4,

29 
	gREPLACEMENT_MODE
 = 0,

30 
	gADDRESS_BITS
 = 32,

31 
	gINDEX_BITS
 = 8

33 
clock
, 
	greset
,

35 
	gread0
, 
	gwrite0
, 
	ginvalidate0
,

36 
	gindex0
,

37 
	gtag0
,

38 
	gmeta_data0
,

39 
	gdata_in0
,

40 
	gway_select0
,

41 
	gdata_out0
,

42 
	gtag_out0
,

43 
	gmatched_way0
,

44 
	gcoh_bits0
,

45 
	gstatus_bits0
,

46 
	ghit0
,

48 
	gread1
, 
	gwrite1
, 
	ginvalidate1
,

49 
	gindex1
,

50 
	gtag1
,

51 
	gmeta_data1
,

52 
	gdata_in1
,

53 
	gway_select1
,

54 
	gdata_out1
,

55 
	gtag_out1
,

56 
	gmatched_way1
,

57 
	gcoh_bits1
,

58 
	gstatus_bits1
,

59 
	ghit1
,

61 
	greport


65 
function
 
integer
 
	glog2
;

66 
input
 
integer
 
	gvalue
;

67 
begin


68 
	gvalue
 = 
value
-1;

69 for (
	glog2
=0; 
	gvalue
>0; log2=
log2
+1)

70 
value
 = value >> 1;

71 
end


72 
endfunction


75 
localparam
 
	gWORDS_PER_LINE
 = 1 << 
OFFSET_BITS
;

76 
localparam
 
	gBLOCK_WIDTH
 = 
DATA_WIDTH
*
WORDS_PER_LINE
;

77 
localparam
 
	gSBITS
 = 
COHERENCE_BITS
 + 
STATUS_BITS
;

78 
localparam
 
	gTAG_BITS
 = 
ADDRESS_BITS
 - 
OFFSET_BITS
 - 
INDEX_BITS
;

79 
localparam
 
	gMBITS
 = 
SBITS
 + 
TAG_BITS
;

80 
localparam
 
	gWAY_BITS
 = (
NUMBER_OF_WAYS
 > 1) ? 
	$log2
(
NUMBER_OF_WAYS
) : 1;

81 
localparam
 
CACHE_DEPTH
 = 1 << 
INDEX_BITS
;

84 
input
 
clock
, 
reset
;

85 
input
 
read0
, 
write0
, 
invalidate0
;

86 
input
 [
INDEX_BITS
-1 :0] 
index0
;

87 
input
 [
TAG_BITS
-1 :0] 
tag0
;

88 
input
 [
SBITS
-1 :0] 
meta_data0
;

89 
input
 [
BLOCK_WIDTH
-1 :0] 
data_in0
;

90 
input
 [
WAY_BITS
-1 :0] 
way_select0
;

91 
output
 [
BLOCK_WIDTH
-1 :0] 
data_out0
;

92 
output
 [
TAG_BITS
-1 :0] 
tag_out0
;

93 
output
 [
WAY_BITS
-1 :0] 
matched_way0
;

94 
output
 [
COHERENCE_BITS
-1:0] 
coh_bits0
;

95 
output
 [
STATUS_BITS
-1 :0] 
status_bits0
;

96 
output
 
hit0
;

98 
input
 
read1
, 
write1
, 
invalidate1
;

99 
input
 [
INDEX_BITS
-1 :0] 
index1
;

100 
input
 [
TAG_BITS
-1 :0] 
tag1
;

101 
input
 [
SBITS
-1 :0] 
meta_data1
;

102 
input
 [
BLOCK_WIDTH
-1 :0] 
data_in1
;

103 
input
 [
WAY_BITS
-1 :0] 
way_select1
;

104 
output
 [
BLOCK_WIDTH
-1 :0] 
data_out1
;

105 
output
 [
TAG_BITS
-1 :0] 
tag_out1
;

106 
output
 [
WAY_BITS
-1 :0] 
matched_way1
;

107 
output
 [
COHERENCE_BITS
-1:0] 
coh_bits1
;

108 
output
 [
STATUS_BITS
-1 :0] 
status_bits1
;

109 
output
 
hit1
;

111 
input
 
report
;

114 
genvar
 
i
;

116 
reg
 
r_read0
, 
r_read1
;

117 
reg
 [
TAG_BITS
-1:0] 
r_tag0
, 
r_tag1
;

120 
wire
 [
NUMBER_OF_WAYS
-1:0] 
we0_d
, 
we1_d
;

121 
wire
 [
BLOCK_WIDTH
-1 :0] 
data_out0_d
 [
NUMBER_OF_WAYS
-1:0];

122 
wire
 [
BLOCK_WIDTH
-1 :0] 
data_out1_d
 [
NUMBER_OF_WAYS
-1:0];

125 
wire
 [
NUMBER_OF_WAYS
-1:0] 
we0_m
, 
we1_m
;

126 
wire
 [
MBITS
-1 :0] 
data_in0_m
 [
NUMBER_OF_WAYS
-1:0];

127 
wire
 [
MBITS
-1 :0] 
data_in1_m
 [
NUMBER_OF_WAYS
-1:0];

128 
wire
 [
COHERENCE_BITS
-1:0] 
cohbits_out0
 [
NUMBER_OF_WAYS
-1:0];

129 
wire
 [
COHERENCE_BITS
-1:0] 
cohbits_out1
 [
NUMBER_OF_WAYS
-1:0];

130 
wire
 [
TAG_BITS
-1 :0] 
tag_0
 [
NUMBER_OF_WAYS
-1:0];

131 
wire
 [
TAG_BITS
-1 :0] 
tag_1
 [
NUMBER_OF_WAYS
-1:0];

132 
wire
 [
STATUS_BITS
-1 :0] 
status_line0
 [
NUMBER_OF_WAYS
-1:0];

133 
wire
 [
STATUS_BITS
-1 :0] 
status_line1
 [
NUMBER_OF_WAYS
-1:0];

134 
wire
 [
NUMBER_OF_WAYS
-1:0] 
valid_line0
, 
valid_line1
;

136 
wire
 [
NUMBER_OF_WAYS
-1:0] 
tag_match0
, 
tag_match1
;

137 
wire
 [
WAY_BITS
-1 :0] 
decoded_tag_match0
, 
decoded_tag_match1
;

138 
wire
 
valid_tag_match0
, 
valid_tag_match1
;

140 
wire
 [
NUMBER_OF_WAYS
-1:0] 
replace_way_encoded
;

141 
wire
 [
WAY_BITS
-1 :0] 
replace_way
;

142 
wire
 
valid_replace_way
;

143 
wire
 [
INDEX_BITS
-1 :0] 
replace_index
;

144 
wire
 [
NUMBER_OF_WAYS
-1:0] 
ways_in_use
;

145 
wire
 [
WAY_BITS
-1 :0] 
current_access
;

146 
wire
 
access_valid
;

150 
generate


151 for(
i
=0; i<
NUMBER_OF_WAYS
; i=i+1)
begin
: 
DATA


152 
dual_port_ram_with_pass_through
 #(

153 .
	`DATA_WIDTH
(
BLOCK_WIDTH
),

154 .
	`ADDRESS_WIDTH
(
INDEX_BITS
),

155 .
	`INDEX_BITS
(
INDEX_BITS
),

156 .
	`RW
("OLD_DATA")

157 ) 
	`data_bram
 (

158 .
	`clock
(
clock
),

159 .
	`we0
(
we0_d
[
i
]),

160 .
	`we1
(
we1_d
[
i
]),

161 .
	`data_in0
(
data_in0
),

162 .
	`data_in1
(
data_in1
),

163 .
	`address0
(
index0
),

164 .
	`address1
(
index1
),

165 .
	`data_out0
(
data_out0_d
[
i
]),

166 .
	`data_out1
(
data_out1_d
[
i
])

168 
end


169 for(
i
=0; i<
NUMBER_OF_WAYS
; i=i+1)
begin
: 
MDATA


170 
dual_port_ram_with_pass_through
 #(

171 .
	`DATA_WIDTH
(
MBITS
),

172 .
	`ADDRESS_WIDTH
(
INDEX_BITS
),

173 .
	`INDEX_BITS
(
INDEX_BITS
),

174 .
	`RW
("OLD_DATA")

175 ) 
	`mdata_bram
 (

176 .
	`clock
(
clock
),

177 .
	`we0
(
we0_m
[
i
]),

178 .
	`we1
(
we1_m
[
i
]),

179 .
	`data_in0
(
data_in0_m
[
i
]),

180 .
	`data_in1
(
data_in1_m
[
i
]),

181 .
	`address0
(
index0
),

182 .
	`address1
(
index1
),

183 .
	`data_out0
({
status_line0
[
i
], 
cohbits_out0
[i], 
tag_0
[i]
	}
}),

184 .
data_out1
({
status_line1
[
i
], 
cohbits_out1
[i], 
tag_1
[i]})

186 
end


187 
endgenerate


190 
generate


191 if(
	gNUMBER_OF_WAYS
 > 1)
begin


192 
	gone_hot_decoder
 #(
	gNUMBER_OF_WAYS
)

193 
decoder_0
 (
tag_match0
, 
decoded_tag_match0
, 
valid_tag_match0
);

194 
	gone_hot_decoder
 #(
	gNUMBER_OF_WAYS
)

195 
decoder_1
 (
tag_match1
, 
decoded_tag_match1
, 
valid_tag_match1
);

196 
	gone_hot_decoder
 #(
	gNUMBER_OF_WAYS
)

197 
decoder_2
 (
replace_way_encoded
, 
replace_way
, 
valid_replace_way
);

198 
end


199 else 
begin


200 
assign
 
	gdecoded_tag_match0
 = 0;

201 
assign
 
	gvalid_tag_match0
 = 
tag_match0
;

202 
assign
 
	gdecoded_tag_match1
 = 0;

203 
assign
 
	gvalid_tag_match1
 = 
tag_match1
;

204 
assign
 
	greplace_way
 = 0;

205 
assign
 
	gvalid_replace_way
 = 
replace_way_encoded
;

206 
end


207 
endgenerate


210 
generate


211 if(
	gNUMBER_OF_WAYS
 > 1)
	gbegin
: 
REPLACE


212 
replacement_controller
 #(
NUMBER_OF_WAYS
, 
	gINDEX_BITS
)

213 
replace_inst
(
clock
, 
reset
, 
ways_in_use
, 
replace_index
, 
REPLACEMENT_MODE
,

214 
current_access
, 
access_valid
, 
report
, 
replace_way_encoded
);

215 
end
 else

216 
assign
 
	greplace_way_encoded
 = 1;

217 
endgenerate


220 
generate


221 for(
	gi
=0; i<
	gNUMBER_OF_WAYS
; i=
i
+1)
begin
: 
VALID


222 
assign
 
valid_line0
[
i
] = 
status_line0
[i][
STATUS_BITS
-1];

223 
assign
 
	gvalid_line1
[
i
] = 
status_line1
[i][
STATUS_BITS
-1];

224 
end


225 
endgenerate


228 
generate


229 for(
	gi
=0; i<
	gNUMBER_OF_WAYS
; i=
i
+1)
begin
: 
TAG_COMP


230 
assign
 
tag_match0
[
i
] = 
valid_line0
[i] & (
r_tag0
 == 
tag_0
[i]);

231 
assign
 
	gtag_match1
[
i
] = 
valid_line1
[i] & (
r_tag1
 == 
tag_1
[i]);

232 
end


233 
endgenerate


235 
assign
 
	gways_in_use
 = 
valid_line0
;

236 
assign
 
	greplace_index
 = 
index0
;

237 
assign
 
	gcurrent_access
 = 
write0
 ? 
way_select0
 : 
decoded_tag_match0
;

238 
assign
 
	gaccess_valid
 = 
write0
 | (
r_read0
 & 
valid_tag_match0
);

240 
generate


241 for(
	gi
=0; i<
	gNUMBER_OF_WAYS
; i=
i
+1)
begin
: 
W_EN


242 
assign
 
we0_d
[
i
] = ((i == 
way_select0
) & 
write0
 & ~((
index0
 == 
index1
) &

243 (
way_select0
 == 
way_select1
) & 
write1
)) | 
reset
;

244 
assign
 
	gwe1_d
[
i
] = (i == 
way_select1
) & 
write1
;

245 
assign
 
	gwe0_m
[
i
] = 
reset
 | ((i == 
way_select0
) & (
write0
 | 
invalidate0
) &

246 ~((
index0
 == 
index1
) & (
way_select0
 == 
way_select1
) &

247 (
write1
 | 
invalidate1
)));

248 
assign
 
	gwe1_m
[
i
] = (i == 
way_select1
) & (
write1
 | 
invalidate1
);

250 
assign
 
	gdata_in0_m
[
i
] = ((
way_select0
 == i) & (
invalidate0
)) | 
reset
 ?

251 {
MBITS
{1'b0}} : {meta_data0, tag0};

252 
assign
 
data_in1_m
[
i
] = ((
way_select1
 == i) & (
invalidate1
)) | 
reset
 ?

253 {
MBITS
{1'b0}} : {meta_data1, tag1};

254 
end


255 
endgenerate


259 
always
 @(
posedge
 
clock
)
begin


260 if(
reset
)
begin


261 
r_read0
 <= 1'b0;

262 
r_read1
 <= 1'b0;

263 
r_tag0
 <= {
TAG_BITS
{1'b0}};

264 
r_tag1
 <= {
TAG_BITS
{1'b0}};

265 
end


266 else 
begin


267 
r_read0
 <= 
read0
;

268 
	gr_read1
 <= 
read1
;

269 
	gr_tag0
 <= 
tag0
;

270 
	gr_tag1
 <= 
tag1
;

271 
end


272 
end


276 
assign
 
	ghit0
 = 
r_read0
 & 
valid_tag_match0
;

277 
assign
 
	ghit1
 = 
r_read1
 & 
valid_tag_match1
;

279 
assign
 
	gmatched_way0
 = 
valid_tag_match0
 ? 
decoded_tag_match0
 : 
replace_way
;

280 
assign
 
	gmatched_way1
 = 
decoded_tag_match1
;

282 
assign
 
	gdata_out0
 = 
hit0
 ? 
data_out0_d
[
decoded_tag_match0
] :

283 
data_out0_d
[
replace_way
];

284 
assign
 
	gdata_out1
 = 
hit1
 ? 
data_out1_d
[
decoded_tag_match1
] : {
BLOCK_WIDTH
{1'b0}};

286 
assign
 
tag_out0
 = 
hit0
 ? 
tag_0
[
decoded_tag_match0
] : tag_0[
replace_way
];

287 
assign
 
	gtag_out1
 = {
TAG_BITS
{1'b0}};

289 
assign
 
coh_bits0
 = 
hit0
 ? 
cohbits_out0
[
decoded_tag_match0
] :

290 
cohbits_out0
[
replace_way
];

291 
assign
 
	gcoh_bits1
 = 
hit1
 ? 
cohbits_out1
[
decoded_tag_match0
] : 0;

293 
assign
 
	gstatus_bits0
 = 
hit0
 ? 
status_line0
[
decoded_tag_match0
] :

294 
status_line0
[
replace_way
];

295 
assign
 
	gstatus_bits1
 = 
hit1
 ? 
status_line1
[
decoded_tag_match1
] :

296 {
STATUS_BITS
{1'b0}};

298 
endmodule


	@coherence_controller.v

23 
module
 
	gcoherence_controller
 #(

24 
parameter
 
	gMSG_BITS
 = 4,

25 
	gNUM_CACHES
 = 4

27 
clock
, 
	greset
,

28 
	gcache2mem_msg
,

29 
	gmem2controller_msg
,

30 
	gbus_msg
,

31 
	gbus_control
,

32 
	gbus_en
,

33 
	gcurr_master
,

34 
	greq_ready


38 
function
 
integer
 
	glog2
;

39 
input
 
integer
 
	gvalue
;

40 
begin


41 
	gvalue
 = 
value
-1;

42 for(
	glog2
=0; 
	gvalue
>0; log2=
log2
+1)

43 
value
 = value>>1;

44 
end


45 
	gendfunction


52 `
	ginclude
 "./params.h"

55 
localparam
 
	gBUS_PORTS
 = 
NUM_CACHES
 + 1;

56 
localparam
 
	gMEM_PORT
 = 
BUS_PORTS
 - 1;

57 
localparam
 
	gBUS_SIG_WIDTH
 = 
log2
(
BUS_PORTS
);

60 
localparam
 
	gIDLE
 = 3'd0,

61 
WAIT_EN
 = 3'd1,

62 
COHERENCE_OP
 = 3'd2,

63 
WAIT_FOR_MEM
 = 3'd3,

64 
HOLD
 = 3'd4,

65 
END_TRANSACTION
 = 3'd5,

66 
MEM_HOLD
 = 3'd6;

68 
input
 
clock
, 
	greset
;

69 
	ginput
 [(
NUM_CACHES
*
MSG_BITS
)-1:0] 
cache2mem_msg
;

70 
	ginput
 [
MSG_BITS
-1: 0] 
mem2controller_msg
;

71 
	ginput
 [
MSG_BITS
-1: 0] 
bus_msg
;

72 
output
 
	greg
 [
BUS_SIG_WIDTH
-1: 0] 
bus_control
;

73 
output
 
reg
 
	gbus_en
;

74 
output
 
reg
 
	greq_ready
;

75 
	goutput
 [
NUM_CACHES
-1 : 0] 
curr_master
;

79 
genvar
 
	gi
;

80 
integer
 
	gj
;

81 
	greg
 [2:0] 
state
;

82 
	gwire
 [
MSG_BITS
-1: 0] 
w_msg_in
 [
NUM_CACHES
-1:0];

83 
	gwire
 [
NUM_CACHES
-1: 0] 
requests
;

84 
	gwire
 [
log2
(
NUM_CACHES
)-1:0] 
serve_next
;

85 
	gwire
 [
NUM_CACHES
-1: 0] 
tr_en_access
, 
	gtr_coherence_op
, 
	gtr_hold
;

86 
	gwire
 [
log2
(
NUM_CACHES
)-1:0] 
coh_op_cache
;

87 
wire
 
	gcoh_op_valid
;

88 
wire
 
	gnext_valid
 = 1;

90 
	greg
 [
log2
(
NUM_CACHES
)-1:0] 
r_curr_master
;

91 
	greg
 [
log2
(
NUM_CACHES
)-1:0] 
transaction_owner
;

92 
reg
 
	gr_curr_master_valid
;

96 
generate


97 for(
	gi
=0; i<
	gNUM_CACHES
; i=
i
+1)
begin
 : 
MSG_IN


98 
assign
 
w_msg_in
[
i
] = 
cache2mem_msg
 [i*
MSG_BITS
 +: MSG_BITS];

99 
end


100 
endgenerate


104 
	garbiter
 #(.
	$WIDTH
(
NUM_CACHES
))

105 
	`arbitrator
(

106 .
	`clock
(
clock
),

107 .
	`reset
(
reset
),

108 .
	`requests
(
requests
),

109 .
	`grant
(
serve_next
)

113 
one_hot_encoder
 #(.
	$WIDTH
(
NUM_CACHES
))

114 
	`curr_master_encoder
(

115 .
	`in
(
r_curr_master
),

116 .
	`valid_input
(
r_curr_master_valid
),

117 .
	`out
(
curr_master
)

121 
priority_encoder
 #(

122 .
	`WIDTH
(
NUM_CACHES
),

123 .
	`PRIORITY
("LSB")

124 ) 
	`coh_op_encoder
 (

125 .
	`decode
(
tr_coherence_op
),

126 .
	`encode
(
coh_op_cache
),

127 .
	`valid
(
coh_op_valid
)

132 
generate


133 for(
i
=0; i<
NUM_CACHES
; i=i+1)
begin
 : 
REQUESTS


134 
assign
 
requests
[
i
] = (
w_msg_in
[i] == 
R_REQ
) | (w_msg_in[i] == 
WB_REQ
 ) |

135 (
w_msg_in
[
i
] == 
FLUSH
) | (w_msg_in[i] == 
WS_BCAST
) |

136 (
w_msg_in
[
i
] == 
FLUSH_S
 ) | (w_msg_in[i] == 
RFO_BCAST
);

137 
end


138 
endgenerate


141 
generate


142 for(
i
=0; i<
NUM_CACHES
; i=i+1)
begin
 : 
TR_COH_MSGS


143 
assign
 
tr_coherence_op
[
i
] = (
w_msg_in
[i] == 
C_WB
) |

144 (
w_msg_in
[
i
] == 
C_FLUSH
) ;

145 
assign
 
tr_en_access
[
i
] = (
w_msg_in
[i] == 
EN_ACCESS
) |

146 ((
i
 == 
transaction_owner
) & (
bus_msg
 != 
REQ_FLUSH
));

147 
end


148 
endgenerate


153 
always
 @(
posedge
 
clock
)
begin


154 if(
reset
)
begin


155 
bus_control
 <= {
BUS_SIG_WIDTH
{1'b0}};

156 
r_curr_master
 <= {(
	`log2
(
NUM_CACHES
)){1'b0}};

157 
transaction_owner
 <= {(
	`log2
(
NUM_CACHES
)){1'b0}};

158 
r_curr_master_valid
 <= 1'b0;

159 
bus_en
 <= 1'b0;

160 
req_ready
 <= 1'b0;

161 
state
 <= 
IDLE
;

162 
end


163 else 
begin


164 case(
state
)

165 
IDLE
:
begin


166 if(|
requests
 & 
next_valid
)
begin


167 
bus_control
 <= 
serve_next
;

168 
r_curr_master
 <= 
serve_next
;

169 
transaction_owner
 <= 
serve_next
;

170 
r_curr_master_valid
 <= 1'b1;

171 
bus_en
 <= 1'b1;

172 if((
w_msg_in
[
serve_next
] == 
WB_REQ
) | (w_msg_in[serve_next] == 
FLUSH
))

173 
begin


174 
req_ready
 <= 1'b1;

175 
state
 <= 
WAIT_FOR_MEM
;

176 
end


178 
state
 <= 
WAIT_EN
;

179 
end


180 else 
begin


181 
state
 <= 
IDLE
;

182 
end


183 
end


184 
WAIT_EN
:
begin


185 if(&
tr_en_access
)
begin


186 if(
bus_msg
 == 
WS_BCAST
)
begin


187 
bus_control
 <= {
BUS_SIG_WIDTH
{1'b0}};

188 
bus_en
 <= 1'b0;

189 
req_ready
 <= 1'b1;

190 
state
 <= 
END_TRANSACTION
;

191 
end


192 else if(
bus_msg
 == 
REQ_FLUSH
)
begin


193 
bus_control
 <= {
BUS_SIG_WIDTH
{1'b0}};

194 
bus_en
 <= 1'b0;

195 
req_ready
 <= 1'b1;

196 
r_curr_master
 <= 
transaction_owner
;

197 
r_curr_master_valid
 <= 1'b1;

198 
state
 <= 
WAIT_FOR_MEM
;

199 
end


200 else 
begin


201 
bus_control
 <= 
transaction_owner
;

202 
bus_en
 <= 1'b1;

203 
req_ready
 <= 1'b1;

204 
r_curr_master
 <= 
transaction_owner
;

205 
r_curr_master_valid
 <= 1'b1;

206 
state
 <= 
WAIT_FOR_MEM
;

207 
end


208 
end


209 else if(
coh_op_valid
)
begin


210 
bus_control
 <= 
coh_op_cache
;

211 
bus_en
 <= 1'b1;

212 
r_curr_master
 <= 
coh_op_cache
;

213 
r_curr_master_valid
 <= 1'b1;

214 
state
 <= 
COHERENCE_OP
;

215 
end


216 else if(
bus_msg
 == 
NO_REQ
)
begin


217 
bus_control
 <= {
BUS_SIG_WIDTH
{1'b0}};

218 
bus_en
 <= 1'b0;

219 
req_ready
 <= 1'b0;

220 
r_curr_master
 <= {
BUS_SIG_WIDTH
{1'b0}};

221 
r_curr_master_valid
 <= 1'b0;

222 
state
 <= 
IDLE
;

223 
end


224 else 
begin


225 
state
 <= 
WAIT_EN
;

226 
end


227 
end


228 
WAIT_FOR_MEM
:
begin


229 if(
mem2controller_msg
 == 
REQ_FLUSH
)
begin


230 
bus_control
 <= 
MEM_PORT
;

231 
bus_en
 <= 1'b1;

232 
r_curr_master
 <= 0;

233 
r_curr_master_valid
 <= 1'b0;

234 
req_ready
 <= 1'b0;

235 
state
 <= 
WAIT_EN
;

236 
end


237 else if((
mem2controller_msg
 == 
MEM_RESP
) | (mem2controller_msg ==

238 
MEM_RESP_S
) | (
mem2controller_msg
 == 
MEM_C_RESP
))
begin


239 
bus_control
 <= 
MEM_PORT
;

240 
bus_en
 <= 1'b1;

241 
r_curr_master
 <= 
transaction_owner
;

242 
r_curr_master_valid
 <= 1'b1;

243 
req_ready
 <= 1'b0;

244 
state
 <= 
END_TRANSACTION
;

245 
end


246 else if(
mem2controller_msg
 == 
HOLD_BUS
)
begin


247 
bus_control
 <= 
MEM_PORT
;

248 
bus_en
 <= 1'b1;

249 
r_curr_master
 <= 
MEM_PORT
;

250 
r_curr_master_valid
 <= 1'b1;

251 
req_ready
 <= 1'b0;

252 
state
 <= 
MEM_HOLD
;

253 
end


254 else 
begin


255 
state
 <= 
WAIT_FOR_MEM
;

256 
end


257 
end


258 
END_TRANSACTION
:
begin


259 if(
w_msg_in
[
r_curr_master
] == 
EN_ACCESS
)
begin


260 
bus_control
 <= {
BUS_SIG_WIDTH
{1'b0}};

261 
bus_en
 <= 1'b0;

262 
r_curr_master
 <= 
transaction_owner
;

263 
r_curr_master_valid
 <= 1'b1;

264 
state
 <= 
WAIT_EN
;

265 
end


266 else if(
w_msg_in
[
r_curr_master
] == 
HOLD_BUS
)
begin


267 
bus_control
 <= 
r_curr_master
;

268 
bus_en
 <= 1'b1;

269 
state
 <= 
HOLD
;

270 
end


271 else if(
w_msg_in
[
r_curr_master
] == 
NO_REQ
)
begin


272 
bus_control
 <= {
BUS_SIG_WIDTH
{1'b0}};

273 
bus_en
 <= 1'b0;

274 
req_ready
 <= 1'b0;

275 
r_curr_master
 <= {(
	`log2
(
NUM_CACHES
)){1'b0}};

276 
r_curr_master_valid
 <= 1'b0;

277 
state
 <= 
IDLE
;

278 
end


279 else 
begin


280 
state
 <= 
END_TRANSACTION
;

281 
end


282 
end


283 
COHERENCE_OP
:
begin


284 if(
mem2controller_msg
 == 
MEM_C_RESP
)
begin


285 
bus_control
 <= 
MEM_PORT
;

286 
bus_en
 <= 1'b1;

287 
state
 <= 
END_TRANSACTION
;

288 
end


289 
end


290 
HOLD
:
begin


291 if(
w_msg_in
[
r_curr_master
] == 
EN_ACCESS
)
begin


292 
bus_control
 <= {
BUS_SIG_WIDTH
{1'b0}};

293 
bus_en
 <= 1'b0;

294 
r_curr_master
 <= 
transaction_owner
;

295 
r_curr_master_valid
 <= 1'b1;

296 
state
 <= 
WAIT_EN
;

297 
end


298 else if((
w_msg_in
[
r_curr_master
] == 
C_WB
) | (w_msg_in[r_curr_master] ==

299 
C_FLUSH
))
begin


300 
bus_control
 <= 
r_curr_master
;

301 
bus_en
 <= 1'b1;

302 
r_curr_master_valid
 <= 1'b1;

303 
state
 <= 
COHERENCE_OP
;

304 
end


305 
end


306 
MEM_HOLD
:
begin


307 if(
mem2controller_msg
 == 
NO_REQ
)
begin


308 
bus_control
 <= 
transaction_owner
;

309 
bus_en
 <= 1'b1;

310 
req_ready
 <= 1'b0;

311 
r_curr_master
 <= 
transaction_owner
;

312 
r_curr_master_valid
 <= 1'b1;

313 
state
 <= 
WAIT_EN
;

314 
end


316 
state
 <= 
MEM_HOLD
;

317 
end


318 default:
begin


319 
state
 <= 
IDLE
;

320 
end


321 
endcase


322 
end


323 
end


325 
endmodule


	@control_unit.v

24 
module
 
	gcontrol_unit
 #(

25 
parameter
 
	gCORE
 = 0,

26 
parameter
 
	gADDRESS_BITS
 = 20,

27 
parameter
 
	gNUM_BYTES
 = 32/8,

28 
parameter
 
	gLOG2_NUM_BYTES
 = 
log2
(
NUM_BYTES
),

29 
parameter
 
	gSCAN_CYCLES_MIN
 = 0,

30 
parameter
 
	gSCAN_CYCLES_MAX
 = 1000

32 
input
 
clock
,

33 
input
 
	greset
,

34 
	ginput
 [6:0] 
opcode_decode
,

35 
	ginput
 [6:0] 
opcode_execute
,

36 
	ginput
 [2:0] 
funct3
,

37 
	ginput
 [6:0] 
funct7
,

39 
	ginput
 [
ADDRESS_BITS
-1:0] 
JALR_target_execute
,

40 
	ginput
 [
ADDRESS_BITS
-1:0] 
branch_target_execute
,

41 
	ginput
 [
ADDRESS_BITS
-1:0] 
JAL_target_decode
,

42 
input
 
	gbranch_execute
,

44 
input
 
	gtrue_data_hazard
,

45 
input
 
	gd_mem_hazard
,

46 
input
 
	gi_mem_hazard
,

47 
input
 
	gJALR_branch_hazard
,

48 
input
 
	gJAL_hazard
,

50 
output
 
	gbranch_op
,

51 
output
 
	gmemRead
,

52 
	goutput
 [5:0] 
ALU_operation
,

53 
output
 
	gmemWrite
,

54 
	goutput
 [
LOG2_NUM_BYTES
-1:0] 
log2_bytes
,

55 
output
 
	gunsigned_load
,

56 
	goutput
 [1:0] 
next_PC_sel
,

57 
	goutput
 [1:0] 
operand_A_sel
,

58 
output
 
	goperand_B_sel
,

59 
	goutput
 [1:0] 
extend_sel
,

60 
output
 
	gregWrite
,

62 
	goutput
 [
ADDRESS_BITS
-1:0] 
target_PC
,

63 
output
 
	gi_mem_read
,

65 
input
 
	gscan


69 
function
 
integer
 
	glog2
;

70 
input
 
integer
 
	gvalue
;

71 
begin


72 
	gvalue
 = 
value
-1;

73 for (
	glog2
=0; 
	gvalue
>0; log2=
log2
+1)

74 
value
 = value >> 1;

75 
end


76 
endfunction


79 
	glocalparam
 [6:0]
R_TYPE
 = 7'b0110011,

80 
I_TYPE
 = 7'b0010011,

81 
STORE
 = 7'b0100011,

82 
LOAD
 = 7'b0000011,

83 
BRANCH
 = 7'b1100011,

84 
JALR
 = 7'b1100111,

85 
JAL
 = 7'b1101111,

86 
AUIPC
 = 7'b0010111,

87 
LUI
 = 7'b0110111,

88 
FENCES
 = 7'b0001111,

89 
SYSCALL
 = 7'b1110011;

92 
assign
 
regWrite
 = (
opcode_decode
 == 
R_TYPE
) | (opcode_decode == 
I_TYPE
) | (opcode_decode == 
LOAD
)

93 | (
opcode_decode
 == 
JALR
) | (opcode_decode == 
JAL
) | (opcode_decode == 
AUIPC
)

94 | (
opcode_decode
 == 
LUI
);

96 
assign
 
	gmemWrite
 = (
opcode_decode
 == 
STORE
);

97 
assign
 
	gbranch_op
 = (
opcode_decode
 == 
BRANCH
);

98 
assign
 
	gmemRead
 = (
opcode_decode
 == 
LOAD
);

101 
assign
 
	glog2_bytes
 = (
opcode_decode
 == 
LOAD
 & 
funct3
 == 3'b000) ? 0 : // LB

102 (
opcode_decode
 == 
LOAD
 & 
funct3
 == 3'b001) ? 1 : // LH

103 (
opcode_decode
 == 
LOAD
 & 
funct3
 == 3'b010) ? 2 : // LW

104 (
opcode_decode
 == 
LOAD
 & 
funct3
 == 3'b100) ? 0 : // LBU

105 (
opcode_decode
 == 
LOAD
 & 
funct3
 == 3'b101) ? 1 : // LHU

106 (
opcode_decode
 == 
STORE
 & 
funct3
 == 3'b000) ? 0 : // SB

107 (
opcode_decode
 == 
STORE
 & 
funct3
 == 3'b001) ? 1 : // SH

108 (
opcode_decode
 == 
STORE
 & 
funct3
 == 3'b010) ? 2 : // SW

109 {
LOG2_NUM_BYTES
{1'b0}};

111 
assign
 
unsigned_load
 = (
opcode_decode
 == 
LOAD
 & 
funct3
 == 3'b100) | // LBU

112 (
opcode_decode
 == 
LOAD
 & 
funct3
 == 3'b101); // LHU

125 
assign
 
ALU_operation
 =

126 (
opcode_decode
 == 
JAL
) ? 6'd1 : // JAL: Pass through

127 (
opcode_decode
 == 
JALR
 & 
funct3
 == 3'b000) ? 6'
d1
 :

128 (
opcode_decode
 == 
BRANCH
 & 
funct3
 == 3'b000) ? 6'
d2
 :

129 (
opcode_decode
 == 
BRANCH
 & 
funct3
 == 3'b001) ? 6'
d3
 :

130 (
opcode_decode
 == 
BRANCH
 & 
funct3
 == 3'b100) ? 6'
d4
 :

131 (
opcode_decode
 == 
BRANCH
 & 
funct3
 == 3'b101) ? 6'
d5
 :

132 (
opcode_decode
 == 
BRANCH
 & 
funct3
 == 3'b110) ? 6'
d6
 :

133 (
opcode_decode
 == 
BRANCH
 & 
funct3
 == 3'b111) ? 6'
d7
 :

134 (
opcode_decode
 == 
I_TYPE
 & 
funct3
 == 3'b010) ? 6'
d4
 :

135 (
opcode_decode
 == 
I_TYPE
 & 
funct3
 == 3'b011) ? 6'
d6
 :

136 (
opcode_decode
 == 
I_TYPE
 & 
funct3
 == 3'b100) ? 6'
d8
 :

137 (
opcode_decode
 == 
I_TYPE
 & 
funct3
 == 3'b110) ? 6'
d9
 :

138 (
opcode_decode
 == 
I_TYPE
 & 
funct3
 == 3'b111) ? 6'
d10
 :

139 (
opcode_decode
 == 
I_TYPE
 & 
funct3
 == 3'b001 & funct7 == 7'
b0000000
) ? 6'd11 : // SLLI: logical left shift

140 (
opcode_decode
 == 
I_TYPE
 & 
funct3
 == 3'b101 & funct7 == 7'
b0000000
) ? 6'd12 : // SRLI: logical right shift

141 (
opcode_decode
 == 
I_TYPE
 & 
funct3
 == 3'b101 & funct7 == 7'
b0100000
) ? 6'd13 : // SRAI: arithemtic right shift

142 (
opcode_decode
 == 
R_TYPE
 & 
funct3
 == 3'b000 & funct7 == 7'
b0100000
) ? 6'd14 : // SUB: subtract

143 (
opcode_decode
 == 
R_TYPE
 & 
funct3
 == 3'b001 & funct7 == 7'
b0000000
) ? 6'd11 : // SLL: logical left shift

144 (
opcode_decode
 == 
R_TYPE
 & 
funct3
 == 3'b010 & funct7 == 7'
b0000000
) ? 6'd4 : // SLT: signed less than

145 (
opcode_decode
 == 
R_TYPE
 & 
funct3
 == 3'b011 & funct7 == 7'
b0000000
) ? 6'd6 : // SLTU: signed less than

146 (
opcode_decode
 == 
R_TYPE
 & 
funct3
 == 3'b100 & funct7 == 7'
b0000000
) ? 6'd8 : // XOR: xor

147 (
opcode_decode
 == 
R_TYPE
 & 
funct3
 == 3'b101 & funct7 == 7'
b0000000
) ? 6'd12 : // SRL: logical right shift

148 (
opcode_decode
 == 
R_TYPE
 & 
funct3
 == 3'b101 & funct7 == 7'
b0100000
) ? 6'd13 : // SRA: arithmetic right shift

149 (
opcode_decode
 == 
R_TYPE
 & 
funct3
 == 3'b110 & funct7 == 7'
b0000000
) ? 6'd9 : // OR: or

150 (
opcode_decode
 == 
R_TYPE
 & 
funct3
 == 3'b111 & funct7 == 7'
b0000000
) ? 6'd10 : // AND: and

153 
assign
 
operand_A_sel
 = (
opcode_decode
 == 
AUIPC
) ? 2'b01 :

154 (
opcode_decode
 == 
LUI
) ? 2'b11 :

155 ((
opcode_decode
 == 
JALR
) | (opcode_decode == 
JAL
)) ? 2'b10 : 2'
b00
;

157 
assign
 
	goperand_B_sel
 = (
opcode_decode
 == 
I_TYPE
) | (opcode_decode == 
STORE
) |

158 (
opcode_decode
 == 
LOAD
) | (opcode_decode == 
AUIPC
) |

159 (
opcode_decode
 == 
LUI
);

161 
assign
 
	gextend_sel
 = ((
opcode_decode
 == 
I_TYPE
) | (opcode_decode == 
LOAD
)) ? 2'b00 :

162 (
opcode_decode
 == 
STORE
) ? 2'b01 :

163 ((
opcode_decode
 == 
AUIPC
) | (opcode_decode == 
LUI
)) ? 2'b10 : 2'
b00
;

165 
assign
 
	gtarget_PC
 = (
opcode_execute
 == 
JALR
) ? 
JALR_target_execute
 :

166 (
opcode_execute
 == 
BRANCH
) & 
branch_execute
 ? 
branch_target_execute
 :

167 (
opcode_decode
 == 
JAL
) ? 
JAL_target_decode
 :

168 {
ADDRESS_BITS
{1'b0}};

170 
assign
 
next_PC_sel
 = 
JALR_branch_hazard
 ? 2'b10 : // target_PC

171 
true_data_hazard
 ? 2'b01 : // stall

172 
JAL_hazard
 ? 2'b10 : // targeet_PC

173 
i_mem_hazard
 ? 2'b01 : // stall

174 
d_mem_hazard
 ? 2'b01 : // stall

177 
assign
 
i_mem_read
 = 1'b1;

179 
reg
 [31: 0] 
cycles
;

180 
	galways
 @ (
posedge
 
	gclock
) 
begin


181 
	gcycles
 <= 
reset
? 0 : 
cycles
 + 1;

182 if (
	gscan
 & ((
	gcycles
 >= 
SCAN_CYCLES_MIN
) & (
cycles
 <= 
SCAN_CYCLES_MAX
)) )
begin


183 
$display
 ("------ Core %d Control Unit - Current Cycle %d ------", 
CORE
, 
cycles
);

184 
$display
 ("| Opcode decode [%b]", 
opcode_decode
);

185 
$display
 ("| Opcode execute [%b]", 
opcode_execute
);

186 
$display
 ("| Branch_op [%b]", 
branch_op
);

187 
$display
 ("| memRead [%b]", 
memRead
);

188 
$display
 ("| memWrite [%b]", 
memWrite
);

189 
$display
 ("| RegWrite [%b]", 
regWrite
);

190 
$display
 ("| log2_bytes [%b]", 
log2_bytes
);

191 
$display
 ("| unsigned_load [%b]", 
unsigned_load
);

192 
$display
 ("| ALU_operation [%b]", 
ALU_operation
);

193 
$display
 ("| Extend_sel [%b]", 
extend_sel
);

194 
$display
 ("| ALUSrc_A [%b]", 
operand_A_sel
);

195 
$display
 ("| ALUSrc_B [%b]", 
operand_B_sel
);

196 
$display
 ("| Next PC sel [%b]", 
next_PC_sel
);

197 
$display
 ("| Target PC [%h]", 
target_PC
);

198 
$display
 ("----------------------------------------------------------------------");

199 
end


200 
end


201 
	gendmodule


	@decode_unit.v

24 
module
 
	gdecode_unit
 #(

25 
parameter
 
	gCORE
 = 0,

26 
parameter
 
	gADDRESS_BITS
 = 20,

27 
parameter
 
	gSCAN_CYCLES_MIN
 = 0,

28 
parameter
 
	gSCAN_CYCLES_MAX
 = 1000

30 
input
 
clock
,

31 
input
 
	greset
,

33 
	ginput
 [
ADDRESS_BITS
-1:0] 
PC
,

34 
	ginput
 [31:0] 
instruction
,

35 
	ginput
 [1:0] 
extend_sel
,

36 
input
 
	gwrite
,

37 
	ginput
 [4:0] 
write_reg
,

38 
	ginput
 [31:0] 
write_data
,

40 
	goutput
 [31:0] 
rs1_data
,

41 
	goutput
 [31:0] 
rs2_data
,

42 
	goutput
 [4:0] 
rd
,

43 
	goutput
 [6:0] 
opcode
,

44 
	goutput
 [6:0] 
funct7
,

45 
	goutput
 [2:0] 
funct3
,

46 
	goutput
 [31:0] 
extend_imm
,

47 
	goutput
 [
ADDRESS_BITS
-1:0] 
branch_target
,

48 
	goutput
 [
ADDRESS_BITS
-1:0] 
JAL_target
,

50 
input
 
	gscan


54 
	gwire
[4:0] 
rs2
;

55 
	gwire
[4:0] 
rs1
;

58 
	gwire
[6:0] 
s_imm_msb
;

59 
	gwire
[4:0] 
s_imm_lsb
;

60 
	gwire
[19:0] 
u_imm
;

61 
	gwire
[11:0] 
i_imm_orig
;

62 
	gwire
[19:0] 
uj_imm
;

63 
	gwire
[11:0] 
s_imm_orig
;

64 
	gwire
[12:0] 
sb_imm_orig
;

66 
	gwire
[31:0] 
sb_imm_32
;

67 
	gwire
[31:0] 
u_imm_32
;

68 
	gwire
[31:0] 
i_imm_32
;

69 
	gwire
[31:0] 
s_imm_32
;

70 
	gwire
[31:0] 
uj_imm_32
;

73 
assign
 
	grs2
 = 
instruction
[24:20];

74 
assign
 
	grs1
 = 
instruction
[19:15];

77 
assign
 
	gs_imm_msb
 = 
instruction
[31:25];

78 
assign
 
	gs_imm_lsb
 = 
instruction
[11:7];

79 
assign
 
	gu_imm
 = 
instruction
[31:12];

80 
assign
 
	gi_imm_orig
 = 
instruction
[31:20];

81 
assign
 
	guj_imm
 = {
instruction
[31],instruction[19:12],instruction[20],instruction[30:21]};

84 
assign
 
	gs_imm_orig
 = {
s_imm_msb
,
s_imm_lsb
};

85 
assign
 
	gsb_imm_orig
 = {
s_imm_msb
[6],
s_imm_lsb
[0],s_imm_msb[5:0],s_imm_lsb[4:1],1'b0};

89 
assign
 
opcode
 = 
instruction
[6:0];

90 
assign
 
	gfunct7
 = 
instruction
[31:25];

91 
assign
 
	gfunct3
 = 
instruction
[14:12];

94 
assign
 
	grd
 = 
instruction
[11:7];

97 
assign
 
	gsb_imm_32
 = {{19{
sb_imm_orig
[12]}}, sb_imm_orig};

98 
assign
 
	gbranch_target
 = 
PC
 + 
sb_imm_32
;

101 
assign
 
	gu_imm_32
 = {
u_imm
,12'b0};

102 
assign
 
i_imm_32
 = {{20{
i_imm_orig
[11]}}, i_imm_orig[11:0] };

103 
assign
 
	gs_imm_32
 = {{20{
s_imm_orig
[11]}}, s_imm_orig};

105 
assign
 
	gextend_imm
 = (
extend_sel
 == 2'b01)? s_imm_32 :

106 (
extend_sel
 == 2'b10)? u_imm_32 : i_imm_32;

109 
assign
 
uj_imm_32
 = {{11{
uj_imm
[19]}},uj_imm[19:0],1'b0};

110 
assign
 
JAL_target
 = 
uj_imm_32
 + 
PC
;

112 
	gregFile
 #(

113 .
REG_DATA_WIDTH
(32),

114 .
REG_SEL_BITS
(5)

115 ) 
registers
 (

116 .
clock
(clock),

117 .
reset
(reset),

118 .
read_sel1
(
rs1
),

119 .
read_sel2
(
rs2
),

120 .
wEn
(
write
),

121 .
write_sel
(
write_reg
),

122 .
write_data
(write_data),

123 .
read_data1
(
rs1_data
),

124 .
read_data2
(
rs2_data
)

127 
	greg
 [31: 0] 
cycles
;

128 
	galways
 @ (
posedge
 
	gclock
) 
begin


129 
	gcycles
 <= 
reset
? 0 : 
cycles
 + 1;

130 if (
	gscan
 & ((
	gcycles
 >= 
SCAN_CYCLES_MIN
) & (
cycles
 <= 
SCAN_CYCLES_MAX
)) )
begin


131 
$display
 ("------ Core %d Decode Unit - Current Cycle %d -------", 
CORE
, 
cycles
);

132 
$display
 ("| PC [%h]", 
PC
);

133 
$display
 ("| Instruction [%h]", 
instruction
);

134 
$display
 ("| rs1 [%d]", 
rs1
);

135 
$display
 ("| rs1_data [%d]", 
rs1_data
);

136 
$display
 ("| rs2 [%d]", 
rs2
);

137 
$display
 ("| rs2_data [%d]", 
rs2_data
);

138 
$display
 ("| rsd [%d]", 
rd
);

139 
$display
 ("| jumpTarget [%h]", 
JAL_target
);

140 
$display
 ("| branchTarget[%h]", 
branch_target
);

141 
$display
 ("| Opcode [%b] Funct3 [%b] Funct7 [%b]", 
opcode
, 
funct3
, 
funct7
);

142 
$display
 ("| Immediate [%d] Hex [%h] Bin [%b]", 
extend_imm
, extend_imm, extend_imm[7:0]);

143 
$display
 ("| write [%b]", 
write
);

144 
$display
 ("| write_reg [%d]", 
write_reg
);

145 
$display
 ("| write_data [%d]", 
write_data
);

146 
$display
 ("----------------------------------------------------------------------");

147 
end


148 
end


150 
	gendmodule


	@dual_port_ram.v

23 
module
 
	gdual_port_ram


25 
parameter


26 
	gDATA_WIDTH
 = 32,

27 
	gADDRESS_WIDTH
 = 32,

28 
	gINDEX_BITS
 = 6

31 
input
 
clock
,

32 
input
 
	gwe0
, 
	gwe1
,

33 
	ginput
 [
DATA_WIDTH
-1:0] 
data_in0
,

34 
	ginput
 [
DATA_WIDTH
-1:0] 
data_in1
,

35 
	ginput
 [
ADDRESS_WIDTH
-1:0] 
address0
,

36 
	ginput
 [
ADDRESS_WIDTH
-1:0] 
address1
,

37 
output
 
	greg
 [
DATA_WIDTH
-1:0] 
data_out0
,

38 
output
 
	greg
 [
DATA_WIDTH
-1:0] 
data_out1


41 
localparam
 
	gRAM_DEPTH
 = 1 << 
INDEX_BITS
;

43 
	greg
 [
DATA_WIDTH
-1:0] 
mem
 [0:
RAM_DEPTH
-1];

45 
wire
 
	gport0_we
;

47 
assign
 
	gport0_we
 = 
we0
 & ~(
we1
 & (
address0
 == 
address1
));

50 
	galways
@(
posedge
 
	gclock
)
begin


51 if(
	gport0_we
) 
begin


52 
	gmem
[
address0
] <= 
data_in0
;

53 
	gdata_out0
 <= 
data_in0
;

54 
end


55 else 
begin


56 
	gdata_out0
 <= 
mem
[
address0
];

57 
end


58 
end


61 
	galways
@(
posedge
 
	gclock
)
begin


62 if(
	gwe1
) 
begin


63 
	gmem
[
address1
] <= 
data_in1
;

64 
	gdata_out1
 <= 
data_in1
;

65 
end


66 else 
begin


67 
	gdata_out1
 <= 
mem
[
address1
];

68 
end


69 
end


72 
	gendmodule


	@dual_port_ram_with_pass_through.v

23 
module
 
	gdual_port_ram_with_pass_through
 #(

24 
parameter
 
	gDATA_WIDTH
 = 32,

25 
	gADDRESS_WIDTH
 = 32,

26 
	gINDEX_BITS
 = 6,

27 
	gRW
 = "OLD_DATA"

30 
input
 
clock
,

31 
input
 
	gwe0
, 
	gwe1
,

32 
	ginput
 [
DATA_WIDTH
-1:0] 
data_in0
,

33 
	ginput
 [
DATA_WIDTH
-1:0] 
data_in1
,

34 
	ginput
 [
ADDRESS_WIDTH
-1:0] 
address0
,

35 
	ginput
 [
ADDRESS_WIDTH
-1:0] 
address1
,

36 
	goutput
 [
DATA_WIDTH
-1:0] 
data_out0
,

37 
	goutput
 [
DATA_WIDTH
-1:0] 
data_out1


40 
reg
 
	gr_we0
, 
	gr_we1
;

41 
	greg
 [
ADDRESS_WIDTH
-1:0] 
r_address0
, 
	gr_address1
;

43 
	gwire
 [
DATA_WIDTH
-1:0] 
t_data_out0
, 
	gt_data_out1
;

45 
	galways
 @(
posedge
 
	gclock
)
begin


46 
	gr_address0
 <= 
address0
;

47 
	gr_address1
 <= 
address1
;

48 
	gr_we0
 <= 
we0
;

49 
	gr_we1
 <= 
we1
;

50 
end


53 
	gdual_port_ram
 #(

54 .
DATA_WIDTH
(DATA_WIDTH),

55 .
ADDRESS_WIDTH
(ADDRESS_WIDTH),

56 .
	$INDEX_BITS
(
INDEX_BITS
)

57 ) 
	`RAM
 (

58 .
	`clock
(
clock
),

59 .
	`we0
(
we0
),

60 .
	`we1
(
we1
),

61 .
	`data_in0
(
data_in0
),

62 .
	`data_in1
(
data_in1
),

63 .
	`address0
(
address0
),

64 .
	`address1
(
address1
),

65 .
	`data_out0
(
t_data_out0
),

66 .
	`data_out1
(
t_data_out1
)

70 
assign
 
data_out0
 = 
r_we1
 & (
r_address1
 == 
r_address0
) & (
RW
 == "NEW_DATA") ?

71 
t_data_out1
 : 
t_data_out0
;

72 
assign
 
data_out1
 = 
r_we0
 & (
r_address0
 == 
r_address1
) & (
RW
 == "NEW_DATA") ?

73 
t_data_out0
 : 
t_data_out1
;

75 
endmodule


	@empty_way_select.v

23 
module
 
	gempty_way_select
 #(

24 
parameter
 
	gNUMBER_OF_WAYS
 = 4

26 
ways_in_use
,

27 
	gnext_empty_way
,

28 
	gvalid


32 
function
 
integer
 
	glog2
;

33 
input
 
integer
 
	gvalue
;

34 
begin


35 
	gvalue
 = 
value
-1;

36 for(
	glog2
=0; 
	gvalue
>0; log2=
log2
+1)

37 
value
 = value>>1;

38 
end


39 
endfunction


42 
	ginput
 [
NUMBER_OF_WAYS
-1:0] 
ways_in_use
;

43 
	goutput
 [
NUMBER_OF_WAYS
-1:0] 
next_empty_way
;

44 
output
 
	gvalid
;

46 
	gwire
 [
NUMBER_OF_WAYS
-1:0] 
invert
, 
	gplusone
;

48 
assign
 
	ginvert
 = ~
ways_in_use
;

49 
assign
 
	gplusone
 = 
ways_in_use
 + 1;

50 
assign
 
	gnext_empty_way
 = 
invert
 & 
plusone
;

51 
assign
 
	gvalid
 = |
invert
;

53 
	gendmodule


	@execution_unit.v

24 
module
 
	gexecution_unit
 #(

25 
parameter
 
	gCORE
 = 0,

26 
parameter
 
	gDATA_WIDTH
 = 32,

27 
parameter
 
	gADDRESS_BITS
 = 20,

28 
parameter
 
	gSCAN_CYCLES_MIN
 = 0,

29 
parameter
 
	gSCAN_CYCLES_MAX
 = 1000

31 
input
 
clock
,

32 
input
 
	greset
,

33 
	ginput
 [5:0] 
ALU_operation
,

34 
	ginput
 [
ADDRESS_BITS
-1:0] 
PC
,

35 
	ginput
 [1:0] 
operand_A_sel
,

36 
input
 
	goperand_B_sel
,

37 
input
 
	gbranch_op
,

38 
	ginput
 [
DATA_WIDTH
-1:0] 
rs1_data
,

39 
	ginput
 [
DATA_WIDTH
-1:0] 
rs2_data
,

40 
	ginput
 [
DATA_WIDTH
-1:0] 
extend
,

42 
output
 
	gbranch
,

43 
	goutput
 [
DATA_WIDTH
-1:0] 
ALU_result
,

44 
	goutput
 [
ADDRESS_BITS
-1:0] 
JALR_target
,

46 
input
 
	gscan


50 
	gwire
 [
DATA_WIDTH
-1:0] 
operand_A
;

51 
	gwire
 [
DATA_WIDTH
-1:0] 
operand_B
;

53 
assign
 
	goperand_A
 = (
operand_A_sel
 == 2'b01) ? PC :

54 (
operand_A_sel
 == 2'b10) ? (PC + 4) :

55 (
operand_A_sel
 == 2'b11) ? 0 :

56 
rs1_data
;

58 
assign
 
	goperand_B
 = 
operand_B_sel
 ? 
extend
 : 
rs2_data
;

60 
assign
 
	gbranch
 = (
ALU_result
 == {{
DATA_WIDTH
-1{1'b0}}, 1'
b1
} & 
branch_op
);

63 
assign
 
	gJALR_target
 = {
rs1_data
 + 
extend
} & 32'hffff_fffe;

65 
ALU
 #(

66 .
DATA_WIDTH
(DATA_WIDTH)

67 ) 
EU
 (

68 .
ALU_operation
(ALU_operation),

69 .
operand_A
(operand_A),

70 .
operand_B
(operand_B),

71 .
ALU_result
(ALU_result)

74 
	greg
 [31: 0] 
cycles
;

75 
	galways
 @ (
posedge
 
	gclock
) 
begin


76 
	gcycles
 <= 
reset
? 0 : 
cycles
 + 1;

77 if (
	gscan
 & ((
	gcycles
 >= 
SCAN_CYCLES_MIN
) & (
cycles
 <= 
SCAN_CYCLES_MAX
)) )
begin


78 
$display
 ("------ Core %d Execute Unit - Current Cycle %d ------", 
CORE
, 
cycles
);

79 
$display
 ("| ALU_Operation [%b]", 
ALU_operation
);

80 
$display
 ("| operand_A [%h]", 
operand_A
);

81 
$display
 ("| operand_B [%h]", 
operand_B
);

82 
$display
 ("| Branch [%b]", 
branch
);

83 
$display
 ("| ALU_result [%h]", 
ALU_result
);

84 
$display
 ("| JALR_taget [%h]", 
JALR_target
);

85 
$display
 ("----------------------------------------------------------------------");

86 
end


87 
end


89 
	gendmodule


	@fetch_issue.v

23 
module
 
	gfetch_issue
 #(

24 
parameter
 
	gCORE
 = 0,

25 
parameter
 
	gRESET_PC
 = 0,

26 
parameter
 
	gADDRESS_BITS
 = 20,

27 
parameter
 
	gSCAN_CYCLES_MIN
 = 1,

28 
parameter
 
	gSCAN_CYCLES_MAX
 = 1000

30 
input
 
clock
,

31 
input
 
	greset
,

33 
	ginput
 [1:0] 
next_PC_select
,

34 
	ginput
 [
ADDRESS_BITS
-1:0] 
target_PC
,

36 
	goutput
 [
ADDRESS_BITS
-1:0] 
issue_PC
,

38 
	goutput
 [
ADDRESS_BITS
-1:0] 
i_mem_read_address
,

40 
input
 
	gscan


43 
	greg
 [
ADDRESS_BITS
-1:0] 
PC_reg
;

46 
assign
 
	gissue_PC
 = 
PC_reg
;

47 
assign
 
	gi_mem_read_address
 = 
PC_reg
;

50 
	galways
 @(
posedge
 
	gclock
)
begin


51 if(
	greset
)
begin


52 
	gPC_reg
 <= 
RESET_PC
;

53 
end


54 else 
begin


55 case(
	gnext_PC_select
)

59 default: 
PC_reg
 <= {
ADDRESS_BITS
{1'b0}};

60 
endcase


61 
end


62 
end


64 
endmodule


	@fetch_receive.v

23 
module
 
	gfetch_receive
 #(

24 
parameter
 
	gDATA_WIDTH
 = 32,

25 
parameter
 
	gSCAN_CYCLES_MIN
 = 0,

26 
parameter
 
	gSCAN_CYCLES_MAX
 = 1000

29 
input
 
flush
,

32 
	ginput
 [
DATA_WIDTH
-1 :0] 
i_mem_data
,

35 
	goutput
 [
DATA_WIDTH
-1 :0] 
instruction
,

38 
input
 
	gscan


41 
localparam
 
	gNOP
 = 32'h00000013;

43 
assign
 
instruction
 = 
flush
 ? 
NOP
 : 
i_mem_data
;

45 
	gendmodule


	@hazard_detection_unit.v

1 
module
 
	ghazard_detection_unit
 #(

2 
parameter
 
	gCORE
 = 0,

3 
parameter
 
	gADDRESS_BITS
 = 20,

4 
parameter
 
	gSCAN_CYCLES_MIN
 = 0,

5 
parameter
 
	gSCAN_CYCLES_MAX
 = 1000

7 
input
 
clock
,

8 
input
 
	greset
,

10 
input
 
	gfetch_valid
,

11 
input
 
	gfetch_ready
,

12 
input
 
	gissue_request
,

13 
	ginput
 [
ADDRESS_BITS
-1:0] 
issue_PC
,

14 
	ginput
 [
ADDRESS_BITS
-1:0] 
fetch_address_in
,

15 
input
 
	gmemory_valid
,

16 
input
 
	gmemory_ready
,

18 
input
 
	gload_memory
,

19 
input
 
	gstore_memory
,

20 
	ginput
 [
ADDRESS_BITS
-1:0] 
load_address
,

21 
	ginput
 [
ADDRESS_BITS
-1:0] 
memory_address_in
,

23 
	ginput
 [6:0] 
opcode_decode
,

24 
	ginput
 [6:0] 
opcode_execute
,

25 
input
 
	gbranch_execute
,

27 
output
 
	gi_mem_hazard
,

28 
output
 
	gd_mem_hazard
,

29 
output
 
	gJALR_branch_hazard
,

30 
output
 
	gJAL_hazard
,

32 
input
 
	gscan


35 
	glocalparam
 [6:0]
R_TYPE
 = 7'b0110011,

36 
BRANCH
 = 7'b1100011,

37 
JALR
 = 7'b1100111,

38 
JAL
 = 7'b1101111;

42 
assign
 
i_mem_hazard
 = (~
fetch_ready
 & ~
issue_request
) |

43 (
issue_request
 & (~
fetch_valid
 | (
issue_PC
 != 
fetch_address_in
)));

45 
assign
 
	gd_mem_hazard
 = ~
memory_ready
 |

46 (
load_memory
 & (~
memory_valid
 |

47 (
load_address
 != 
memory_address_in
)));

53 
assign
 
	gJALR_branch_hazard
 = (
opcode_execute
 == 
JALR
 ) |

54 ((
opcode_execute
 == 
BRANCH
) & 
branch_execute
);

56 
assign
 
	gJAL_hazard
 = (
opcode_decode
 == 
JAL
);

59 
	greg
 [31: 0] 
cycles
;

60 
	galways
 @ (
posedge
 
	gclock
) 
begin


61 
	gcycles
 <= 
reset
? 0 : 
cycles
 + 1;

62 if (
	gscan
 & ((
	gcycles
 >= 
SCAN_CYCLES_MIN
) & (
cycles
 <= 
SCAN_CYCLES_MAX
)) )
begin


63 
$display
 ("------ Core %d Hazard Detection Unit - Current Cycle %d ------", 
CORE
, 
cycles
);

65 
$display
 ("| Fetch Valid [%b]", 
fetch_valid
);

66 
$display
 ("| Fetch Ready [%b]", 
fetch_ready
);

67 
$display
 ("| Issue Request [%b]", 
issue_request
);

68 
$display
 ("| Issue PC [%h]", 
issue_PC
);

69 
$display
 ("| Fetch Address In [%h]", 
fetch_address_in
);

70 
$display
 ("| Load Memory [%b]", 
load_memory
);

71 
$display
 ("| Memory Valid [%b]", 
memory_valid
);

72 
$display
 ("| Store Memory [%b]", 
store_memory
);

73 
$display
 ("| Memory Ready [%b]", 
memory_ready
);

74 
$display
 ("| I-Mem Hazard [%b]", 
i_mem_hazard
);

75 
$display
 ("| D-Mem Hazard [%b]", 
d_mem_hazard
);

76 
$display
 ("| JALR/branch Hazard [%b]", 
JALR_branch_hazard
);

77 
$display
 ("| JAL Hazard [%b]", 
JAL_hazard
);

78 
$display
 ("----------------------------------------------------------------------");

79 
end


80 
end


82 
	gendmodule


	@lru.v

23 
module
 
	gLRU
 #(

24 
parameter
 
	gWIDTH
 = 4,

25 
	gINDEX_BITS
 = 8

27 
input
 
clock
,

28 
input
 
	greset
,

29 
	ginput
 [
INDEX_BITS
-1 : 0] 
current_index
,

30 
	ginput
 [
log2
(
WIDTH
)-1:0] 
access
,

31 
input
 
	gaccess_valid
,

32 
	goutput
 [
WIDTH
-1:0] 
lru


36 
function
 
integer
 
	glog2
;

37 
input
 
integer
 
	gvalue
;

38 
begin


39 
	gvalue
 = 
value
-1;

40 for(
	glog2
=0; 
	gvalue
>0; log2=
log2
+1)

41 
value
 = value >> 1;

42 
end


43 
endfunction


45 
localparam
 
	gCACHE_DEPTH
 = 1 << 
INDEX_BITS
;

46 
localparam
 
	gLRU_MEM_WIDTH
 = 
log2
(
WIDTH
)*WIDTH;

48 
genvar
 
	gi
;

49 
integer
 
	gj
;

51 
	gwire
 [
LRU_MEM_WIDTH
-1 : 0] 
data_in0
, 
	gdata_in1
, 
	gdata_out0
, 
	gdata_out1
, 
	ginit_data
;

52 
	gwire
 [
INDEX_BITS
-1 : 0] 
address0
, 
	gaddress1
;

53 
	gwire
 [
log2
(
WIDTH
)-1:0] 
w_order
 [WIDTH-1 : 0];

54 
	gwire
 [
LRU_MEM_WIDTH
-1 : 0] 
c_order
;

55 
wire
 
	gwe1
;

56 
wire
 
	gwe0
;

57 
	greg
 [
INDEX_BITS
-1 : 0] 
r_current_index
;

59 
	gdual_port_ram_with_pass_through
 #(
	gLRU_MEM_WIDTH
, 
	gINDEX_BITS
, INDEX_BITS, "NEW_DATA")

60 
lru_bram
 (
clock
, 
we0
, 
we1
, 
data_in0
, 
data_in1
, 
address0
, 
address1
,

61 
data_out0
, 
data_out1
);

64 
generate


65 for(
	gi
=0; i<
	gWIDTH
; i=
i
+1)
begin
 : 
ASSIGNS


66 
assign
 
init_data
[
i
*
log2
(
WIDTH
) +: log2(WIDTH)] = i;

67 
assign
 
	gw_order
[
i
] = 
data_out1
[i*
log2
(
WIDTH
) +: log2(WIDTH)];

68 
end


69 for(
	gi
=0; i<
	gWIDTH
; i=
i
+1)
begin
:
C_ORDER


70 
assign
 
c_order
[
i
*
log2
(
WIDTH
) +: log2(WIDTH)] = 
we0
 ? (
access
 == i) ? 0

71 : (
w_order
[
access
] > w_order[
i
]) ? w_order[i] + 1 : w_order[i] : 0;

72 
end


73 
endgenerate


75 
assign
 
	gwe1
 = 
reset
 ? 1 : 0;

76 
assign
 
	gdata_in1
 = 
reset
 ? 
init_data
 : 0;

77 
assign
 
	gaddress1
 = 
current_index
;

79 
assign
 
	gdata_in0
 = 
c_order
;

80 
assign
 
	gaddress0
 = 
r_current_index
;

82 
assign
 
	gwe0
 = 
access_valid
 & ~
reset
;

84 
	galways
 @(
posedge
 
	gclock
)
begin


85 
	gr_current_index
 <= 
current_index
;

86 
end


88 
generate


89 for(
	gi
=0; i<
	gWIDTH
; i=
i
+1)
begin
:
LUR


90 
assign
 
lru
[
i
] = 
w_order
[i] == (
WIDTH
-1);

91 
end


92 
endgenerate


94 
	gendmodule


	@main_memory.v

23 
module
 
	gmain_memory
 #(

24 
parameter
 
	gDATA_WIDTH
 = 32,

25 
	gADDRESS_WIDTH
 = 32,

26 
	gMSG_BITS
 = 4,

27 
	gINDEX_BITS
 = 15,

28 
	gNUM_PORTS
 = 1,

29 
	gINIT_FILE
 = "./instructions.dat"

31 
clock
, 
	greset
,

32 
	gmsg_in
,

33 
	gaddress
,

34 
	gdata_in
,

35 
	gmsg_out
,

36 
	gaddress_out
,

37 
	gdata_out


41 
function
 
integer
 
	glog2
;

42 
input
 
integer
 
	gvalue
;

43 
begin


44 
	gvalue
 = 
value
-1;

45 for(
	glog2
=0; 
	gvalue
>0; log2=
log2
+1)

46 
value
 = value>>1;

47 
end


48 
endfunction


50 
input
 
	gclock
, 
	greset
;

51 
	ginput
 [
NUM_PORTS
*
MSG_BITS
-1 : 0] 
msg_in
;

52 
	ginput
 [
NUM_PORTS
*
ADDRESS_WIDTH
-1 : 0] 
address
;

53 
	ginput
 [
NUM_PORTS
*
DATA_WIDTH
-1 : 0] 
data_in
;

54 
	goutput
 [
NUM_PORTS
*
MSG_BITS
-1 : 0] 
msg_out
;

55 
	goutput
 [
NUM_PORTS
*
ADDRESS_WIDTH
-1 : 0] 
address_out
;

56 
	goutput
 [
NUM_PORTS
*
DATA_WIDTH
-1 : 0] 
data_out
;

58 
localparam
 
	gMEM_DEPTH
 = 1 << 
INDEX_BITS
;

59 
localparam
 
	gIDLE
 = 0,

60 
	gSERVING
 = 1,

61 
	gREAD_OUT
 = 2;

68 `
	ginclude
 "./params.h"

70 
genvar
 
	gi
;

71 
integer
 
	gj
;

73 
	greg
 [1:0] 
state
;

74 
	greg
 [
log2
(
NUM_PORTS
)-1 : 0] 
serving
;

75 
	greg
 [
MSG_BITS
-1 : 0] 
t_msg_out
 [
NUM_PORTS
-1 : 0];

76 
	greg
 [
ADDRESS_WIDTH
-1 : 0] 
t_address_out
 [
NUM_PORTS
-1 : 0];

77 
	greg
 [
MSG_BITS
-1 : 0] 
t_msg
;

78 
	greg
 [
ADDRESS_WIDTH
-1 : 0] 
t_address
;

79 
	greg
 [
DATA_WIDTH
-1 : 0] 
t_data
;

81 
	gwire
 [
NUM_PORTS
-1 : 0] 
requests
;

82 
	gwire
 [
log2
(
NUM_PORTS
)-1 : 0] 
serv_next
;

83 
	gwire
 [
MSG_BITS
-1 : 0] 
w_msg_in
 [
NUM_PORTS
-1 : 0];

84 
	gwire
 [
ADDRESS_WIDTH
-1 : 0] 
w_address_in
 [
NUM_PORTS
-1 : 0];

85 
	gwire
 [
DATA_WIDTH
-1 : 0] 
w_data_in
 [
NUM_PORTS
-1 : 0];

86 
	gwire
 [
DATA_WIDTH
-1 : 0] 
w_data_out
 [
NUM_PORTS
-1 : 0];

87 
wire
 
	gwe0
;

88 
	gwire
 [
DATA_WIDTH
-1 : 0] 
data_in0
;

89 
	gwire
 [
ADDRESS_WIDTH
-1 : 0] 
address0
;

90 
	gwire
 [
DATA_WIDTH
-1 : 0] 
data_out0
, 
	gdata_out1
;

92 
generate


93 for(
	gi
=0;i<
	gNUM_PORTS
; i=
i
+1)
begin
 : 
SPLIT_INPUTS


94 
assign
 
w_msg_in
[
i
] = 
msg_in
[i*
MSG_BITS
 +: MSG_BITS];

95 
assign
 
	gw_data_in
[
i
] = 
data_in
[i*
DATA_WIDTH
 +: DATA_WIDTH];

96 
assign
 
	gw_address_in
[
i
] = 
address
[i*
ADDRESS_WIDTH
 +: ADDRESS_WIDTH];

97 
assign
 
	grequests
[
i
] = (
w_msg_in
[i] == 
R_REQ
) | (w_msg_in[i] == 
WB_REQ
);

98 
end


99 
endgenerate


101 
assign
 
	gaddress0
 = (
state
 == 
SERVING
) ? 
t_address
 : 0;

102 
assign
 
	gdata_in0
 = (
state
 == 
SERVING
) ? 
t_data
 : 0;

103 
assign
 
	gwe0
 = (
state
 == 
SERVING
) & (
t_msg
 == 
WB_REQ
);

106 
generate
 if(
	gNUM_PORTS
 > 1)

107 
	garbiter
 #(
	gNUM_PORTS
) 
arbitrtor_1
 (
clock
, 
reset
, 
requests
, 
serv_next
);

109 
assign
 
	gserv_next
 = 0;

110 
endgenerate


113 
	gBRAM
 #(

114 .
DATA_WIDTH
(DATA_WIDTH),

115 .
	$ADDR_WIDTH
(
INDEX_BITS
)

116 ) 
	`BRAM_inst
 (

117 .
	`clock
(
clock
),

118 .
	`reset
(1'b0),

119 .
	`readEnable
(1'b1),

120 .
	`readAddress
(
address0
[0 +: 
INDEX_BITS
]),

121 .
	`readData
(
data_out0
),

122 .
	`writeEnable
(
we0
),

123 .
	`writeAddress
(
address0
[0 +: 
INDEX_BITS
]),

124 .
	`writeData
(
data_in0
),

125 .
	`scan
(1'b0)

130 
always
 @(
posedge
 
clock
)
begin


131 if(
reset
)
begin


132 for(
j
=0; j<
NUM_PORTS
; j=j+1)
begin


133 
t_msg_out
[
j
] <= 
NO_REQ
;

134 
t_address_out
[
j
] <= 0;

135 
end


136 
state
 <= 
IDLE
;

137 
end


138 else 
begin


139 case(
state
)

140 
IDLE
:
begin


141 if(|
requests
)
begin


142 
t_msg
 <= 
w_msg_in
[
serv_next
];

143 
t_address
 <= 
w_address_in
[
serv_next
];

144 
t_data
 <= 
w_data_in
[
serv_next
];

145 
serving
 <= 
serv_next
;

146 if(
w_msg_in
[
serv_next
] == 
WB_REQ
)
begin


147 
t_msg_out
[
serving
] <= 
MEM_RESP
;

148 
t_address_out
[
serving
] <= 
w_address_in
[
serv_next
];

149 
end


150 
state
 <= 
SERVING
;

151 
end


153 
state
 <= 
IDLE
;

154 
end


155 
SERVING
:
begin


156 if(
t_msg
 == 
R_REQ
)
begin


157 
t_msg_out
[
serving
] <= 
MEM_RESP
;

158 
t_address_out
[
serving
] <= 
w_address_in
[serving];

159 
state
 <= 
READ_OUT
;

160 
end


161 else if(
t_msg
 == 
WB_REQ
)
begin


162 
t_msg_out
[
serving
] <= 
NO_REQ
;

163 
t_address_out
[
serving
] <= 0;

164 
state
 <= 
IDLE
;

165 
end


166 
end


167 
READ_OUT
:
begin


168 
t_msg_out
[
serving
] <= 
NO_REQ
;

169 
t_address_out
[
serving
] <= 0;

170 
state
 <= 
IDLE
;

171 
end


172 default: 
state
 <= 
IDLE
;

173 
endcase


174 
end


175 
end


178 
generate


179 for(
i
=0; i<
NUM_PORTS
; i=i+1)
begin
 : 
OUTPUTS


180 
assign
 
w_data_out
[
i
] = (i==
serving
) & (
state
==
READ_OUT
) ? 
data_out0
 : 0;

181 
assign
 
msg_out
[
i
*
MSG_BITS
 +: MSG_BITS ] = 
t_msg_out
[i];

182 
assign
 
address_out
[
i
*
ADDRESS_WIDTH
 +: ADDRESS_WIDTH] = 
t_address_out
[i];

183 
assign
 
data_out
[
i
*
DATA_WIDTH
 +: DATA_WIDTH] = 
w_data_out
[i];

184 
end


185 
endgenerate


187 
endmodule


	@main_memory_interface.v

23 
module
 
	gmain_memory_interface
 #(

24 
parameter
 
	gOFFSET_BITS
 = 2,

25 
	gDATA_WIDTH
 = 32,

26 
	gADDRESS_WIDTH
 = 32,

27 
	gMSG_BITS
 = 4

29 
clock
, 
	greset
,

31 
	gcache2interface_msg
,

32 
	gcache2interface_address
,

33 
	gcache2interface_data
,

35 
	ginterface2cache_msg
,

36 
	ginterface2cache_address
,

37 
	ginterface2cache_data
,

39 
	gnetwork2interface_msg
,

40 
	gnetwork2interface_address
,

41 
	gnetwork2interface_data
,

43 
	ginterface2network_msg
,

44 
	ginterface2network_address
,

45 
	ginterface2network_data
,

47 
	gmem2interface_msg
,

48 
	gmem2interface_address
,

49 
	gmem2interface_data
,

51 
	ginterface2mem_msg
,

52 
	ginterface2mem_address
,

53 
	ginterface2mem_data


56 
localparam
 
	gWORDS_PER_LINE
 = 1 << 
OFFSET_BITS
;

57 
localparam
 
	gBUS_WIDTH
 = 
DATA_WIDTH
*
WORDS_PER_LINE
;

59 
localparam
 
	gIDLE
 = 0,

60 
	gREAD_MEMORY
 = 1,

61 
	gWRITE_MEMORY
 = 2,

62 
	gRESPOND
 = 3;

69 `
	ginclude
 "./params.h"

71 
input
 
	gclock
, 
	greset
;

72 
	ginput
 [
MSG_BITS
-1 : 0] 
cache2interface_msg
;

73 
	ginput
 [
ADDRESS_WIDTH
-1 : 0] 
cache2interface_address
;

74 
	ginput
 [
BUS_WIDTH
-1 : 0] 
cache2interface_data
;

76 
	goutput
 [
MSG_BITS
-1 : 0 ] 
interface2cache_msg
;

77 
	goutput
 [
ADDRESS_WIDTH
-1 : 0] 
interface2cache_address
;

78 
	goutput
 [
BUS_WIDTH
-1 : 0] 
interface2cache_data
;

80 
	ginput
 [
MSG_BITS
-1 : 0] 
network2interface_msg
;

81 
	ginput
 [
ADDRESS_WIDTH
-1 : 0] 
network2interface_address
;

82 
	ginput
 [
DATA_WIDTH
-1 : 0] 
network2interface_data
;

84 
	goutput
 [
MSG_BITS
-1 : 0] 
interface2network_msg
;

85 
	goutput
 [
ADDRESS_WIDTH
-1 : 0] 
interface2network_address
;

86 
	goutput
 [
DATA_WIDTH
-1 : 0] 
interface2network_data
;

88 
	ginput
 [
MSG_BITS
-1 : 0] 
mem2interface_msg
;

89 
	ginput
 [
ADDRESS_WIDTH
-1 : 0] 
mem2interface_address
;

90 
	ginput
 [
DATA_WIDTH
-1 : 0] 
mem2interface_data
;

92 
	goutput
 [
MSG_BITS
-1 : 0] 
interface2mem_msg
;

93 
	goutput
 [
ADDRESS_WIDTH
-1 : 0] 
interface2mem_address
;

94 
	goutput
 [
DATA_WIDTH
-1 : 0] 
interface2mem_data
;

97 
genvar
 
	gi
;

98 
integer
 
	gj
;

99 
	greg
 [2:0] 
state
;

100 
	greg
 [
DATA_WIDTH
-1 : 0] 
r_intf2cache_data
 [
WORDS_PER_LINE
-1 : 0];

101 
	greg
 [
MSG_BITS
-1 : 0] 
r_intf2cache_msg
;

102 
	greg
 [
ADDRESS_WIDTH
-1 : 0] 
r_intf2cache_address
;

103 
	greg
 [
DATA_WIDTH
-1 : 0] 
from_intf_data
;

104 
	greg
 [
MSG_BITS
-1 : 0] 
from_intf_msg
;

105 
	greg
 [
ADDRESS_WIDTH
-1 : 0] 
from_intf_address
;

106 
	greg
 [
OFFSET_BITS
 : 0] 
word_counter
;

108 
wire
 
	glocal_address
 = 1;

110 
	gwire
 [
DATA_WIDTH
-1 : 0] 
w_cache2intf_data
 [
WORDS_PER_LINE
-1 : 0];

111 
	gwire
 [
MSG_BITS
-1 : 0] 
to_intf_msg
;

112 
	gwire
 [
ADDRESS_WIDTH
-1 : 0] 
to_intf_address
;

113 
	gwire
 [
DATA_WIDTH
-1 : 0] 
to_intf_data
;

117 
generate


118 for(
	gi
=0; i<
	gWORDS_PER_LINE
; i=
i
+1)
begin
 : 
SPLIT_INPUTS


119 
assign
 
w_cache2intf_data
[
i
] = 
cache2interface_data
[i*
DATA_WIDTH
 +:

120 
DATA_WIDTH
];

121 
end


122 
endgenerate


124 
assign
 
	gto_intf_msg
 = 
local_address
 ? 
mem2interface_msg
 :

125 
network2interface_msg
;

126 
assign
 
	gto_intf_address
 = 
local_address
 ? 
mem2interface_address
 :

127 
network2interface_address
;

128 
assign
 
	gto_intf_data
 = 
local_address
 ? 
mem2interface_data
 :

129 
network2interface_data
;

132 
assign
 
	ginterface2cache_msg
 = 
r_intf2cache_msg
;

133 
assign
 
	ginterface2cache_address
 = 
r_intf2cache_address
;

134 
generate


135 for(
	gi
=0; i<
	gWORDS_PER_LINE
; i=
i
+1)
begin
: 
OUTDATA


136 
assign
 
interface2cache_data
[
i
*
DATA_WIDTH
 +: DATA_WIDTH] =

137 
r_intf2cache_data
[
i
];

138 
end


139 
endgenerate


141 
assign
 
	ginterface2network_msg
 = 
local_address
 ? 0 : 
from_intf_msg
;

142 
assign
 
	ginterface2network_address
 = 
local_address
 ? 0 : 
from_intf_address
;

143 
assign
 
	ginterface2network_data
 = 
local_address
 ? 0 : 
from_intf_data
;

145 
assign
 
	ginterface2mem_msg
 = 
local_address
 ? 
from_intf_msg
 : 0;

146 
assign
 
	ginterface2mem_address
 = 
local_address
 ? 
from_intf_address
 : 0;

147 
assign
 
	ginterface2mem_data
 = 
local_address
 ? 
from_intf_data
 : 0;

150 
	galways
 @(
posedge
 
	gclock
)
begin


151 if(
	greset
)
begin


152 
	gr_intf2cache_msg
 <= 
NO_REQ
;

153 
	gr_intf2cache_address
 <= 0;

154 
	gfrom_intf_msg
 <= 
NO_REQ
;

155 
	gfrom_intf_address
 <= 0;

156 
	gfrom_intf_data
 <= 0;

157 for(
	gj
=0; j<
	gWORDS_PER_LINE
; j=
j
+1)
begin


158 
r_intf2cache_data
[
j
] <= 0;

159 
end


160 
	gstate
 <= 
IDLE
;

161 
end


162 else 
begin


163 case(
state
)

164 
IDLE
:
begin


165 if(
cache2interface_msg
 == 
R_REQ
)
begin


166 
word_counter
 <= 0;

167 
from_intf_msg
 <= 
R_REQ
;

168 
from_intf_address
 <= 
cache2interface_address
;

169 
r_intf2cache_address
 <= 
cache2interface_address
;

170 
state
 <= 
READ_MEMORY
;

171 
end


172 else if((
cache2interface_msg
 == 
FLUSH
) | (cache2interface_msg == 
WB_REQ
))

173 
begin


174 
word_counter
 <= 0;

175 
from_intf_msg
 <= 
WB_REQ
;

176 
from_intf_address
 <= 
cache2interface_address
;

177 
from_intf_data
 <= 
w_cache2intf_data
[0];

178 
r_intf2cache_address
 <= 
cache2interface_address
;

179 
state
 <= 
WRITE_MEMORY
;

180 
end


182 
state
 <= 
IDLE
;

183 
end


184 
READ_MEMORY
:
begin


185 if((
to_intf_msg
 == 
MEM_RESP
) & (
word_counter
 < 
WORDS_PER_LINE
-1))
begin


186 
r_intf2cache_data
[
word_counter
] <= 
to_intf_data
;

187 
word_counter
 <= word_counter + 1;

188 
from_intf_address
 <= from_intf_address + 1;

189 
from_intf_msg
 <= 
R_REQ
;

190 
end


191 else if((
to_intf_msg
 == 
MEM_RESP
) &

192 (
word_counter
 == 
WORDS_PER_LINE
-1))
begin


193 
r_intf2cache_data
[
word_counter
] <= 
to_intf_data
;

194 
from_intf_address
 <= 0;

195 
from_intf_msg
 <= 
NO_REQ
;

196 
r_intf2cache_msg
 <= 
MEM_RESP
;

197 
state
 <= 
RESPOND
;

198 
end


200 
state
 <= 
READ_MEMORY
;

201 
end


202 
WRITE_MEMORY
:
begin


203 if((
to_intf_msg
 == 
MEM_RESP
) & (
word_counter
 < 
WORDS_PER_LINE
-1))
begin


204 
from_intf_data
 <= 
w_cache2intf_data
[
word_counter
 + 1];

205 
word_counter
 <= word_counter + 1;

206 
from_intf_address
 <= from_intf_address + 1;

207 
from_intf_msg
 <= 
WB_REQ
;

208 
end


209 else if((
to_intf_msg
 == 
MEM_RESP
) &

210 (
word_counter
 == 
WORDS_PER_LINE
-1))
begin


211 
from_intf_data
 <= 0;

212 
from_intf_address
 <= 0;

213 
from_intf_msg
 <= 
NO_REQ
;

214 
r_intf2cache_msg
 <= 
MEM_RESP
;

215 
state
 <= 
RESPOND
;

216 
end


218 
state
 <= 
WRITE_MEMORY
;

219 
end


220 
RESPOND
:
begin


221 
r_intf2cache_address
 <= 0;

222 
r_intf2cache_msg
 <= 
NO_REQ
;

223 
state
 <= 
IDLE
;

224 
end


225 default: 
state
 <= 
IDLE
;

226 
endcase


227 
end


228 
end


230 
endmodule


	@memory_interface.v

23 
module
 
	gmemory_interface
 #(

24 
parameter
 
	gDATA_WIDTH
 = 32,

25 
parameter
 
	gADDRESS_BITS
 = 32

28 
input
 
fetch_read
,

29 
	ginput
 [
ADDRESS_BITS
-1:0] 
fetch_address_out
,

30 
	goutput
 [
DATA_WIDTH
-1 :0] 
fetch_data_in
,

31 
	goutput
 [
ADDRESS_BITS
-1:0] 
fetch_address_in
,

32 
output
 
	gfetch_valid
,

33 
output
 
	gfetch_ready
,

35 
input
 
	gmemory_read
,

36 
input
 
	gmemory_write
,

37 
	ginput
 [
DATA_WIDTH
/8-1:0] 
memory_byte_en
,

38 
	ginput
 [
ADDRESS_BITS
-1:0] 
memory_address_out
,

39 
	ginput
 [
DATA_WIDTH
-1 :0] 
memory_data_out
,

40 
	goutput
 [
DATA_WIDTH
-1 :0] 
memory_data_in
,

41 
	goutput
 [
ADDRESS_BITS
-1:0] 
memory_address_in
,

42 
output
 
	gmemory_valid
,

43 
output
 
	gmemory_ready
,

45 
	ginput
 [
DATA_WIDTH
-1 :0] 
i_mem_data_out
,

46 
	ginput
 [
ADDRESS_BITS
-1:0] 
i_mem_address_out
,

47 
input
 
	gi_mem_valid
,

48 
input
 
	gi_mem_ready
,

49 
output
 
	gi_mem_read
,

50 
	goutput
 [
ADDRESS_BITS
-1:0] 
i_mem_address_in
,

52 
	ginput
 [
DATA_WIDTH
-1 :0] 
d_mem_data_out
,

53 
	ginput
 [
ADDRESS_BITS
-1:0] 
d_mem_address_out
,

54 
input
 
	gd_mem_valid
,

55 
input
 
	gd_mem_ready
,

56 
output
 
	gd_mem_read
,

57 
output
 
	gd_mem_write
,

58 
	goutput
 [
DATA_WIDTH
/8-1:0] 
d_mem_byte_en
,

59 
	goutput
 [
ADDRESS_BITS
-1:0] 
d_mem_address_in
,

60 
	goutput
 [
DATA_WIDTH
-1 :0] 
d_mem_data_in
,

62 
input
 
	gscan


65 
assign
 
	gfetch_data_in
 = 
i_mem_data_out
;

66 
assign
 
	gfetch_address_in
 = 
i_mem_address_out
;

67 
assign
 
	gfetch_valid
 = 
i_mem_valid
;

68 
assign
 
	gfetch_ready
 = 
i_mem_ready
;

70 
assign
 
	gmemory_data_in
 = 
d_mem_data_out
;

71 
assign
 
	gmemory_address_in
 = 
d_mem_address_out
;

72 
assign
 
	gmemory_valid
 = 
d_mem_valid
;

73 
assign
 
	gmemory_ready
 = 
d_mem_ready
;

75 
assign
 
	gi_mem_read
 = 
fetch_read
;

76 
assign
 
	gi_mem_address_in
 = 
fetch_address_out
;

78 
assign
 
	gd_mem_read
 = 
memory_read
;

79 
assign
 
	gd_mem_write
 = 
memory_write
;

80 
assign
 
	gd_mem_byte_en
 = 
memory_byte_en
;

81 
assign
 
	gd_mem_address_in
 = 
memory_address_out
;

82 
assign
 
	gd_mem_data_in
 = 
memory_data_out
;

84 
	gendmodule


	@memory_issue.v

23 
module
 
	gmemory_issue
 #(

24 
parameter
 
	gCORE
 = 0,

25 
parameter
 
	gDATA_WIDTH
 = 32,

26 
parameter
 
	gADDRESS_BITS
 = 20,

27 
parameter
 
	gNUM_BYTES
 = 
DATA_WIDTH
/8,

28 
parameter
 
	gLOG2_NUM_BYTES
 = 
log2
(
NUM_BYTES
),

29 
parameter
 
	gSCAN_CYCLES_MIN
 = 0,

30 
parameter
 
	gSCAN_CYCLES_MAX
 = 1000

32 
input
 
clock
,

33 
input
 
	greset
,

36 
input
 
	gload
,

37 
input
 
	gstore
,

38 
	ginput
 [
ADDRESS_BITS
-1:0] 
address
,

39 
	ginput
 [
DATA_WIDTH
-1:0] 
store_data
,

40 
	ginput
 [
LOG2_NUM_BYTES
-1:0] 
log2_bytes
,

43 
output
 
	gmemory_read
,

44 
output
 
	gmemory_write
,

45 
	goutput
 [
NUM_BYTES
-1:0] 
memory_byte_en
,

46 
	goutput
 [
ADDRESS_BITS
-1:0] 
memory_address
,

47 
	goutput
 [
DATA_WIDTH
-1:0] 
memory_data
,

50 
input
 
	gscan


55 
function
 
integer
 
	glog2
;

56 
input
 
integer
 
	gvalue
;

57 
begin


58 
	gvalue
 = 
value
-1;

59 for (
	glog2
=0; 
	gvalue
>0; log2=
log2
+1)

60 
value
 = value >> 1;

61 
end


62 
endfunction


64 
genvar
 
	gi
,
	gj
;

68 
	gwire
 [
NUM_BYTES
-1:0] 
base_byte
;

70 
	gwire
 [
NUM_BYTES
-1:0] 
mux_chain
 [NUM_BYTES:0];

72 
	gwire
 [
NUM_BYTES
-1:0] 
byte_en_mask
 [
LOG2_NUM_BYTES
:0];

74 
	gwire
 [
DATA_WIDTH
-1:0] 
byte_data
;

75 
	gwire
 [
DATA_WIDTH
-1:0] 
half_word_data
;

77 
generate


78 for (
	gi
=0; i<
	gNUM_BYTES
; i=
i
+1) 
begin
 : 
BASE_BYTE_DECODER


79 
assign
 
mux_chain
[
i
] = 
address
[
LOG2_NUM_BYTES
-1:0] == i ? 1 << i : mux_chain[i+1];

80 
end


81 
endgenerate


83 
assign
 
	gmux_chain
[
NUM_BYTES
] = 0;

84 
assign
 
	gbase_byte
 = 
mux_chain
[0];

103 
generate


104 for(
	gi
=1; i<=
NUM_BYTES
; i=
i
*2) 
begin
 : 
BYTE_ENABLE_MASK_LOOP


105 for(
j
=0; 
	gj
<
	gNUM_BYTES
; j=j+
i
) 
begin
 : 
BYTE_ENABLE_BIT_LOOP


106 
assign
 
byte_en_mask
[
log2
(
i
)][
j
 +: i] = {i{
base_byte
[j]}};

107 
end


108 
end


109 
endgenerate


114 
assign
 
	gbyte_data
 = {
DATA_WIDTH
/8 {
store_data
[ 7:0]}};

115 
assign
 
	ghalf_word_data
 = {
DATA_WIDTH
/16{
store_data
[15:0]}};

118 
assign
 
	gmemory_read
 = 
load
;

119 
assign
 
	gmemory_write
 = 
store
;

120 
assign
 
	gmemory_byte_en
 = 
byte_en_mask
[
log2_bytes
];

121 
assign
 
	gmemory_address
 = 
address
;

122 
assign
 
	gmemory_data
 = 
log2_bytes
 == 0 ? 
byte_data
 :

123 
log2_bytes
 == 1 ? 
half_word_data
 :

124 
log2_bytes
 == 2 ? 
store_data
 :

125 {
DATA_WIDTH
{1'b0}};

128 
reg
 [31: 0] 
cycles
;

129 
	galways
 @ (
posedge
 
	gclock
) 
begin


130 
	gcycles
 <= 
reset
? 0 : 
cycles
 + 1;

131 if(
	gscan
 & ((
	gcycles
 >= 
SCAN_CYCLES_MIN
) & (
cycles
 <= 
SCAN_CYCLES_MAX
)) ) 
begin


132 
$display
 ("------ Core %d Memory Issue - Current Cycle %d -------", 
CORE
, 
cycles
);

133 
$display
 ("| Load [%b]", 
load
);

134 
$display
 ("| Store [%b]", 
store
);

135 
$display
 ("| Address [%h]", 
address
);

136 
$display
 ("| Store Data [%h]", 
store_data
);

137 
$display
 ("| Log2 Bytes [%b]", 
log2_bytes
);

138 
$display
 ("| Memory Read [%b]", 
memory_read
);

139 
$display
 ("| Memory Write [%b]", 
memory_write
);

140 
$display
 ("| Memory Byte En [%b]", 
memory_byte_en
);

141 
$display
 ("| Memory Address [%h]", 
memory_address
);

142 
$display
 ("| Memory Data [%h]", 
memory_data
);

143 
$display
 ("----------------------------------------------------------------------");

144 
end


145 
end


147 
	galways
@(
posedge
 
	gclock
) 
begin


148 if(
	gstore
 && (
	gaddress
[0] != 1'b0) && (log2_bytes == 2'
b01
)) 
begin


149 
$display
("Unalligned Half Word Write at %g", 
$time
);

150 
$display
 ("| Address [%h]", 
address
);

151 
end


152 if(
	gload
 && (
	gaddress
[0] != 1'b0) && (log2_bytes == 2'
b01
)) 
begin


153 
$display
("Unalligned Half Word Read at %g", 
$time
);

154 
$display
 ("| Address [%h]", 
address
);

155 
end


156 if(
	gstore
 && (
	gaddress
[0] != 1'b0) && (log2_bytes == 2'
b10
)) 
begin


157 
$display
("Unalligned Half Word Write at %g", 
$time
);

158 
$display
 ("| Address [%h]", 
address
);

159 
end


160 if(
	gload
 && (
	gaddress
[0] != 1'b0) && (log2_bytes == 2'
b10
)) 
begin


161 
$display
("Unalligned Half Word Read at %g", 
$time
);

162 
$display
 ("| Address [%h]", 
address
);

163 
end


164 
end


167 
	gendmodule


	@memory_receive.v

23 
module
 
	gmemory_receive
 #(

24 
parameter
 
	gCORE
 = 0,

25 
parameter
 
	gDATA_WIDTH
 = 32,

26 
parameter
 
	gADDRESS_BITS
 = 20,

27 
parameter
 
	gNUM_BYTES
 = 
DATA_WIDTH
/8,

28 
parameter
 
	gLOG2_NUM_BYTES
 = 
log2
(
NUM_BYTES
),

29 
parameter
 
	gSCAN_CYCLES_MIN
 = 0,

30 
parameter
 
	gSCAN_CYCLES_MAX
 = 1000

32 
input
 
clock
,

33 
input
 
	greset
,

36 
	ginput
 [
LOG2_NUM_BYTES
-1:0] 
log2_bytes
,

37 
input
 
	gunsigned_load
,

39 
	ginput
 [
DATA_WIDTH
-1:0] 
memory_data_in
,

40 
	ginput
 [
DATA_WIDTH
-1:0] 
memory_address_in
,

43 
	goutput
 [
DATA_WIDTH
-1:0] 
load_data
,

45 
input
 
	gscan


50 
function
 
integer
 
	glog2
;

51 
input
 
integer
 
	gvalue
;

52 
begin


53 
	gvalue
 = 
value
-1;

54 for (
	glog2
=0; 
	gvalue
>0; log2=
log2
+1)

55 
value
 = value >> 1;

56 
end


57 
endfunction


59 
	gwire
 [
LOG2_NUM_BYTES
:0] 
load_type
;

60 
	gwire
 [
LOG2_NUM_BYTES
-1:0] 
byte_shift
;

61 
	gwire
 [
DATA_WIDTH
-1:0] 
shifted_data
;

63 
assign
 
	gload_type
 = {
log2_bytes
, 
unsigned_load
};

64 
assign
 
	gbyte_shift
 = 
memory_address_in
[
LOG2_NUM_BYTES
-1:0];

66 
assign
 
	gshifted_data
 = 
memory_data_in
 >> {
byte_shift
, 3'b000};

67 
assign
 
load_data
 =

68 
load_type
 == 3'd0 ? {{DATA_WIDTH-8{shifted_data[7]}} , shifted_data[7:0]} : // LB

69 
load_type
 == 3'd1 ? {{DATA_WIDTH-8{1'
b0
}} , 
	gshifted_data
[7:0]} :

70 
load_type
 == 3'd2 ? {{DATA_WIDTH-16{shifted_data[15]}}, shifted_data[15:0]} : // LH

71 
load_type
 == 3'd3 ? {{DATA_WIDTH-16{1'
b0
}} , 
	gshifted_data
[15:0]} :

72 
load_type
 == 3'd4 ? {{DATA_WIDTH-32{shifted_data[31]}}, shifted_data[31:0]} : // LW

73 
load_type
 == 3'd5 ? {{DATA_WIDTH-32{1'
b0
}} , 
	gshifted_data
[31:0]} :

74 {
DATA_WIDTH
{1'b0}};

76 
reg
 [31: 0] 
cycles
;

77 
	galways
 @ (
posedge
 
	gclock
) 
begin


78 
	gcycles
 <= 
reset
? 0 : 
cycles
 + 1;

79 if(
	gscan
 & ((
	gcycles
 >= 
SCAN_CYCLES_MIN
) & (
cycles
 <= 
SCAN_CYCLES_MAX
)) ) 
begin


80 
$display
 ("------ Core %d Memory Receive - Current Cycle %d -------", 
CORE
, 
cycles
);

81 
$display
 ("| Log2 Bytes [%b]", 
log2_bytes
);

82 
$display
 ("| Unsigned Load [%b]", 
unsigned_load
);

83 
$display
 ("| Memory Data In [%h]", 
memory_data_in
);

84 
$display
 ("| Memory Addr In [%h]", 
memory_address_in
);

85 
$display
 ("| Load Data [%h]", 
load_data
);

86 
$display
 ("----------------------------------------------------------------------");

87 
end


88 
end


90 
	gendmodule


	@mux_bus.v

23 
module
 
	gmux_bus
 #(

24 
parameter
 
	gWIDTH
 = 8,

25 
	gNUM_PORTS
 = 4

27 
input
 [
WIDTH
*
NUM_PORTS
-1 : 0] 
data_in
,

28 
	ginput
 [
log2
(
NUM_PORTS
)-1 : 0] 
enable_port
,

29 
input
 
	gvalid_enable
,

30 
	goutput
 [
WIDTH
-1 : 0] 
data_out


34 
function
 
integer
 
	glog2
;

35 
input
 
integer
 
	gvalue
;

36 
begin


37 
	gvalue
 = 
value
-1;

38 for(
	glog2
=0; 
	gvalue
>0; log2=
log2
+1)

39 
value
 = value>>1;

40 
end


41 
endfunction


43 
genvar
 
	gi
;

44 
	gwire
 [
WIDTH
-1 : 0] 
inputs
 [
NUM_PORTS
-1 : 0];

46 
generate


47 for(
	gi
=0; i<
	gNUM_PORTS
; i=
i
+1)
begin
: 
INPUT


48 
assign
 
inputs
[
i
] = 
data_in
[i*
WIDTH
 +: WIDTH];

49 
end


50 
endgenerate


52 
assign
 
	gdata_out
 = 
valid_enable
 ? 
inputs
[
enable_port
] : 0;

54 
	gendmodule


	@one_hot_decoder.v

23 
module
 
	gone_hot_decoder
 #(

24 
parameter
 
	gWIDTH
 = 16

26 
encoded
,

27 
	gdecoded
,

28 
	gvalid


32 
function
 
integer
 
	glog2
;

33 
input
 
integer
 
	gvalue
;

34 
begin


35 
	gvalue
 = 
value
-1;

36 for (
	glog2
=0; 
	gvalue
>0; log2=
log2
+1)

37 
value
 = value >> 1;

38 
end


39 
endfunction


42 
	ginput
 [
WIDTH
-1 : 0] 
encoded
;

43 
	goutput
 [
log2
(
WIDTH
)-1 : 0] 
decoded
;

44 
output
 
	gvalid
;

46 
generate


47 
wire
 
	gdecoded_half_valid
;

48 
wire
 
	gtop_half_has_one
;

50 if (
	gWIDTH
==2)
begin


51 
assign
 
valid
 = 
encoded
[1] | encoded [0];

52 
assign
 
	gdecoded
 = 
encoded
[1];

53 
end


54 else 
begin


55 
assign
 
	gtop_half_has_one
 = |
encoded
[
WIDTH
-1 : WIDTH/2];

56 
assign
 
	gdecoded
[
log2
(
WIDTH
)-1] = 
top_half_has_one
;

57 
assign
 
	gvalid
 = 
top_half_has_one
 | 
decoded_half_valid
;

59 
	gone_hot_decoder
 #(
	gWIDTH
/2) 
decode_half
 (

60 .
encoded
(
top_half_has_one
 ? encoded[
WIDTH
-1 : WIDTH/2]

61 : 
encoded
[(
WIDTH
/2)-1 : 0]),

62 .
decoded
(decoded[
log2
(
WIDTH
)-2 : 0]),

63 .
valid
(
decoded_half_valid
) );

64 
end


65 
endgenerate


68 
	gendmodule


	@one_hot_encoder.v

23 
module
 
	gone_hot_encoder
 #(

24 
parameter
 
	gWIDTH
 = 8

26 
in
,

27 
	gvalid_input
,

28 
	gout


32 
function
 
integer
 
	glog2
;

33 
input
 
integer
 
	gvalue
;

34 
begin


35 
	gvalue
 = 
value
-1;

36 for(
	glog2
=0; 
	gvalue
>0; log2=
log2
+1)

37 
value
 = value >> 1;

38 
end


39 
endfunction


41 
	ginput
 [
log2
(
WIDTH
)-1 : 0] 
in
;

42 
input
 
	gvalid_input
;

43 
	goutput
 [
WIDTH
-1 : 0] 
out
;

45 
genvar
 
	gi
;

47 
generate


48 for(
	gi
=0; i<
	gWIDTH
; i=
i
+1)
begin
 : 
ENCODED_BITS


49 
assign
 
out
[
i
] = (
in
 == i) & 
valid_input
 ? 1'b1 : 1'
b0
;

50 
end


51 
endgenerate


53 
	gendmodule


	@params.h

2 
localparam
 
	gNO_REQ
 = 4'd0,

3 
R_REQ
 = 4'd1,

4 
WB_REQ
 = 4'd2,

5 
FLUSH
 = 4'd3,

6 
FLUSH_S
 = 4'd4,

7 
WS_BCAST
 = 4'd5,

8 
RFO_BCAST
 = 4'd6,

9 
C_WB
 = 4'd7,

10 
C_FLUSH
 = 4'd8,

11 
EN_ACCESS
 = 4'd9,

12 
MEM_RESP
 = 4'd10,

13 
MEM_RESP_S
 = 4'd11,

14 
MEM_C_RESP
 = 4'd12,

15 
REQ_FLUSH
 = 4'd13,

16 
HOLD_BUS
 = 4'd14;

21 
localparam
 
INVALID
 = 2'b00,

22 
EXCLUSIVE
 = 2'b01,

23 
SHARED
 = 2'b11,

24 
MODIFIED
 = 2'b10;

	@priority_encoder.v

23 
module
 
	gpriority_encoder
 #(

24 
parameter
 
	gWIDTH
 = 8,

25 
parameter
 
	gPRIORITY
 = "MSB"

27 
decode
,

28 
	gencode
,

29 
	gvalid


33 
function
 
integer
 
	glog2
;

34 
input
 
integer
 
	gvalue
;

35 
begin


36 
	gvalue
 = 
value
-1;

37 for(
	glog2
=0; 
	gvalue
>0; log2=
log2
+1)

38 
value
 = value>>1;

39 
end


40 
endfunction


42 
	ginput
 [
WIDTH
-1 : 0] 
decode
;

43 
	goutput
 [
log2
(
WIDTH
)-1 : 0] 
encode
;

44 
output
 
	gvalid
;

46 
generate


47 
wire
 
	gencoded_half_valid
;

48 
wire
 
	ghalf_has_one
;

50 if (
	gWIDTH
==2)
begin


51 
assign
 
valid
 = 
decode
[1] | decode [0];

52 
assign
 
	gencode
 = ((
PRIORITY
 == "LSB") & 
decode
[0]) ? 0 : decode[1];

53 
end


54 else 
begin


55 
assign
 
	ghalf_has_one
 = (
PRIORITY
 == "LSB") ? |
decode
[(
WIDTH
/2)-1 : 0]

56 : |
decode
[
WIDTH
-1 : WIDTH/2];

57 
assign
 
	gencode
[
log2
(
WIDTH
)-1] = ((
PRIORITY
 == "MSB") & 
half_has_one
) ? 1

58 : ((
PRIORITY
 == "LSB") & ~
half_has_one
 &

59 
valid
) ? 1

61 
assign
 
	gvalid
 = 
half_has_one
 | 
encoded_half_valid
;

63 if(
	gPRIORITY
 == "MSB")

64 
priority_encoder
 #((
WIDTH
/2), 
	gPRIORITY
)

65 
decode_half
 (

66 .
decode
(
half_has_one
 ? decode[
WIDTH
-1 : WIDTH/2] :

67 
decode
[(
WIDTH
/2)-1 : 0]),

68 .
encode
(encode[
log2
(
WIDTH
)-2 : 0]),

69 .
valid
(
encoded_half_valid
)

73 
	gpriority_encoder
 #((
	gWIDTH
/2), 
	gPRIORITY
)

74 
decode_half
 (

75 .
decode
(
half_has_one
 ? decode[(
WIDTH
/2)-1 : 0] : decode[WIDTH-1 :

76 
WIDTH
/2]),

77 .
encode
(encode[
log2
(
WIDTH
)-2 : 0]),

78 .
valid
(
encoded_half_valid
)

80 
end


81 
endgenerate


84 
	gendmodule


	@regFile.v

24 
module
 
	gregFile
 #(

25 
parameter
 
	gREG_DATA_WIDTH
 = 32,

26 
parameter
 
	gREG_SEL_BITS
 = 5

28 
input
 
clock
,

29 
input
 
	greset
,

30 
input
 
	gwEn
,

31 
	ginput
 [
REG_DATA_WIDTH
-1:0] 
write_data
,

32 
	ginput
 [
REG_SEL_BITS
-1:0] 
read_sel1
,

33 
	ginput
 [
REG_SEL_BITS
-1:0] 
read_sel2
,

34 
	ginput
 [
REG_SEL_BITS
-1:0] 
write_sel
,

35 
	goutput
[
REG_DATA_WIDTH
-1:0] 
read_data1
,

36 
	goutput
[
REG_DATA_WIDTH
-1:0] 
read_data2


39 (* 
	gram_style
 = "distributed" *)

40 
reg
 [
REG_DATA_WIDTH
-1:0] 
register_file
[0:(1<<
REG_SEL_BITS
)-1];

42 
	galways
 @(
posedge
 
	gclock
)

43 if(
	greset
==1)

44 
register_file
[0] <= 0;

46 if (
	gwEn
 & 
	gwrite_sel
 != 0) 
register_file
[
write_sel
] <= 
write_data
;

51 
assign
 
	gread_data1
 = 
register_file
[
read_sel1
];

52 
assign
 
	gread_data2
 = 
register_file
[
read_sel2
];

54 
	gendmodule


	@replacement_controller.v

23 
module
 
	greplacement_controller
 #(

24 
parameter
 
	gNUMBER_OF_WAYS
 = 8,

25 
	gINDEX_BITS
 = 8

27 
clock
, 
	greset
,

28 
	gways_in_use
,

29 
	gcurrent_index
,

30 
	greplacement_policy_select
,

31 
	gcurrent_access
, 
	gaccess_valid
,

32 
	greport
,

33 
	gselected_way


37 
function
 
integer
 
	glog2
;

38 
input
 
integer
 
	gvalue
;

39 
begin


40 
	gvalue
 = 
value
-1;

41 for (
	glog2
=0; 
	gvalue
>0; log2=
log2
+1)

42 
value
 = value >> 1;

43 
end


44 
endfunction


46 
input
 
	gclock
, 
	greset
;

47 
	ginput
 [
NUMBER_OF_WAYS
-1:0] 
ways_in_use
;

48 
	ginput
 [
INDEX_BITS
-1 : 0] 
current_index
;

49 
input
 
	greplacement_policy_select
;

50 
	ginput
 [
log2
(
NUMBER_OF_WAYS
)-1:0] 
current_access
;

51 
input
 
	gaccess_valid
;

52 
input
 
	greport
;

53 
	goutput
 [
NUMBER_OF_WAYS
-1:0] 
selected_way
;

55 
	gwire
 [
NUMBER_OF_WAYS
-1:0] 
lru_way
, 
	grandom_way
, 
	gnext_empty_way
;

56 
	gwire
 [
log2
(
NUMBER_OF_WAYS
)-1 : 0] 
current_access_binary
;

57 
wire
 
	gvalid_decode
, 
	gvalid_empty_way
;

60 
	gLRU
 #(
	gNUMBER_OF_WAYS
, 
	gINDEX_BITS
)

61 
lru_inst
 (
clock
, 
reset
, 
current_index
, 
current_access
,

62 
access_valid
, 
lru_way
);

65 
	gempty_way_select
 #(
	gNUMBER_OF_WAYS
)

66 
empty_way_sel_inst
 (
ways_in_use
, 
next_empty_way
, 
valid_empty_way
);

68 
assign
 
	grandom_way
 = 0;

70 
assign
 
	gselected_way
 = 
valid_empty_way
 ? 
next_empty_way


71 : (
replacement_policy_select
)? 
random_way


72 : 
lru_way
;

74 
	gendmodule


	@single_cycle_control_unit.v

1 
module
 
	gsingle_cycle_control_unit
 #(

2 
parameter
 
	gCORE
 = 0,

3 
parameter
 
	gADDRESS_BITS
 = 20,

4 
parameter
 
	gNUM_BYTES
 = 32/8,

5 
parameter
 
	gLOG2_NUM_BYTES
 = 
log2
(
NUM_BYTES
),

6 
parameter
 
	gSCAN_CYCLES_MIN
 = 0,

7 
parameter
 
	gSCAN_CYCLES_MAX
 = 1000

10 
input
 
clock
,

11 
input
 
	greset
,

13 
	ginput
 [6:0] 
opcode_decode
,

14 
	ginput
 [6:0] 
opcode_execute
,

15 
	ginput
 [2:0] 
funct3
,

16 
	ginput
 [6:0] 
funct7
,

18 
	ginput
 [
ADDRESS_BITS
-1:0] 
JALR_target_execute
,

19 
	ginput
 [
ADDRESS_BITS
-1:0] 
branch_target_execute
,

20 
	ginput
 [
ADDRESS_BITS
-1:0] 
JAL_target_decode
,

21 
input
 
	gbranch_execute
,

23 
output
 
	gbranch_op
,

24 
output
 
	gmemRead
,

25 
	goutput
 [5:0] 
ALU_operation
,

26 
output
 
	gmemWrite
,

27 
	goutput
 [
LOG2_NUM_BYTES
-1:0] 
log2_bytes
,

28 
output
 
	gunsigned_load
,

29 
	goutput
 [1:0] 
next_PC_sel
,

30 
	goutput
 [1:0] 
operand_A_sel
,

31 
output
 
	goperand_B_sel
,

32 
	goutput
 [1:0] 
extend_sel
,

33 
output
 
	gregWrite
,

35 
	goutput
 [
ADDRESS_BITS
-1:0] 
target_PC
,

36 
output
 
	gi_mem_read
,

39 
input
 
	gfetch_valid
,

40 
input
 
	gfetch_ready
,

41 
	ginput
 [
ADDRESS_BITS
-1:0] 
issue_PC
,

42 
	ginput
 [
ADDRESS_BITS
-1:0] 
fetch_address_in
,

43 
input
 
	gmemory_valid
,

44 
input
 
	gmemory_ready
,

46 
input
 
	gload_memory
,

47 
input
 
	gstore_memory
,

48 
	ginput
 [
ADDRESS_BITS
-1:0] 
load_address
,

49 
	ginput
 [
ADDRESS_BITS
-1:0] 
memory_address_in
,

52 
output
 
	gflush_fetch_receive
,

54 
input
 
	gscan


58 
function
 
integer
 
	glog2
;

59 
input
 
integer
 
	gvalue
;

60 
begin


61 
	gvalue
 = 
value
-1;

62 for (
	glog2
=0; 
	gvalue
>0; log2=
log2
+1)

63 
value
 = value >> 1;

64 
end


65 
endfunction


68 
wire
 
	gd_mem_hazard
;

69 
wire
 
	gi_mem_hazard
;

70 
wire
 
	gJALR_branch_hazard
;

71 
wire
 
	gJAL_hazard
;

72 
wire
 
	gregWrite_i
;

74 
assign
 
	gflush_fetch_receive
 = 
i_mem_hazard
;

75 
assign
 
	gregWrite
 = 
regWrite_i
 & ~
d_mem_hazard
;

77 
	ghazard_detection_unit
 #(

78 .
CORE
(CORE),

79 .
ADDRESS_BITS
(ADDRESS_BITS),

80 .
SCAN_CYCLES_MIN
(SCAN_CYCLES_MIN),

81 .
	$SCAN_CYCLES_MAX
(
SCAN_CYCLES_MAX
)

82 ) 
	`hazard_unit
 (

83 .
	`clock
(
clock
),

84 .
	`reset
(
reset
),

85 .
	`fetch_valid
(
fetch_valid
),

86 .
	`fetch_ready
(
fetch_ready
),

87 .
	`issue_PC
(
issue_PC
),

88 .
	`issue_request
(1'b1),

89 .
	`fetch_address_in
(
fetch_address_in
),

90 .
	`memory_valid
(
memory_valid
),

91 .
	`memory_ready
(
memory_ready
),

93 .
	`load_memory
(
load_memory
),

94 .
	`store_memory
(
store_memory
),

95 .
	`load_address
(
load_address
),

96 .
	`memory_address_in
(
memory_address_in
),

98 .
	`opcode_decode
(
opcode_decode
),

99 .
	`opcode_execute
(
opcode_execute
),

100 .
	`branch_execute
(
branch_execute
),

102 .
	`i_mem_hazard
(
i_mem_hazard
),

103 .
	`d_mem_hazard
(
d_mem_hazard
),

104 .
	`JALR_branch_hazard
(
JALR_branch_hazard
),

105 .
	`JAL_hazard
(
JAL_hazard
),

107 .
	`scan
(
scan
)

111 
control_unit
 #(

112 .
	`CORE
(
CORE
),

113 .
	`ADDRESS_BITS
(
ADDRESS_BITS
),

114 .
	`SCAN_CYCLES_MIN
(
SCAN_CYCLES_MIN
),

115 .
	$SCAN_CYCLES_MAX
(
SCAN_CYCLES_MAX
)

116 ) 
	`control
 (

117 .
	`clock
(
clock
),

118 .
	`reset
(
reset
),

119 .
	`opcode_decode
(
opcode_decode
),

120 .
	`opcode_execute
(
opcode_execute
),

121 .
	`funct3
(
funct3
),

122 .
	`funct7
(
funct7
),

124 .
	`JALR_target_execute
(
JALR_target_execute
),

125 .
	`branch_target_execute
(
branch_target_execute
),

126 .
	`JAL_target_decode
(
JAL_target_decode
),

127 .
	`branch_execute
(
branch_execute
),

129 .
	`true_data_hazard
(1'b0), // No data hazards in single cycle core

130 .
	`d_mem_hazard
(
d_mem_hazard
),

131 .
	`i_mem_hazard
(
i_mem_hazard
),

132 .
	`JALR_branch_hazard
(
JALR_branch_hazard
),

133 .
	`JAL_hazard
(
JAL_hazard
),

135 .
	`branch_op
(
branch_op
),

136 .
	`memRead
(
memRead
),

137 .
	`ALU_operation
(
ALU_operation
),

138 .
	`memWrite
(
memWrite
),

139 .
	`log2_bytes
(
log2_bytes
),

140 .
	`unsigned_load
(
unsigned_load
),

141 .
	`next_PC_sel
(
next_PC_sel
),

142 .
	`operand_A_sel
(
operand_A_sel
),

143 .
	`operand_B_sel
(
operand_B_sel
),

144 .
	`extend_sel
(
extend_sel
),

145 .
	`regWrite
(
regWrite_i
),

147 .
	`target_PC
(
target_PC
),

148 .
	`i_mem_read
(
i_mem_read
),

150 .
	`scan
(
scan
)

153 
reg
 [31: 0] 
cycles
;

154 
always
 @ (
posedge
 
clock
) 
begin


155 
cycles
 <= 
reset
? 0 : cycles + 1;

156 if (
scan
 & ((
cycles
 >= 
SCAN_CYCLES_MIN
) & (cycles <= 
SCAN_CYCLES_MAX
)) )
begin


157 
	`$display
 ("------ Core %d Singl Cycle Control Unit - Current Cycle %d ------", 
CORE
, 
cycles
);

158 
	`$display
 ("| Memory Valid [%b]", 
memory_valid
);

159 
	`$display
 ("| Memory Ready [%b]", 
memory_ready
);

160 
	`$display
 ("| Fetch Valid [%b]", 
fetch_valid
);

161 
	`$display
 ("| Target PC [%h]", 
target_PC
);

162 
	`$display
 ("| Next PC sel [%b]", 
next_PC_sel
);

163 
	`$display
 ("----------------------------------------------------------------------");

164 
end


165 
end


167 
endmodule


	@single_cycle_core.v

23 
module
 
	gsingle_cycle_core
 #(

24 
parameter
 
	gCORE
 = 0,

25 
parameter
 
	gRESET_PC
 = 0,

26 
parameter
 
	gDATA_WIDTH
 = 32,

27 
parameter
 
	gADDRESS_BITS
 = 32,

28 
parameter
 
	gNUM_BYTES
 = 
DATA_WIDTH
/8,

29 
parameter
 
	gSCAN_CYCLES_MIN
 = 0,

30 
parameter
 
	gSCAN_CYCLES_MAX
 = 1000

32 
input
 
clock
,

33 
input
 
	greset
,

34 
input
 
	gstart
,

35 
	ginput
 [
ADDRESS_BITS
-1 :0] 
program_address
,

37 
input
 
	gfetch_valid
,

38 
input
 
	gfetch_ready
,

39 
	ginput
 [
DATA_WIDTH
-1 :0] 
fetch_data_in
,

40 
	ginput
 [
ADDRESS_BITS
-1 :0] 
fetch_address_in
,

41 
input
 
	gmemory_valid
,

42 
input
 
	gmemory_ready
,

43 
	ginput
 [
DATA_WIDTH
-1 :0] 
memory_data_in
,

44 
	ginput
 [
ADDRESS_BITS
-1 :0] 
memory_address_in
,

45 
output
 
	gfetch_read
,

46 
	goutput
 [
ADDRESS_BITS
-1 :0] 
fetch_address_out
,

47 
output
 
	gmemory_read
,

48 
output
 
	gmemory_write
,

49 
	goutput
 [
NUM_BYTES
-1: 0] 
memory_byte_en
,

50 
	goutput
 [
ADDRESS_BITS
-1 :0] 
memory_address_out
,

51 
	goutput
 [
DATA_WIDTH
-1 :0] 
memory_data_out
,

53 
input
 
	gscan


57 
function
 
integer
 
	glog2
;

58 
input
 
integer
 
	gvalue
;

59 
begin


60 
	gvalue
 = 
value
-1;

61 for (
	glog2
=0; 
	gvalue
>0; log2=
log2
+1)

62 
value
 = value >> 1;

63 
end


64 
endfunction


66 
localparam
 
	gLOG2_NUM_BYTES
 = 
log2
(
NUM_BYTES
);

69 
	gwire
 [1 :0] 
next_PC_select
;

70 
	gwire
 [
ADDRESS_BITS
-1:0] 
target_PC
;

71 
	gwire
 [
ADDRESS_BITS
-1:0] 
issue_PC
;

73 
wire
 
	gflush_fetch_receive
;

74 
	gwire
 [
DATA_WIDTH
-1 :0] 
instruction
;

76 
	gwire
 [
ADDRESS_BITS
-1:0] 
inst_PC
;

77 
	gwire
 [1 :0] 
extend_sel
;

78 
wire
 
	gwrite
;

79 
	gwire
 [4 :0] 
write_reg
;

80 
	gwire
 [
DATA_WIDTH
-1 :0] 
write_data
;

81 
	gwire
 [
DATA_WIDTH
-1 :0] 
rs1_data
;

82 
	gwire
 [
DATA_WIDTH
-1 :0] 
rs2_data
;

83 
	gwire
 [4 :0] 
rd
;

84 
	gwire
 [6 :0] 
opcode
;

85 
	gwire
 [6 :0] 
funct7
;

86 
	gwire
 [2 :0] 
funct3
;

87 
	gwire
 [
DATA_WIDTH
-1 :0] 
extend_imm
;

88 
	gwire
 [
ADDRESS_BITS
-1:0] 
branch_target
;

89 
	gwire
 [
ADDRESS_BITS
-1:0] 
JAL_target
;

91 
	gwire
 [5 :0] 
ALU_operation
;

92 
	gwire
 [1 :0] 
operand_A_sel
;

93 
wire
 
	goperand_B_sel
;

94 
wire
 
	gbranch_op
;

95 
	gwire
 [
DATA_WIDTH
-1 :0] 
ALU_result
;

96 
	gwire
 [
ADDRESS_BITS
-1:0] 
JALR_target
;

97 
wire
 
	gbranch
;

99 
wire
 
	gmemRead
;

100 
wire
 
	gmemWrite
;

101 
	gwire
 [
LOG2_NUM_BYTES
-1:0] 
log2_bytes
;

102 
wire
 
	gunsigned_load
;

103 
	gwire
 [
ADDRESS_BITS
-1:0] 
generated_address
;

104 
	gwire
 [
DATA_WIDTH
-1 :0] 
load_data
;

106 
wire
 
	gregWrite
;

109 
assign
 
	ggenerated_address
 = 
ALU_result
;

110 
assign
 
	ginst_PC
 = 
fetch_address_in
;

114 
	gfetch_issue
 #(

115 .
CORE
(CORE),

116 .
RESET_PC
(RESET_PC),

117 .
ADDRESS_BITS
(ADDRESS_BITS),

118 .
SCAN_CYCLES_MIN
(SCAN_CYCLES_MIN),

119 .
	$SCAN_CYCLES_MAX
(
SCAN_CYCLES_MAX
)

120 ) 
	`FI
 (

121 .
	`clock
(
clock
),

122 .
	`reset
(
reset
),

123 .
	`next_PC_select
(
next_PC_select
),

124 .
	`target_PC
(
target_PC
),

125 .
	`issue_PC
(
issue_PC
),

127 .
	`i_mem_read_address
(
fetch_address_out
),

129 .
	`scan
(
scan
)

134 
fetch_receive
 #(

135 .
	`DATA_WIDTH
(
DATA_WIDTH
),

136 .
	`SCAN_CYCLES_MIN
(
SCAN_CYCLES_MIN
),

137 .
	$SCAN_CYCLES_MAX
(
SCAN_CYCLES_MAX
)

138 ) 
	`FR
 (

139 .
	`flush
(
flush_fetch_receive
),

140 .
	`i_mem_data
(
fetch_data_in
),

141 .
	`instruction
(
instruction
),

143 .
	`scan
(
scan
)

148 
decode_unit
 #(

149 .
	`CORE
(
CORE
),

150 .
	`ADDRESS_BITS
(
ADDRESS_BITS
),

151 .
	`SCAN_CYCLES_MIN
(
SCAN_CYCLES_MIN
),

152 .
	$SCAN_CYCLES_MAX
(
SCAN_CYCLES_MAX
)

153 ) 
	`ID
 (

154 .
	`clock
(
clock
),

155 .
	`reset
(
reset
),

157 .
	`PC
(
inst_PC
),

158 .
	`instruction
(
instruction
),

159 .
	`extend_sel
(
extend_sel
),

160 .
	`write
(
write
),

161 .
	`write_reg
(
write_reg
),

162 .
	`write_data
(
write_data
),

164 .
	`rs1_data
(
rs1_data
),

165 .
	`rs2_data
(
rs2_data
),

166 .
	`rd
(
rd
),

167 .
	`opcode
(
opcode
),

168 .
	`funct7
(
funct7
),

169 .
	`funct3
(
funct3
),

170 .
	`extend_imm
(
extend_imm
),

171 .
	`branch_target
(
branch_target
),

172 .
	`JAL_target
(
JAL_target
),

174 .
	`scan
(
scan
)

179 
single_cycle_control_unit
 #(

180 .
	`CORE
(
CORE
),

181 .
	`ADDRESS_BITS
(
ADDRESS_BITS
),

182 .
	`SCAN_CYCLES_MIN
(
SCAN_CYCLES_MIN
),

183 .
	$SCAN_CYCLES_MAX
(
SCAN_CYCLES_MAX
)

184 ) 
	`CTRL
 (

186 .
	`clock
(
clock
),

187 .
	`reset
(
reset
),

189 .
	`opcode_decode
(
opcode
),

190 .
	`opcode_execute
(
opcode
),

191 .
	`funct7
(
funct7
),

192 .
	`funct3
(
funct3
),

194 .
	`JALR_target_execute
(
JALR_target
),

195 .
	`branch_target_execute
(
branch_target
),

196 .
	`JAL_target_decode
(
JAL_target
),

197 .
	`branch_execute
(
branch
),

199 .
	`branch_op
(
branch_op
),

200 .
	`memRead
(
memRead
),

201 .
	`ALU_operation
(
ALU_operation
),

202 .
	`memWrite
(
memWrite
),

203 .
	`log2_bytes
(
log2_bytes
),

204 .
	`unsigned_load
(
unsigned_load
),

205 .
	`next_PC_sel
(
next_PC_select
),

206 .
	`operand_A_sel
(
operand_A_sel
),

207 .
	`operand_B_sel
(
operand_B_sel
),

208 .
	`extend_sel
(
extend_sel
),

209 .
	`regWrite
(
regWrite
),

211 .
	`target_PC
(
target_PC
),

212 .
	`i_mem_read
(
fetch_read
),

215 .
	`fetch_valid
(
fetch_valid
),

216 .
	`fetch_ready
(
fetch_ready
),

217 .
	`issue_PC
(
issue_PC
),

218 .
	`fetch_address_in
(
fetch_address_in
),

219 .
	`memory_valid
(
memory_valid
),

220 .
	`memory_ready
(
memory_ready
),

221 .
	`load_address
(
generated_address
),

222 .
	`memory_address_in
(
memory_address_in
),

224 .
	`load_memory
(
memRead
),

225 .
	`store_memory
(
memWrite
),

228 .
	`flush_fetch_receive
(
flush_fetch_receive
),

231 .
	`scan
(
scan
)

236 
execution_unit
 #(

237 .
	`CORE
(
CORE
),

238 .
	`DATA_WIDTH
(
DATA_WIDTH
),

239 .
	`ADDRESS_BITS
(
ADDRESS_BITS
),

240 .
	`SCAN_CYCLES_MIN
(
SCAN_CYCLES_MIN
),

241 .
	$SCAN_CYCLES_MAX
(
SCAN_CYCLES_MAX
)

242 ) 
	`EX
 (

243 .
	`clock
(
clock
),

244 .
	`reset
(
reset
),

245 .
	`ALU_operation
(
ALU_operation
),

246 .
	`PC
(
inst_PC
),

247 .
	`operand_A_sel
(
operand_A_sel
),

248 .
	`operand_B_sel
(
operand_B_sel
),

249 .
	`branch_op
(
branch_op
),

250 .
	`rs1_data
(
rs1_data
),

251 .
	`rs2_data
(
rs2_data
),

252 .
	`extend
(
extend_imm
),

254 .
	`branch
(
branch
),

255 .
	`ALU_result
(
ALU_result
),

256 .
	`JALR_target
(
JALR_target
),

258 .
	`scan
(
scan
)

263 
memory_issue
 #(

264 .
	`CORE
(
CORE
),

265 .
	`DATA_WIDTH
(
DATA_WIDTH
),

266 .
	`ADDRESS_BITS
(
ADDRESS_BITS
),

267 .
	`SCAN_CYCLES_MIN
(
SCAN_CYCLES_MIN
),

268 .
	$SCAN_CYCLES_MAX
(
SCAN_CYCLES_MAX
)

269 ) 
	`MI
 (

270 .
	`clock
(
clock
),

271 .
	`reset
(
reset
),

274 .
	`load
(
memRead
),

275 .
	`store
(
memWrite
),

276 .
	`address
(
generated_address
),

277 .
	`store_data
(
rs2_data
),

278 .
	`log2_bytes
(
log2_bytes
),

280 .
	`memory_read
(
memory_read
),

281 .
	`memory_write
(
memory_write
),

282 .
	`memory_byte_en
(
memory_byte_en
),

283 .
	`memory_address
(
memory_address_out
),

284 .
	`memory_data
(
memory_data_out
),

286 .
	`scan
(
scan
)

291 
memory_receive
 #(

292 .
	`CORE
(
CORE
),

293 .
	`DATA_WIDTH
(
DATA_WIDTH
),

294 .
	$ADDRESS_BITS
(
ADDRESS_BITS
)

295 ) 
	`MR
 (

296 .
	`clock
(
clock
),

297 .
	`reset
(
reset
),

299 .
	`log2_bytes
(
log2_bytes
),

300 .
	`unsigned_load
(
unsigned_load
),

302 .
	`memory_data_in
(
memory_data_in
),

303 .
	`memory_address_in
(
memory_address_in
),

305 .
	`load_data
(
load_data
),

307 .
	`scan
(
scan
)

312 
writeback_unit
 #(

313 .
	`CORE
(
CORE
),

314 .
	`DATA_WIDTH
(
DATA_WIDTH
),

315 .
	`SCAN_CYCLES_MIN
(
SCAN_CYCLES_MIN
),

316 .
	$SCAN_CYCLES_MAX
(
SCAN_CYCLES_MAX
)

317 ) 
	`WB
 (

318 .
	`clock
(
clock
),

319 .
	`reset
(
reset
),

321 .
	`opWrite
(
regWrite
),

322 .
	`opSel
(
memRead
),

323 .
	`opReg
(
rd
),

324 .
	`ALU_result
(
ALU_result
),

325 .
	`memory_data
(
load_data
),

327 .
	`write
(
write
),

328 .
	`write_reg
(
write_reg
),

329 .
	`write_data
(
write_data
),

331 .
	`scan
(
scan
)

334 
endmodule


	@snooper.v

23 
module
 
	gsnooper
 #(

24 
parameter
 
	gCACHE_OFFSET_BITS
 = 2,

25 
	gBUS_OFFSET_BITS
 = 1,

26 
	gDATA_WIDTH
 = 32,

27 
	gADDRESS_WIDTH
 = 32,

28 
	gMSG_BITS
 = 4,

29 
	gINDEX_BITS
 = 8,

30 
	gCOHERENCE_BITS
 = 2,

31 
	gSTATUS_BITS
 = 2,

32 
	gNUMBER_OF_WAYS
 = 4,

33 
	gMAX_OFFSET_BITS
 = 2

35 
clock
,

36 
	greset
,

37 
	gdata_in
,

38 
	gmatched_way
,

39 
	gcoh_bits
,

40 
	gstatus_bits
,

41 
	ghit
,

42 
	gread
,

43 
	gwrite
,

44 
	ginvalidate
,

45 
	gindex
,

46 
	gtag
,

47 
	gmeta_data
,

48 
	gdata_out
,

49 
	gway_select
,

51 
	gintf_msg
,

52 
	gintf_address
,

53 
	gintf_data
,

54 
	gsnoop_msg
,

55 
	gsnoop_address
,

56 
	gsnoop_data
,

58 
	gbus_msg
,

59 
	gbus_address
,

60 
	greq_ready
,

61 
	gbus_master
,

62 
	gcurr_offset


66 
function
 
integer
 
	glog2
;

67 
input
 
integer
 
	gvalue
;

68 
begin


69 
	gvalue
 = 
value
-1;

70 for (
	glog2
=0; 
	gvalue
>0; log2=
log2
+1)

71 
value
 = value >> 1;

72 
end


73 
endfunction


75 
localparam
 
	gCACHE_WORDS
 = 1 << 
CACHE_OFFSET_BITS
;

76 
localparam
 
	gBUS_WORDS
 = 1 << 
BUS_OFFSET_BITS
;

77 
localparam
 
	gCACHE_WIDTH
 = 
DATA_WIDTH
*
CACHE_WORDS
;

78 
localparam
 
	gSBITS
 = 
COHERENCE_BITS
 + 
STATUS_BITS
;

79 
localparam
 
	gTAG_BITS
 = 
ADDRESS_WIDTH
 - 
CACHE_OFFSET_BITS
 - 
INDEX_BITS
;

80 
localparam
 
	gWAY_BITS
 = (
NUMBER_OF_WAYS
 > 1) ? 
	$log2
(
NUMBER_OF_WAYS
) : 1;

82 
localparam
 
IDLE
 = 3'd0,

83 
START
 = 3'd1,

84 
READ_LINE
 = 3'd2,

85 
WRITE_LINE
 = 3'd3,

86 
INVALIDATE_LINE
 = 3'd4,

87 
ACTION
 = 3'd5,

88 
WAIT_FOR_RESP
 = 3'd6;

95 `
include
 "./params.h"

98 
input
 
clock
, 
reset
;

100 
input
 [
CACHE_WIDTH
-1 :0] 
data_in
;

101 
input
 [
WAY_BITS
-1 :0] 
matched_way
;

102 
input
 [
COHERENCE_BITS
-1:0] 
coh_bits
;

103 
input
 [
STATUS_BITS
-1 :0] 
status_bits
;

104 
input
 
hit
;

105 
output
 
read
, 
write
, 
invalidate
;

106 
output
 [
INDEX_BITS
-1 :0] 
index
;

107 
output
 [
TAG_BITS
-1 :0] 
tag
;

108 
output
 [
SBITS
-1 :0] 
meta_data
;

109 
output
 [
CACHE_WIDTH
-1 :0] 
data_out
;

110 
output
 [
WAY_BITS
-1 :0] 
way_select
;

113 
input
 [
MSG_BITS
-1: 0] 
intf_msg
;

114 
input
 [
ADDRESS_WIDTH
-1: 0] 
intf_address
;

115 
input
 [
CACHE_WIDTH
-1: 0] 
intf_data
;

116 
output
 [
MSG_BITS
-1: 0] 
snoop_msg
;

117 
output
 [
ADDRESS_WIDTH
-1: 0] 
snoop_address
;

118 
output
 [
CACHE_WIDTH
-1: 0] 
snoop_data
;

121 
input
 [
MSG_BITS
-1: 0] 
bus_msg
;

122 
input
 [
ADDRESS_WIDTH
-1: 0] 
bus_address
;

123 
input
 
req_ready
;

124 
input
 
bus_master
;

125 
input
 [
	$log2
(
MAX_OFFSET_BITS
):0] 
curr_offset
;

129 
genvar
 
i
;

130 
integer
 
j
;

132 
wire
 [
DATA_WIDTH
-1:0] 
w_cache_data
 [
CACHE_WORDS
-1:0];

133 
wire
 [
MAX_OFFSET_BITS
-1:0] 
offset_diff
;

134 
wire
 [
MAX_OFFSET_BITS
 :0] 
ratio
;

135 
wire
 
wider_transfer
, 
wider_line
;

136 
wire
 
read_req
, 
write_req
, 
flush_req
, 
mflush_req
;

137 
wire
 
dirty
;

140 
reg
 [2:0] 
state
;

141 
reg
 
r_read
, 
r_write
, 
r_invalidate
;

142 
reg
 [
INDEX_BITS
-1 :0] 
r_index
;

143 
reg
 [
TAG_BITS
-1 :0] 
r_tag
;

144 
reg
 [
SBITS
-1 :0] 
r_meta_data
;

145 
reg
 [
DATA_WIDTH
-1: 0] 
r_data_out
 [
CACHE_WORDS
-1:0];

146 
reg
 [
WAY_BITS
-1 :0] 
r_way_select
;

147 
reg
 [
MSG_BITS
-1: 0] 
r_snoop_msg
;

148 
reg
 [
ADDRESS_WIDTH
-1:0] 
r_snoop_address
;

149 
reg
 [
DATA_WIDTH
-1: 0] 
r_snoop_data
 [
CACHE_WORDS
-1:0];

150 
reg
 [
MSG_BITS
-1: 0] 
r_bus_msg
;

151 
reg
 [
ADDRESS_WIDTH
-1:0] 
r_bus_address
;

152 
reg
 [
DATA_WIDTH
-1: 0] 
r_transfer_words
;

153 
reg
 [
ADDRESS_WIDTH
-1:0] 
address_counter
;

154 
reg
 [
MAX_OFFSET_BITS
:0] 
line_counter
, 
word_counter
;

155 
reg
 [
	$log2
(
MAX_OFFSET_BITS
):0] 
r_curr_offset
;

158 
generate


159 for(
i
=0; i<
CACHE_WORDS
; i=i+1)
begin
: 
SPLIT_CACHE_DATA


160 
assign
 
w_cache_data
[
i
] = 
data_in
[i*
DATA_WIDTH
 +: DATA_WIDTH];

161 
end


162 
endgenerate


164 
assign
 
dirty
 = 
status_bits
[
STATUS_BITS
-2];

166 
assign
 
offset_diff
 = (
r_curr_offset
 > 
CACHE_OFFSET_BITS
) ?

167 (
r_curr_offset
 - 
CACHE_OFFSET_BITS
) : 0;

169 
assign
 
ratio
 = 1 << 
offset_diff
;

170 
assign
 
wider_transfer
 = 
r_curr_offset
 > 
CACHE_OFFSET_BITS
;

171 
assign
 
wider_line
 = 
CACHE_OFFSET_BITS
 >= 
r_curr_offset
;

173 
assign
 
read_req
 = ((
bus_msg
 == 
R_REQ
) | (bus_msg == 
RFO_BCAST
)) & ~
bus_master


174 & ~
req_ready
;

175 
assign
 
write_req
 = (
bus_msg
 == 
WS_BCAST
) & ~
bus_master
 & ~
req_ready
;

176 
assign
 
mflush_req
 = (
bus_msg
 == 
REQ_FLUSH
);

177 
assign
 
flush_req
 = (
bus_msg
 == 
FLUSH_S
) & ~
bus_master
 & ~
req_ready
;

181 
assign
 
read
 = 
r_read
;

182 
assign
 
write
 = 
r_write
;

183 
assign
 
invalidate
 = 
r_invalidate
;

184 
assign
 
index
 = 
r_index
;

185 
assign
 
tag
 = 
r_tag
;

186 
assign
 
meta_data
 = 
r_meta_data
;

187 
assign
 
way_select
 = 
r_way_select
;

188 
assign
 
snoop_msg
 = 
r_snoop_msg
;

189 
assign
 
snoop_address
 = 
r_snoop_address
;

191 
generate


192 for(
i
=0; i<
CACHE_WORDS
; i=i+1)
begin
: 
SN_DATA


193 
assign
 
snoop_data
[
i
*
DATA_WIDTH
 +: DATA_WIDTH] = 
r_snoop_data
[i];

194 
assign
 
data_out
[
i
*
DATA_WIDTH
 +: DATA_WIDTH] = 
r_data_out
[i] ;

195 
end


196 
endgenerate


203 
always
 @(
posedge
 
clock
)
begin


204 if(
reset
)
begin


205 
r_read
 <= 1'b0;

206 
r_write
 <= 1'b0;

207 
r_invalidate
 <= 1'b0;

208 
r_index
 <= {
INDEX_BITS
{1'b0}};

209 
r_tag
 <= {
TAG_BITS
{1'b0}};

210 
r_meta_data
 <= {
SBITS
{1'b0}};

211 
r_way_select
 <= {
WAY_BITS
{1'b0}};

212 for(
j
=0; j<
CACHE_WORDS
; j=j+1)
begin


213 
r_data_out
[
j
] <= {
DATA_WIDTH
{1'b0}};

214 
end


215 
r_snoop_msg
 <= 
NO_REQ
;

216 
r_snoop_address
 <= {
ADDRESS_WIDTH
{1'b0}};

217 for(
j
=0; j<
CACHE_WORDS
; j=j+1)
begin


218 
r_snoop_data
[
j
] <= {
DATA_WIDTH
{1'b0}};

219 
end


220 
r_bus_address
 <= {
ADDRESS_WIDTH
{1'b0}};

221 
address_counter
 <= {
ADDRESS_WIDTH
{1'b0}};

222 
r_bus_msg
 <= 
NO_REQ
;

223 
line_counter
 <= {(
MAX_OFFSET_BITS
+1){1'b0}};

224 
word_counter
 <= {
MAX_OFFSET_BITS
{1'b0}};

225 
state
 <= 
IDLE
;

226 
end


227 else 
begin


228 case(
state
)

229 
IDLE
:
begin


230 if(
read_req
 | 
write_req
 | 
flush_req
 | 
mflush_req
)
begin


231 
r_bus_msg
 <= 
bus_msg
;

232 
r_bus_address
 <= 
bus_address
;

233 
r_curr_offset
 <= 
curr_offset
;

234 
state
 <= 
START
;

235 
end


237 
state
 <= 
IDLE
;

238 
end


239 
START
:
begin


240 
r_index
 <= 
r_bus_address
[
CACHE_OFFSET_BITS
 +: 
INDEX_BITS
];

241 
address_counter
 <= {
r_bus_address
[
ADDRESS_WIDTH
-1 : 
CACHE_OFFSET_BITS
],

242 {
CACHE_OFFSET_BITS
{1'b0}}};

243 
r_tag
 <= 
r_bus_address
[
ADDRESS_WIDTH
-1 -: 
TAG_BITS
];

244 
r_read
 <= 1'b1;

245 
line_counter
 <= 1;

246 
state
 <= 
READ_LINE
;

247 
end


248 
READ_LINE
:
begin


249 
state
 <= 
ACTION
;

250 
end


251 
ACTION
:
begin


252 for(
j
=0; j<
CACHE_WORDS
; j=j+1)
begin


253 
r_snoop_data
[
j
] <= 
w_cache_data
[j];

254 
end


255 
r_way_select
 <= 
matched_way
;

256 case(
r_bus_msg
)

257 
R_REQ
:
begin


258 if(
hit
)
begin


259 if(
dirty
)
begin


260 
r_snoop_msg
 <= 
C_WB
;

261 
r_snoop_address
 <= 
address_counter
;

262 
r_read
 <= 1'b0;

263 
r_invalidate
 <= 1'b1;

264 
state
 <= 
WAIT_FOR_RESP
;

265 
end


266 else 
begin


267 
r_read
 <= 1'b0;

268 
r_write
 <= 1'b1;

269 
r_meta_data
 <= {2'b10, SHARED};

270 for(
j
=0; j<
CACHE_WORDS
; j=j+1)
begin


271 
r_data_out
[
j
] <= 
w_cache_data
[j];

272 
end


273 
state
 <= 
WRITE_LINE
;

274 
end


275 
end


276 else 
begin


277 if(
line_counter
 == 
ratio
)
begin


278 
r_read
 <= 1'b0;

279 
r_snoop_msg
 <= 
EN_ACCESS
;

280 
r_snoop_address
 <= 
r_bus_address
;

281 
state
 <= 
WAIT_FOR_RESP
;

282 
end


283 else 
begin


284 
r_read
 <= 1'b1;

285 
r_index
 <= r_index + 1;

286 
address_counter
 <= address_counter + 
CACHE_WORDS
;

287 
line_counter
 <= line_counter + 1;

288 
state
 <= 
READ_LINE
;

289 
end


290 
end


291 
end


292 
RFO_BCAST
:
begin


293 if(
hit
)
begin


294 if(
line_counter
 == 
ratio
)
begin


295 
r_read
 <= 1'b0;

296 
r_invalidate
 <= 1'b1;

297 
r_snoop_msg
 <= 
EN_ACCESS
;

298 
r_snoop_address
 <= 
r_bus_address
;

299 
state
 <= 
WAIT_FOR_RESP
;

300 
end


301 else 
begin


302 
r_read
 <= 1'b0;

303 
r_invalidate
 <= 1'b1;

304 
state
 <= 
INVALIDATE_LINE
;

305 
end


306 
end


307 else 
begin


308 if(
line_counter
 == 
ratio
)
begin


309 
r_read
 <= 1'b0;

310 
r_snoop_msg
 <= 
EN_ACCESS
;

311 
r_snoop_address
 <= 
r_bus_address
;

312 
state
 <= 
WAIT_FOR_RESP
;

313 
end


314 else 
begin


315 
r_read
 <= 1'b1;

316 
r_index
 <= r_index + 1;

317 
address_counter
 <= address_counter + 
CACHE_WORDS
;

318 
line_counter
 <= line_counter + 1;

319 
state
 <= 
READ_LINE
;

320 
end


321 
end


322 
end


323 
WS_BCAST
:
begin


324 if(
hit
)
begin


325 if(
line_counter
 == 
ratio
)
begin


326 
r_read
 <= 1'b0;

327 
r_invalidate
 <= 1'b1;

328 
r_snoop_msg
 <= 
EN_ACCESS
;

329 
r_snoop_address
 <= 
r_bus_address
;

330 
state
 <= 
WAIT_FOR_RESP
;

331 
end


332 else 
begin


333 
r_read
 <= 1'b0;

334 
r_invalidate
 <= 1'b1;

335 
state
 <= 
INVALIDATE_LINE
;

336 
end


337 
end


338 else 
begin


339 if(
line_counter
 == 
ratio
)
begin


340 
r_read
 <= 1'b0;

341 
r_snoop_msg
 <= 
EN_ACCESS
;

342 
r_snoop_address
 <= 
r_bus_address
;

343 
state
 <= 
WAIT_FOR_RESP
;

344 
end


345 else 
begin


346 
r_read
 <= 1'b1;

347 
r_index
 <= r_index + 1;

348 
address_counter
 <= address_counter + 
CACHE_WORDS
;

349 
line_counter
 <= line_counter + 1;

350 
state
 <= 
READ_LINE
;

351 
end


352 
end


353 
end


354 
FLUSH_S
:
begin


355 if(
hit
)
begin


356 if(
dirty
)
begin


357 
r_snoop_msg
 <= 
C_FLUSH
;

358 
r_snoop_address
 <= 
address_counter
;

359 
r_read
 <= 1'b0;

360 
r_invalidate
 <= 1'b1;

361 
state
 <= 
WAIT_FOR_RESP
;

362 
end


363 else 
begin


364 if(
line_counter
 == 
ratio
)
begin


365 
r_read
 <= 1'b0;

366 
r_invalidate
 <= 1'b1;

367 
r_snoop_msg
 <= 
EN_ACCESS
;

368 
r_snoop_address
 <= 
r_bus_address
;

369 
state
 <= 
WAIT_FOR_RESP
;

370 
end


371 else 
begin


372 
r_read
 <= 1'b0;

373 
r_invalidate
 <= 1'b1;

374 
state
 <= 
INVALIDATE_LINE
;

375 
end


376 
end


377 
end


378 else 
begin


379 if(
line_counter
 == 
ratio
)
begin


380 
r_read
 <= 1'b0;

381 
r_snoop_msg
 <= 
EN_ACCESS
;

382 
r_snoop_address
 <= 
r_bus_address
;

383 
state
 <= 
WAIT_FOR_RESP
;

384 
end


385 else 
begin


386 
r_read
 <= 1'b1;

387 
r_index
 <= r_index + 1;

388 
address_counter
 <= address_counter + 
CACHE_WORDS
;

389 
line_counter
 <= line_counter + 1;

390 
state
 <= 
READ_LINE
;

391 
end


392 
end


393 
end


394 
REQ_FLUSH
:
begin


395 if(
hit
)
begin


396 if(
dirty
)
begin


397 
r_snoop_msg
 <= 
C_FLUSH
;

398 
r_snoop_address
 <= 
address_counter
;

399 
r_read
 <= 1'b0;

400 
r_invalidate
 <= 1'b1;

401 
state
 <= 
WAIT_FOR_RESP
;

402 
end


403 else 
begin


404 if(
line_counter
 == 
ratio
)
begin


405 
r_read
 <= 1'b0;

406 
r_invalidate
 <= 1'b1;

407 
r_snoop_msg
 <= 
EN_ACCESS
;

408 
r_snoop_address
 <= 
r_bus_address
;

409 
state
 <= 
WAIT_FOR_RESP
;

410 
end


411 else 
begin


412 
r_read
 <= 1'b0;

413 
r_invalidate
 <= 1'b1;

414 
state
 <= 
INVALIDATE_LINE
;

415 
end


416 
end


417 
end


418 else 
begin


419 if(
line_counter
 == 
ratio
)
begin


420 
r_read
 <= 1'b0;

421 
r_snoop_msg
 <= 
EN_ACCESS
;

422 
r_snoop_address
 <= 
r_bus_address
;

423 
state
 <= 
WAIT_FOR_RESP
;

424 
end


425 else 
begin


426 
r_read
 <= 1'b1;

427 
r_index
 <= r_index + 1;

428 
address_counter
 <= address_counter + 
CACHE_WORDS
;

429 
line_counter
 <= line_counter + 1;

430 
state
 <= 
READ_LINE
;

431 
end


432 
end


433 
end


434 default:
begin


435 
state
 <= 
IDLE
;

436 
end


437 
endcase


438 
end


439 
WAIT_FOR_RESP
:
begin


440 
r_invalidate
 <= 1'b0;

441 if(
line_counter
 == 
ratio
)
begin


442 if(
intf_msg
 == 
MEM_RESP
)
begin


443 
r_snoop_msg
 <= 
EN_ACCESS
;

444 
r_snoop_address
 <= 
r_bus_address
;

445 for(
j
=0; j<
CACHE_WORDS
; j=j+1)
begin


446 
r_snoop_data
[
j
] <= {
DATA_WIDTH
{1'b0}};

447 
end


448 
state
 <= 
WAIT_FOR_RESP
;

449 
end


450 else if(
req_ready
)
begin


451 
r_snoop_msg
 <= 
NO_REQ
;

452 
r_snoop_address
 <= {
ADDRESS_WIDTH
{1'b0}};

453 for(
j
=0; j<
CACHE_WORDS
; j=j+1)
begin


454 
r_snoop_data
[
j
] <= {
DATA_WIDTH
{1'b0}};

455 
end


456 
state
 <= 
IDLE
;

457 
end


459 
state
 <= 
WAIT_FOR_RESP
;

460 
end


461 else 
begin


462 if(
intf_msg
 == 
MEM_RESP
)
begin


463 
r_read
 <= 1'b1;

464 
r_index
 <= r_index + 1;

465 
address_counter
 <= address_counter + 
CACHE_WORDS
;

466 
line_counter
 <= line_counter + 1;

467 
r_snoop_msg
 <= 
HOLD_BUS
;

468 
r_snoop_address
 <= {
ADDRESS_WIDTH
{1'b0}};

469 for(
j
=0; j<
CACHE_WORDS
; j=j+1)
begin


470 
r_snoop_data
[
j
] <= {
DATA_WIDTH
{1'b0}};

471 
end


472 
state
 <= 
READ_LINE
;

473 
end


474 
end


475 
end


476 
INVALIDATE_LINE
:
begin


477 
r_invalidate
 <= 1'b0;

478 
r_read
 <= 1'b1;

479 
r_index
 <= r_index + 1;

480 
address_counter
 <= address_counter + 
CACHE_WORDS
;

481 
line_counter
 <= line_counter + 1;

482 
state
 <= 
READ_LINE
;

483 
end


484 
WRITE_LINE
:
begin


485 
r_write
 <= 1'b0;

486 if(
line_counter
 == 
ratio
)
begin


487 
r_snoop_msg
 <= 
EN_ACCESS
;

488 
r_snoop_address
 <= 
r_bus_address
;

489 for(
j
=0; j<
CACHE_WORDS
; j=j+1)
begin


490 
r_snoop_data
[
j
] <= {
DATA_WIDTH
{1'b0}};

491 
end


492 
state
 <= 
WAIT_FOR_RESP
;

493 
end


494 else 
begin


495 
r_read
 <= 1'b1;

496 
r_index
 <= r_index + 1;

497 
address_counter
 <= address_counter+ 
CACHE_WORDS
;

498 
line_counter
 <= line_counter + 1;

499 
state
 <= 
READ_LINE
;

500 
end


501 
end


502 default:
begin


503 
r_read
 <= 1'b0;

504 
r_write
 <= 1'b0;

505 
r_invalidate
 <= 1'b0;

506 
r_index
 <= {
INDEX_BITS
{1'b0}};

507 
r_tag
 <= {
TAG_BITS
{1'b0}};

508 
r_meta_data
 <= {
SBITS
{1'b0}};

509 
r_way_select
 <= {
WAY_BITS
{1'b0}};

510 for(
j
=0; j<
CACHE_WORDS
; j=j+1)
begin


511 
r_data_out
[
j
] <= {
DATA_WIDTH
{1'b0}};

512 
end


513 
r_snoop_msg
 <= 
NO_REQ
;

514 
r_snoop_address
 <= {
ADDRESS_WIDTH
{1'b0}};

515 for(
j
=0; j<
BUS_WORDS
; j=j+1)
begin


516 
r_snoop_data
[
j
] <= {
DATA_WIDTH
{1'b0}};

517 
end


518 
r_bus_address
 <= {
ADDRESS_WIDTH
{1'b0}};

519 
r_bus_msg
 <= 
NO_REQ
;

520 
state
 <= 
IDLE
;

521 
end


522 
endcase


523 
end


524 
end


526 
endmodule


	@tb_Dual_core_2_ways_single_cycle.v

1 `
ifndef
 
	gPROC_BRAM_MACROS


2 `
define
 
	gPROC_BRAM_MACROS
 1

3 `
define
 
PROGRAM_BRAM_MEMORY
 
	gdut
.
	gmemory
.
	gBRAM_inst
.
	gram


5 `
define
 
REGISTER_FILE0
 
	gdut
.
	gCORES
[0].
	gcore
.
	gID
.
	gregisters
.
	gregister_file


6 `
define
 
REGISTER_FILE1
 
	gdut
.
	gCORES
[1].
	gcore
.
	gID
.
	gregisters
.
	gregister_file


8 `
define
 
CURRENT_PC0
 
	gdut
.
	gCORES
[0].
	gcore
.
	gFI
.
	gPC_reg


9 `
define
 
CURRENT_PC1
 
	gdut
.
	gCORES
[1].
	gcore
.
	gFI
.
	gPC_reg


10 `
endif


13 
module
 
tb_Dual_core_2_ways_single_cycle
();

14 
parameter
 
	gNUM_CORES
=2;

15 
parameter
 
	gDATA_WIDTH
=32;

16 
parameter
 
	gADDRESS_BITS
=32;

17 
parameter
 
	gMEM_ADDRESS_BITS
=14;

18 
parameter
 
	gSCAN_CYCLES_MIN
=0;

19 
parameter
 
	gSCAN_CYCLES_MAX
=1000;

20 
parameter
 
	gPROGRAM
="/home/debleena/CC/work/instructions1.dat";

21 
parameter
 
	gLOG_FILE
="Dual_core_2_ways_single_cycle.log";

23 
genvar
 
	gi
;

24 
integer
 
	gx
;

25 
integer
 
	glog_file
;

26 
integer
 
	gcore_i
;

27 
integer
 
	gcore_finish_count
;

29 
reg
 
	gclock
;

30 
reg
 
	greset
;

31 
reg
 
	gstart
;

32 
	greg
 [
NUM_CORES
*
ADDRESS_BITS
-1:0] 
program_address
;

34 
	gwire
 [
NUM_CORES
*
ADDRESS_BITS
-1:0] 
PC
;

35 
	gwire
 [
ADDRESS_BITS
-1:0] 
PC1
;

36 
	gwire
 [
ADDRESS_BITS
-1:0] 
PC2
;

38 
assign
 
	gPC1
 = 
PC
[0 +: 
ADDRESS_BITS
];

39 
assign
 
	gPC2
 = 
PC
[
ADDRESS_BITS
 +: ADDRESS_BITS];

41 
reg
 
	gscan
;

44 
integer
 
	gcore0_finished
;

45 
integer
 
	gcore1_finished
;

47 
localparam
 
	gTEST_NAME0
="./instructions1.dat";

48 
localparam
 
	gTEST_NAME1
="./instructions1.dat";

51 
	gDual_core_2_ways_single_cycle
 #(

52 .
NUM_CORES
(NUM_CORES),

53 .
DATA_WIDTH
(DATA_WIDTH),

54 .
ADDRESS_BITS
(ADDRESS_BITS),

55 .
MEM_ADDRESS_BITS
(MEM_ADDRESS_BITS),

56 .
SCAN_CYCLES_MIN
(SCAN_CYCLES_MIN),

57 .
	$SCAN_CYCLES_MAX
(
SCAN_CYCLES_MAX
)

58 ) 
	`dut
(

59 .
	`clock
(
clock
),

60 .
	`reset
(
reset
),

61 .
	`start
(
start
),

62 .
	`program_address
(
program_address
),

63 .
	`PC
(
PC
),

64 .
	`scan
(
scan
)

69 
always
 #1 
clock
 = ~clock;

72 
initial
 
begin


73 for (
x
 = 0; x < 2 ** 
MEM_ADDRESS_BITS
; x = x+1) 
begin


74 
dut
.
memory
.
BRAM_inst
.
ram
[
x
] = 32'd0;

75 
end


76 for (
x
 = 0; x < 32; x = x+1) 
begin


77 `
REGISTER_FILE0
[
x
] = 32'd0; `REGISTER_FILE1[x] = 32'
d0
;

78 
end


79 
	`$readmemh
(
PROGRAM
, 
dut
.
memory
.
BRAM_inst
.
ram
);

81 
dut
.
memory
.
BRAM_inst
.
ram
[10] = 32'd1000;

82 
dut
.
memory
.
BRAM_inst
.
ram
[11] = 32'd1050;

83 
dut
.
memory
.
BRAM_inst
.
ram
[5] = 32'd2000;

84 
dut
.
memory
.
BRAM_inst
.
ram
[10] = 32'd2050;

85 
dut
.
memory
.
BRAM_inst
.
ram
[11] = 32'd2080;

86 
dut
.
memory
.
BRAM_inst
.
ram
[12] = 32'd3000;

87 
dut
.
memory
.
BRAM_inst
.
ram
[13] = 32'd1000;

88 
dut
.
memory
.
BRAM_inst
.
ram
[49] = 32'd1050;

89 
dut
.
memory
.
BRAM_inst
.
ram
[50] = 32'd2000;

90 
dut
.
memory
.
BRAM_inst
.
ram
[51] = 32'd2050;

91 
dut
.
memory
.
BRAM_inst
.
ram
[52] = 32'd2080;

92 
dut
.
memory
.
BRAM_inst
.
ram
[53] = 32'd3000;

93 
dut
.
memory
.
BRAM_inst
.
ram
[54] = 32'd1000;

94 
dut
.
memory
.
BRAM_inst
.
ram
[55] = 32'd1050;

95 
dut
.
memory
.
BRAM_inst
.
ram
[56] = 32'd2080;

96 
dut
.
memory
.
BRAM_inst
.
ram
[57] = 32'd3000;

97 
dut
.
memory
.
BRAM_inst
.
ram
[58] = 32'd1000;

98 
dut
.
memory
.
BRAM_inst
.
ram
[59] = 32'd1050;

99 
dut
.
memory
.
BRAM_inst
.
ram
[60] = 32'd2000;

100 
dut
.
memory
.
BRAM_inst
.
ram
[61] = 32'd2050;

101 
dut
.
memory
.
BRAM_inst
.
ram
[62] = 32'd2080;

102 
dut
.
memory
.
BRAM_inst
.
ram
[63] = 32'd3000;

106 
end


109 
integer
 
start_time
;

110 
integer
 
end_time
;

111 
integer
 
total_cycles
;

113 
initial
 
begin


114 
clock
 = 1;

115 
reset
 = 1;

116 
scan
 = 0;

117 
start
 = 0;

118 
core_finish_count
 = 0;

119 for (
core_i
 = 0; core_i < 
NUM_CORES
; core_i = core_i+1) 
begin


120 
program_address
[
core_i
*
ADDRESS_BITS
 +: ADDRESS_BITS] = core_i*32'h0000_0000;

121 
end


123 #10 #1 
reset
 = 0;

124 
start
 = 1;

125 
start_time
 = 
$time
;

128 
start
 = 0;

130 
log_file
 = 
	`$fopen
(
LOG_FILE
, "a+");

131 if (!
log_file
) 
begin


132 
	`$display
("Could not open log file... Exiting!");

133 
	`$finish
();

134 
end


135 #600 
	`$finish
();

136 
end


138 
always
 
begin


144 if ((`
CURRENT_PC0
 == 32'h00000b0 || `CURRENT_PC0 == 32'
h00000b0
) && 
core0_finished
 !== 1) 
begin


145 
end_time
 = 
$time
;

146 
total_cycles
 = (
end_time
-
start_time
)/2;

148 
core_finish_count
 = core_finish_count+1;

149 
core0_finished
 = 1;

150 
	`$display
("\nCore 0 <PROGRAM 1 NAME HERE> is finished!\n");

151 
	`$display
("\nRun Time (cycles): %d", 
total_cycles
);

152 
	`$fdisplay
(
log_file
, "\nRun Time (cycles): %d", 
total_cycles
);

153 if (`
REGISTER_FILE0
[9] == 32'h0000000) begin

154 
	`$display
("<PROGRAM 1 NAME HERE>:\nTest Passed!\n\n");

155 
	`$fdisplay
(
log_file
, "<PROGRAM 1 NAME HERE>:\nTest Passed!\n\n");

156 
end
 else 
begin


157 
	`$display
("<PROGRAM 1 NAME HERE>:\nTest Failed!\n\n");

158 
	`$fdisplay
(
log_file
, "<PROGRAM 1 NAME HERE>:\nTest Failed!\n\n");

159 
	`$display
("Dumping reg file states:");

160 
	`$fdisplay
(
log_file
, "Dumping reg file states:");

161 
	`$display
("Reg Index, Value");

162 
	`$fdisplay
(
log_file
, "Reg Index, Value");

163 for (
x
 = 0; x < 32; x = x+1) 
begin


164 
	`$display
("%d: %h", 
x
, `
REGISTER_FILE0
[x]);

165 
	`$fdisplay
(
log_file
, "%d: %h", 
x
, `
REGISTER_FILE0
[x]);

166 
end


167 
	`$display
("");

168 
	`$fdisplay
(
log_file
, "");

169 
end


171 if (
core_finish_count
 == 
NUM_CORES
) 
begin


172 
	`$display
("Finished running tests for %d cores\n", 
core_finish_count
);

173 
	`$fclose
(
log_file
);

174 
	`$stop
();

175 
end


176 
end


179 if ((`
CURRENT_PC1
 == 32'h0000168 || `CURRENT_PC1 == 32'
h0000168
) && 
core1_finished
 !== 1) 
begin


180 
end_time
 = 
$time
;

181 
total_cycles
 = (
end_time
-
start_time
)/2;

183 
core_finish_count
 = core_finish_count+1;

184 
core1_finished
 = 1;

185 
	`$display
("\nCore 1 <PROGRAM 2 NAME HERE> is finished!\n");

186 
	`$display
("\nRun Time (cycles): %d", 
total_cycles
);

187 
	`$fdisplay
(
log_file
, "\nRun Time (cycles): %d", 
total_cycles
);

188 if (`
REGISTER_FILE1
[9] == 32'h0000000) begin

189 
	`$display
("<PROGRAM 2 NAME HERE>:\nTest Passed!\n\n");

190 
	`$fdisplay
(
log_file
, "<PROGRAM 2 NAME HERE>:\nTest Passed!\n\n");

191 
end
 else 
begin


192 
	`$display
("<PROGRAM 2 NAME HERE>:\nTest Failed!\n\n");

193 
	`$fdisplay
(
log_file
, "<PROGRAM 2 NAME HERE>:\nTest Failed!\n\n");

194 
	`$display
("Dumping reg file states:");

195 
	`$fdisplay
(
log_file
, "Dumping reg file states:");

196 
	`$display
("Reg Index, Value");

197 
	`$fdisplay
(
log_file
, "Reg Index, Value");

198 for (
x
 = 0; x < 32; x = x+1) 
begin


199 
	`$display
("%d: %h", 
x
, `
REGISTER_FILE1
[x]);

200 
	`$fdisplay
(
log_file
, "%d: %h", 
x
, `
REGISTER_FILE1
[x]);

201 
end


202 
	`$display
("");

203 
	`$fdisplay
(
log_file
, "");

204 
end


206 if (
core_finish_count
 == 
NUM_CORES
) 
begin


207 
	`$display
("Finished running tests for %d cores\n", 
core_finish_count
);

208 
	`$fclose
(
log_file
);

209 
	`$stop
();

210 
end


211 
end


213 
end


215 
endmodule


	@writeback_unit.v

22 
module
 
	gwriteback_unit
 #(

23 
parameter
 
	gCORE
 = 0,

24 
parameter
 
	gDATA_WIDTH
 = 32,

25 
parameter
 
	gSCAN_CYCLES_MIN
 = 0,

26 
parameter
 
	gSCAN_CYCLES_MAX
 = 1000

28 
input
 
clock
,

29 
input
 
	greset
,

31 
input
 
	gopWrite
,

32 
input
 
	gopSel
,

33 
	ginput
 [4:0] 
opReg
,

34 
	ginput
 [
DATA_WIDTH
-1:0] 
ALU_result
,

35 
	ginput
 [
DATA_WIDTH
-1:0] 
memory_data
,

37 
output
 
	gwrite
,

38 
	goutput
 [4:0] 
write_reg
,

39 
	goutput
 [
DATA_WIDTH
-1:0] 
write_data
,

41 
input
 
	gscan


45 
assign
 
	gwrite_data
 = 
opSel
? 
memory_data
 : 
ALU_result
;

46 
assign
 
	gwrite_reg
 = 
opReg
;

47 
assign
 
	gwrite
 = 
opWrite
;

49 
	greg
 [31: 0] 
cycles
;

50 
	galways
 @ (
posedge
 
	gclock
) 
begin


51 
	gcycles
 <= 
reset
? 0 : 
cycles
 + 1;

52 if (
	gscan
 & ((
	gcycles
 >= 
SCAN_CYCLES_MIN
) & (
cycles
 <= 
SCAN_CYCLES_MAX
)) )
begin


53 
$display
 ("------ Core %d Writeback Unit - Current Cycle %d ----", 
CORE
, 
cycles
);

54 
$display
 ("| opSel [%b]", 
opSel
);

55 
$display
 ("| opReg [%b]", 
opReg
);

56 
$display
 ("| ALU_result [%d]", 
ALU_result
);

57 
$display
 ("| Memory_data [%d]", 
memory_data
);

58 
$display
 ("| write [%b]", 
write
);

59 
$display
 ("| write_reg [%d]", 
write_reg
);

60 
$display
 ("| write_data [%d]", 
write_data
);

61 
$display
 ("----------------------------------------------------------------------");

62 
end


63 
end


65 
	gendmodule


	@
1
.
0
40
708
ALU.v
BRAM.v
Dual_core_2_ways_single_cycle.v
L1_bus_interface.v
L1cache_wrapper.v
Lx_bus_interface.v
Lxcache_controller.v
Lxcache_wrapper.v
arbiter.v
cache_controller.v
cache_hierarchy.v
cache_memory.v
coherence_controller.v
control_unit.v
decode_unit.v
dual_port_ram.v
dual_port_ram_with_pass_through.v
empty_way_select.v
execution_unit.v
fetch_issue.v
fetch_receive.v
hazard_detection_unit.v
lru.v
main_memory.v
main_memory_interface.v
memory_interface.v
memory_issue.v
memory_receive.v
mux_bus.v
one_hot_decoder.v
one_hot_encoder.v
params.h
priority_encoder.v
regFile.v
replacement_controller.v
single_cycle_control_unit.v
single_cycle_core.v
snooper.v
tb_Dual_core_2_ways_single_cycle.v
writeback_unit.v
